import os
import time
import uuid
from datetime import datetime
from pathlib import Path
from python_on_whales.components.container.cli_wrapper import Container
from python_on_whales.exceptions import DockerException
from rigel.clients import DockerClient
from rigel.loggers import get_logger
from rigel.models.application import Application
from rigel.models.builder import ModelBuilder
from rigel.models.plugin import PluginRawData
from rigel.models.rigelfile import RigelfileGlobalData
from rigel.plugins import Plugin as PluginBase
from typing import Any, Dict, List, Optional, Tuple
from .models import PluginModel, ApplicationComponent

LOGGER = get_logger()


class Plugin(PluginBase):

    """
    Simulates a ROS (Robot Operating System) environment, creating and managing
    containers for ROS nodes. It sets up and starts the simulation, allows the
    nodes to run for a specified duration or indefinitely, and then stops and
    cleans up the containers and network.

    Attributes:
        model (PluginModel): Initialized through a call to `ModelBuilder.build`.
            It represents the model for the simulation, which contains components
            to be run as part of the simulation.
        raw_data (PluginRawData): Passed to the class during initialization. Its
            purpose is not explicitly stated, but it seems to provide raw data for
            building a model used in the simulation.
        __simulation_uuid (str|uuidUUID): Generated by `uuid.uuid1()` function,
            which generates a universally unique identifier (UUID) version 1. It
            is used as part of network names and container names for Docker
            containers in simulation setup.
        __network_name (str): Generated from a UUID, used as a prefix for naming
            Docker networks created by this plugin. It's set to `'rigel-simulation-{self.__simulation_uuid}'`.
        __docker_client (DockerClient): Used to interact with the Docker container
            management system. It allows methods such as creating, running, stopping,
            removing containers and networks.

    """
    def __init__(
        self,
        raw_data: PluginRawData,
        global_data: RigelfileGlobalData,
        application: Application,
        providers_data: Dict[str, Any],
        shared_data: Dict[str, Any] = {}  # noqa
    ) -> None:
        """
        Initializes an instance with raw data, global data, application, and
        providers data. It then creates a model using the raw data and sets
        simulation UUID, network name, and Docker client for further processing.

        Args:
            raw_data (PluginRawData): Used to initialize an instance of the class.
                It represents raw data specific to the plugin, but its exact nature
                is not further specified.
            global_data (RigelfileGlobalData): Required for initialization.
            application (Application): Used to initialize the object.
            providers_data (Dict[str, Any]): Optional with default value `{}`. It
                represents a dictionary where keys are strings and values can be
                any type (Any).
            shared_data (Dict[str, Any]): Optional with default value `{}`. It
                allows additional shared data to be passed to the instance.

        """
        super().__init__(
            raw_data,
            global_data,
            application,
            providers_data,
            shared_data
        )

        # Ensure model instance was properly initialized
        self.model = ModelBuilder(PluginModel).build([], self.raw_data)
        assert isinstance(self.model, PluginModel)

        self.__simulation_uuid = str(uuid.uuid1())
        self.__network_name = f'rigel-simulation-{self.__simulation_uuid}'
        self.__docker_client = DockerClient()

    def create_simulation_network(self) -> None:
        """
        Creates a new Docker network with the name specified by `self.__network_name`
        and sets its type to 'bridge'. It then logs an informational message
        indicating the successful creation of the network.

        """
        self.__docker_client.create_network(self.__network_name, 'bridge')
        LOGGER.info(f"Created Docker network '{self.__network_name}'")

    def start_ros_master(self) -> None:
        """
        Creates and starts a Docker container for running ROS (Robot Operating
        System) master node, specifying its hostname, command, environment variables,
        network, and detaching it from the calling process.

        """
        master_container = f'master-{self.__simulation_uuid}'
        self.__docker_client.run_container(
            master_container,
            f'ros:{self.application.distro}',
            hostname=master_container,
            command=['roscore'],
            envs={
                'ROS_HOSTNAME': master_container,
                'ROS_MASTER_URI': f'http://{master_container}:11311'
            },
            networks=[self.__network_name],
            detach=True
        )
        LOGGER.info(f"Created ROS master '{master_container}'")

    def stop_ros_master(self) -> None:
        """
        Removes a Docker container corresponding to a ROS (Robot Operating System)
        master with a specified simulation UUID, and logs an informative message
        indicating the successful stop operation.

        """
        master_container = f'master-{self.__simulation_uuid}'
        self.__docker_client.remove_container(master_container)
        LOGGER.info(f"Stopped ROS master '{master_container}'")

    def remove_simulation_network(self) -> None:
        """
        Removes a specified Docker network with the name stored in the `__network_name`
        attribute using the Docker client, and logs an informational message to
        indicate successful removal.

        """
        self.__docker_client.remove_network(self.__network_name)
        LOGGER.info(f"Removed Docker network '{self.__network_name}'")

    def convert_envs(self, envs: List[str]) -> Dict[str, str]:
        """
        Converts a list of strings representing environment variables into a
        dictionary, where each string is split into a key-value pair at the '='
        character and the resulting values are stripped of leading and trailing
        whitespace characters.

        Args:
            envs (List[str]): Expected to be a list of strings, where each string
                represents an environment variable in the format 'key=value'.

        Returns:
            Dict[str, str]: A dictionary where each key-value pair represents an
            environment variable and its corresponding value. The keys are strings
            that were previously used as environment variable names and the values
            are strings representing their assigned values.

        """
        result = {}
        for env in envs:
            key, value = env.split('=')
            result[key.strip()] = value.strip()
        return result

    def bringup_ros_nodes(self) -> None:
        """
        Brings up ROS (Robot Operating System) nodes by creating and running
        containers for each test component, waiting for the master container to
        be running, and logging information about created containers and their IP
        addresses.

        """
        master_container = f'master-{self.__simulation_uuid}'
        self.__docker_client.wait_for_container_status(master_container, 'running')
        master_container = self.__docker_client.get_container(master_container)
        assert master_container
        master_ip = master_container.network_settings.networks[self.__network_name].ip_address

        # Start containerize ROS application
        for test_component in self.model.components:

            container = self.run_package_container(test_component, master_ip)
            # container = self.run_package_container(test_component, master_container)

            if container:

                container_ip = container.network_settings.networks[self.__network_name].ip_address
                LOGGER.info(f"Created container '{test_component.name}-{self.__simulation_uuid}' ({container_ip} -> {master_ip})")

    def run_package_container(self, component: ApplicationComponent, master: str) -> Optional[Container]:
        """
        Runs a Docker container for an ApplicationComponent, setting environment
        variables and configuring it to run detached with restart on failure. The
        function returns the created Container object after waiting for its status
        to become 'running'.

        Args:
            component (ApplicationComponent): Required to run the package container.
                It represents an application component that needs to be executed
                within the container, with its name, image, and other relevant details.
            master (str): Used to set the ROS master URI environment variable
                within the container to a specific IP address and port, for example
                'http://localhost:11311'.

        Returns:
            Optional[Container]: Either a Container object or None. It represents
            the created container if the container was successfully run, otherwise,
            it returns None.

        """
        component_name = f"{component.name}-{self.__simulation_uuid}"
        kwargs = component._kwargs.copy()

        kwargs['detach'] = True
        kwargs['hostname'] = component_name

        if 'envs' not in kwargs:
            kwargs['envs'] = {}
        kwargs['envs']['ROS_MASTER_URI'] = f'http://{master}:11311'
        kwargs['envs']['ROS_HOSTNAME'] = f"{kwargs['hostname']}"

        # TODO: ensure that networks can be costumized.
        # Probably not required.
        kwargs['networks'] = [self.__network_name]

        if 'restart' not in kwargs:
            kwargs['restart'] = 'on-failure'

        container = self.__docker_client.run_container(
            component_name,
            component.image,
            **kwargs
        )
        self.__docker_client.wait_for_container_status(component_name, 'running')

        if component.introspection:
            self.shared_data["simulation_address"] = container.network_settings.networks[self.__network_name].ip_address

        return self.__docker_client.get_container(component_name)  # this call to 'get_container' ensures updated container data

    def remove_package_containers(self) -> None:
        """
        Iterates through its components, removes Docker containers associated with
        each component based on the simulation UUID, and logs removal events.

        """
        for test_component in self.model.components:
            component_name = f"{test_component.name}-{self.__simulation_uuid}"
            self.__docker_client.remove_container(component_name)
            LOGGER.info(f"Removed Docker container '{component_name}'")

    def copy_files(self) -> None:
        """
        Copies files from Docker containers to a local directory structure based
        on the timestamp. It iterates over test components, extracts artifacts,
        and saves them locally with their original directory hierarchy.

        """
        root_path = f"/home/{os.environ.get('USER')}/.rigel/archives/test"
        base_path = Path(f"{root_path}/{datetime.now().strftime('%d-%m-%Y-%H-%M-%S')}")
        latest_path = Path(f"{root_path}/latest")

        copied_files = False
        for test_component in self.model.components:

            component_name = f"{test_component.name}-{self.__simulation_uuid}"

            component_container = self.__docker_client.get_container(component_name)
            assert isinstance(component_container, Container)

            if test_component.artifacts:

                base_path.mkdir(parents=True, exist_ok=True)

                LOGGER.info(f"Saving files from component '{test_component.name}':")
                for file in test_component.artifacts:

                    complete_file_path = Path(f"{base_path}/{test_component.name}")
                    complete_file_path.mkdir(parents=True, exist_ok=True)

                    try:

                        component_container.copy_from(Path(file), complete_file_path)

                        filename = file.rsplit('/')[-1]
                        LOGGER.info(f"- {file} -> {str(complete_file_path.absolute())}/{filename}")
                        copied_files = True

                    except DockerException:

                        LOGGER.warning(f"File '{file}' does not exist inside container '{component_name}'. Ignoring.")

        if copied_files:

            if latest_path.exists():
                latest_path.unlink()
            latest_path.symlink_to(base_path)

    def setup(self) -> None:
        """
        Initializes a simulation network and starts a ROS (Robot Operating System)
        master process, setting up the environment for subsequent actions.

        """
        self.create_simulation_network()
        self.start_ros_master()

    def start(self) -> None:
        """
        Initializes ROS nodes and sets the simulation duration to the timeout value
        defined by the model. This is done by calling the `bringup_ros_nodes`
        method and updating the shared data dictionary with the simulation duration.

        """
        self.bringup_ros_nodes()
        self.shared_data["simulation_duration"] = self.model.timeout

    def process(self) -> None:

        """
        Initializes logging and then waits for a specified timeout period before
        starting an infinite loop if no timeout is provided, indicating that
        containers will run indefinitely.

        """
        LOGGER.info("Press CTRL-C/CTRL-Z to stop plugin execution.")

        if self.model.timeout:
            time.sleep(self.model.timeout)
        else:
            LOGGER.warning("Containers will run indefinitely since no timeout value was provided.")
            while True:
                pass  # do nothing until user CTRL-Z

    def stop(self) -> None:
        """
        Terminates the plugin's activities by copying files, stopping ROS master,
        removing package containers, and eliminating simulation networks. This
        ensures proper shutdown and cleanup when the plugin is terminated or restarted.

        """
        self.copy_files()
        self.stop_ros_master()
        self.remove_package_containers()
        self.remove_simulation_network()
