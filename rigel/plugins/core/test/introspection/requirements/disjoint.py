from rigel.plugins.core.test.introspection.command import (
    Command,
    CommandBuilder,
    CommandType
)
from .node import SimulationRequirementNode


class DisjointSimulationRequirementNode(SimulationRequirementNode):
    """
    Simulates a node in a hierarchical system, managing its children's status and
    triggering actions upon certain events or commands from upstream or downstream
    nodes. It updates its own state based on child node satisfaction and sends
    notifications accordingly.

    Attributes:
        children (List[SimulationRequirementNode]): Initialized to an empty list
            during object creation. It stores child nodes that are connected to
            this node.
        father (None|SimulationRequirementNode): Initialized to None. It represents
            the parent node for a child node within a hierarchical simulation
            requirement structure.
        trigger (bool): Initially set to False. It is used to track whether a
            trigger event has occurred, which can affect the node's state and
            downstream commands.
        last_message (float): 0.0 by default. It keeps track of the last message
            received, possibly indicating a timestamp for messages or events
            processed by this node.

    """

    def __init__(self) -> None:
        """
        Initializes an instance by setting up three attributes: `children` (a
        list), `father` (None), and two booleans (`trigger` and `last_message`).
        This suggests that the class is used for node-based simulations or
        requirements tracking.

        """
        self.children = []
        self.father = None

        # Flag that signals when to stop listening for incoming ROS messages.
        self.trigger: bool = False

        # Store the timestamp when a child was last satisfy.
        self.last_message: float = 0.0

    def __str__(self) -> str:
        """
        Converts the object to its string representation by recursively concatenating
        the string representations of all child objects stored in the children attribute.

        Returns:
            str: A string representation of an object, generated by concatenating
            strings from its child objects.

        """
        repr = ''
        for child in self.children:
            repr += f'{str(child)}'
        return repr

    def assess_children_nodes(self) -> bool:
        """
        Traverses its children, checks if any child's `satisfied` attribute is
        True, and returns True as soon as it finds a satisfied child. If no satisfied
        child is found, it returns False.

        Returns:
            bool: True if any child node's `satisfied` attribute is True, and False
            otherwise, indicating whether at least one child node has satisfied
            its requirements.

        """
        for child in self.children:

            # NOTE: the following assertion is required so that mypy
            # doesn't throw an error related with multiple inheritance.
            # All 'children' are of type CommandHandler and
            # 'satisfied' is a member of SimulationRequirementNode
            # that inherits from CommandHandler.
            assert isinstance(child, SimulationRequirementNode)

            if child.satisfied:
                return True
        return False

    def handle_trigger(self, command: Command) -> None:
        """
        Sets the `trigger` attribute to True and sends a downstream command when
        triggered.

        Args:
            command (Command): Expected to be an object that represents a command
                or instruction that needs to be executed.

        """
        self.trigger = True
        self.send_downstream_cmd(command)

    def handle_children_status_change(self) -> None:
        """
        Handles changes in the status of its child nodes by updating its own
        satisfied state and sending an upstream command to notify about the change.
        It only considers state changes if they are not already satisfied.

        """
        if self.assess_children_nodes() != self.satisfied:  # only consider state changes
            self.satisfied = not self.satisfied

            # Inform father node about state change.
            command = CommandBuilder.build_status_change_cmd()
            self.send_upstream_cmd(command)

    def handle_upstream_command(self, command: Command) -> None:
        """
        Handles an upstream command by checking its type. If the command is a
        status change, it invokes the `handle_children_status_change` method to
        process this event. The function does not return any value.

        Args:
            command (Command): Expected to be an object with a defined attribute
                `type`. The `CommandType` is presumably an enumeration or class
                that defines different types of commands.

        """
        if command.type == CommandType.STATUS_CHANGE:
            self.handle_children_status_change()

    def handle_downstream_command(self, command: Command) -> None:
        """
        Processes incoming downstream commands and dispatches them to appropriate
        handlers based on their types. It sends connect/disconnect commands to a
        specified function, while trigger commands are handled by another method
        within the class.

        Args:
            command (Command): Required for the execution of this method. It
                represents a downstream command that needs to be processed by the
                class instance.

        """
        if command.type in [CommandType.ROSBRIDGE_CONNECT, CommandType.ROSBRIDGE_DISCONNECT]:
            self.send_downstream_cmd(command)
        elif command.type == CommandType.TRIGGER:
            self.handle_trigger(command)
