import roslibpy
from rigel.exceptions import ClientError
from typing import Any, Callable, Dict, List, Optional, Tuple


MAX_CONNECTION_ATTEMPTS = 15
ROS_MESSAGE_TYPE = Dict[str, Any]
ROS_MESSAGE_HANDLER_TYPE = Callable[[ROS_MESSAGE_TYPE], None]


def client_is_active(f: Callable) -> Callable:
    """
    Returns a decorator that wraps a given function (`f`) to check if a client
    object's `rosbridge_client` attribute is not None before executing the wrapped
    function. If the client is active, it executes the original function with the
    provided arguments.

    Args:
        f (Callable): Passed to this function. It represents a function that takes
            self as its first argument, followed by any number of positional and
            keyword arguments.

    Returns:
        Callable: A decorator that can be used to check if the client is active
        before calling a method `f`. If the client is active, it calls the original
        method `f`; otherwise, it does nothing.

    """
    def wrapper(self, *args, **kwargs):
        """
        Checks if an instance variable `rosbridge_client` exists and returns its
        value if it does. The returned value is generated by calling another
        function `f` with the current object (`self`) and any additional arguments
        (`*args`, **kwargs`).

        Args:
            self (object): Used to pass implicit reference of the instance of a
                class. It allows the method called by this wrapper to access and
                modify attributes and methods of the class.
            *args (list): List of positional arguments
            **kwargs (dict): Dictionary of keyword arguments

        Returns:
            str|Any: Obtained by calling the function `f` with arguments `self`,
            `*args`, and `**kwargs`. The return value depends on the implementation
            of function `f`.

        """
        if self.rosbridge_client is not None:
            return f(self, *args, **kwargs)
    return wrapper


class ROSBridgeClient:
    """
    Connects to a ROS bridge, registers and removes message handlers for specific
    topics and message types, and manages subscribers. It persists connections
    until explicitly closed or an error occurs.

    Attributes:
        handlers (Dict[Tuple[str, str], List[ROS_MESSAGE_HANDLER_TYPE]]): Used to
            store registered message handlers for specific topics and message
            types. It maps keys (topic, message_type) to lists of handler functions.
        subscribers (Dict[Tuple[str, str], roslibpy.core.Topic]): Used to keep
            track of all the topics subscribed by the client. Each topic subscription
            is represented as a key-value pair where the key is a tuple of
            (topic_name, message_type) and the value is the corresponding `Topic`
            object from `roslibpy`.
        rosbridge_client (Optional[roslibpy.Ros]): Initialized with a roslibpy.Ros
            object in the `__init__` method, allowing for connection to a ROS bridge.
        host (str): Initialized to 'localhost'. It specifies the hostname or IP
            address of the ROS bridge server that this client will connect to.
        port (int): 9090 by default. It specifies the port number to which the ROS
            bridge client connects for communication with the ROS master.
        __persist (bool): Initially set to `True`. It determines whether the client
            should continue attempting to establish a connection when encountering
            exceptions during startup or shutdown operations.

    """

    handlers: Dict[Tuple[str, str], List[ROS_MESSAGE_HANDLER_TYPE]]
    subscribers: Dict[Tuple[str, str], roslibpy.core.Topic]

    rosbridge_client: Optional[roslibpy.Ros] = None

    def __init__(self, host: str = 'localhost', port: int = 9090) -> None:
        """
        Initializes an instance by setting up internal data structures and
        establishing a connection to a ROS (Robot Operating System) bridge client.
        It takes optional host and port parameters, defaulting to 'localhost' and
        9090 respectively.

        Args:
            host (str): Set to 'localhost' by default. It represents the host name
                or IP address where the ROS (Robot Operating System) bridge is
                running, allowing connections from clients.
            port (int): 9090 by default. It specifies the port number to which the
                Rosbridge client connects when establishing a connection with the
                ROS (Robot Operating System).

        """
        self.handlers = {}
        self.subscribers = {}
        self.host = host
        self.port = port

        self.__persist = True

        self.rosbridge_client = roslibpy.Ros(host=host, port=port)

    @client_is_active
    def connect(self, retries=MAX_CONNECTION_ATTEMPTS) -> None:

        """
        Attempts to connect to a ROS bridge server specified by `self.host` and
        `self.port`, retrying up to `MAX_CONNECTION_ATTEMPTS` times if failed, and
        raises an exception if all retries fail.

        Args:
            retries (int): 30 by default. It determines how many times to retry
                connecting to the ROS bridge if an attempt fails, before raising
                a ClientError with details about the exception.

        """
        attempts = 0
        while self.__persist:
            try:
                print(f"Attempting connection to '{self.host}:{self.port}'")
                self.rosbridge_client.run()
                break
            except Exception as exception:
                if attempts < retries:
                    attempts = attempts + 1
                else:
                    raise ClientError('ROS bridge', exception)

    def __create_generic_message_handler(self, topic: str, message_type: str) -> ROS_MESSAGE_HANDLER_TYPE:
        """
        Creates a generic message handler for a given topic and message type. The
        handler function calls all registered message handlers for that topic and
        message type, passing the received message to each handler.

        """
        def handler_function(message: ROS_MESSAGE_TYPE) -> None:
            """
            Maps a combination of a topic and message type to a list of handlers,
            and then invokes each handler in the list with the given message as
            its argument. This allows for flexible and dynamic handling of messages
            based on their topic and type.

            Args:
                message (ROS_MESSAGE_TYPE): Expected to be an instance of a specific
                    type, representing a message received from a topic of interest.

            """
            key = (topic, message_type)
            if key in self.handlers:
                for message_handler in self.handlers[key]:
                    message_handler(message)

        return handler_function

    @client_is_active
    def register_message_handler(self, topic: str, message_type: str, handler: ROS_MESSAGE_HANDLER_TYPE) -> None:
        """
        Registers a message handler for a specified topic and message type, ensuring
        that no duplicate handlers are registered. If no existing handler exists,
        it creates a new subscriber to receive messages of that type from the topic.

        Args:
            topic (str): Required to be passed while registering a message handler.
                It represents the topic for which the provided message handler
                will be registered on the ROS (Robot Operating System) system.
            message_type (str): Used to specify the message type that corresponds
                to the topic where messages are being published or subscribed.
            handler (ROS_MESSAGE_HANDLER_TYPE): Expected to be a callback function
                that will be called when a message of the specified topic and
                message type is received from the ROS node.

        """
        key = (topic, message_type)

        # Verify if any other handler already exists for the same topic and message type.
        if key in self.handlers:

            if handler not in self.handlers[key]:
                self.handlers[key].append(handler)

        else:  # register provided handler and create new subscriber for the specified topic and message type.

            self.handlers[key] = [handler]

        subscriber = roslibpy.Topic(self.rosbridge_client, topic, message_type)
        subscriber.subscribe(self.__create_generic_message_handler(topic, message_type))
        self.subscribers[key] = subscriber

    @client_is_active
    def remove_message_handler(self, topic: str, message_type: str, handler: ROS_MESSAGE_HANDLER_TYPE) -> None:
        """
        Removes a message handler for a specific topic and message type, verifying
        if any other handlers are registered after removal. If not, it also
        unsubscribes from the topic and deletes the key from internal dictionaries.

        Args:
            topic (str): Required, indicating the name of a topic to remove the
                message handler for. It forms part of a key along with the
                `message_type` to uniquely identify the message handlers.
            message_type (str): Used to specify the type of ROS (Robot Operating
                System) message for which a handler needs to be removed. It is
                part of the key that uniquely identifies a handler in the handlers
                dictionary.
            handler (ROS_MESSAGE_HANDLER_TYPE): Used to remove a message handler
                from the list of handlers for a specific topic and message type.

        """
        key = (topic, message_type)
        if key in self.handlers:
            if handler in self.handlers[key]:
                self.handlers[key].remove(handler)

                # Verify if any handler is still registered.
                if not self.handlers[key]:

                    del self.handlers[key]
                    self.subscribers[key].unsubscribe()
                    del self.subscribers[key]

    @client_is_active
    def close(self) -> None:
        """
        Closes the connection to the ROS bridge, unsubscribes all subscribers, and
        resets internal state.

        """
        self.__persist = False
        self.handlers = {}
        for _, subscriber in self.subscribers.items():
            subscriber.unsubscribe()
        self.subscribers = {}

        self.rosbridge_client.close()
