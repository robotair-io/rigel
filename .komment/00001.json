[
  {
    "name": "absence.py",
    "path": "rigel/plugins/core/test/introspection/requirements/absence.py",
    "content": {
      "structured": {
        "description": "An absence simulation requirement node that ensures no ROS messages are received that satisfy a given condition. It uses threading and math libraries from the Python standard library as well as rigel plugins core test introspection command package. The absence simulation requirement node monitors its child nodes for any satisfaction of conditions, cancels timers, sends commands to stop receiving incoming ROS messages and informs father node about state changes upon timeout or status change.",
        "items": [
          {
            "id": "af2b6efb-a607-2382-624e-f72b82e2fd47",
            "ancestors": [],
            "description": "Simulates absence by monitoring its child nodes for satisfaction and sends commands to downstream or upstream nodes based on their status and a specified timeout.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Initialized to an empty list during object creation. It stores child nodes, which are instances of SimulationRequirementNode or its subclasses."
              },
              {
                "name": "father",
                "type_name": "SimulationRequirementNode|None",
                "description": "Initialized to None. It is used to store the parent node of the current node, if any, in a tree-like structure."
              },
              {
                "name": "timeout",
                "type_name": "float|int",
                "description": "0 by default. It represents the time limit for which a simulation requirement should be satisfied, after which it will automatically stop if not met."
              },
              {
                "name": "__timer",
                "type_name": "threadingTimer|None",
                "description": "Initialized with a timer that calls the `handle_timeout` method after a specified timeout period when started."
              },
              {
                "name": "handle_timeout",
                "type_name": "NoneNone",
                "description": "A method that gets called when a timer set in the node times out. It cancels any ongoing simulation if it has not been satisfied by then."
              },
              {
                "name": "satisfied",
                "type_name": "bool",
                "description": "Initially set to True when an instance of this class is created. It indicates whether all child nodes have satisfied their requirements or not."
              }
            ],
            "name": "AbsenceSimulationRequirementNode",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 11,
                "end": 15
              }
            },
            "item_type": "class",
            "length": 64,
            "docLength": 4
          },
          {
            "id": "45afcab0-2b63-5588-8d49-21c75f49a417",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Initializes an instance by setting up attributes for children, father, timeout, and timer. It also sets the initial satisfaction state to True and creates a timer that will call the handle_timeout method after the specified timeout period.",
            "params": [
              {
                "name": "timeout",
                "type_name": "float",
                "description": "0 by default, which specifies the time after which an action should be performed. The value `inf` means that no timeout will occur. It is set to `self.__timer`, which triggers a timeout event when it expires."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_node = AbsenceSimulationRequirementNode(timeout=10)\nabsence_node.handle_rosbridge_connection_commands(CommandBuilder.build_rosbridge_connect_cmd())\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 17,
              "insert": 18,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 7,
            "docLength": null
          },
          {
            "id": "14ee2148-b34f-e58d-1c49-bc0b91ac6c01",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Returns a string representation of itself and its child nodes by recursively concatenating their string representations. This is used to provide a human-readable output for the node and its children.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A string representation of the object, consisting of the string representations of its children. The returned string is created by concatenating the strings of all child objects."
            },
            "usage": {
              "language": "python",
              "code": "node = AbsenceSimulationRequirementNode()\nnode.children.append(SimulationRequirementNode('Child 1'))\nnode.children.append(SimulationRequirementNode('Child 2'))\n\nrepresentation = str(node)\n",
              "description": "\nIn this example, `AbsenceSimulationRequirementNode` is used as a parent node and `SimulationRequirementNode` are its children."
            },
            "name": "__str__",
            "location": {
              "start": 27,
              "insert": 28,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "ab98189a-6885-40b6-ae4f-3d9e1e91d9be",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Iterates over its child nodes, checks if any are satisfied, and returns False if found; otherwise, it returns True, indicating that none of the children are satisfied.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "True if all children nodes are not satisfied and False otherwise, indicating whether there are any child nodes that are already satisfied."
            },
            "usage": {
              "language": "python",
              "code": "absence_simulation_requirement_node = AbsenceSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\nchild3 = SimulationRequirementNode()\n\nabsence_simulation_requirement_node.children.append(child1)\nabsence_simulation_requirement_node.children.append(child2)\nabsence_simulation_requirement_node.children.append(child3)\n\nprint(absence_simulation_requirement_node.assess_children_nodes())  # Returns True\nchild1.satisfied = False\nprint(absence_simulation_requirement_node.assess_children_nodes())  # Returns False",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 33,
              "insert": 34,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 33,
                "end": 40
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 7
          },
          {
            "id": "ce8df2c7-7c84-42a4-6340-39f157448431",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Handles changes in the status of children nodes and triggers corresponding actions, such as disconnecting from Rosbridge, stopping simulation, and updating internal state variables.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_simulation_requirement_node = AbsenceSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nabsence_simulation_requirement_node.children.append(child1)\nabsence_simulation_requirement_node.children.append(child2)\n\nchild1.satisfied = True\nchild2.satisfied = False\n\nabsence_simulation_requirement_node.handle_children_status_change()",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 54,
              "insert": 55,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 54,
                "end": 58
              }
            },
            "item_type": "method",
            "length": 9,
            "docLength": 4
          },
          {
            "id": "58aac08d-4571-4bb9-e14e-0fafffe60947",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Checks if the node's satisfaction status (`self.satisfied`) is not met, and if so, sends a stop simulation command upstream using the provided `CommandBuilder`. This likely handles a timeout condition in an absence simulation requirement.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_node = AbsenceSimulationRequirementNode(timeout=5)\n# ... other code\n",
              "description": "\nThis creates a new instance of `AbsenceSimulationRequirementNode` with a timeout of 5 seconds."
            },
            "name": "handle_timeout",
            "location": {
              "start": 70,
              "insert": 71,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 70,
                "end": 74
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "891f2119-3860-14ac-3f4b-5da7e17d2ea3",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Sends a command downstream and starts a timer if a time limit was specified, allowing execution to be limited by a timeout.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Required."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_node = AbsenceSimulationRequirementNode(timeout=10)\ncommand = Command(type=CommandType.ROSBRIDGE_CONNECT, data=\"connect_command\")\nabsence_node.handle_rosbridge_connection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_connection_commands",
            "location": {
              "start": 78,
              "insert": 79,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 78,
                "end": 85
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 7
          },
          {
            "id": "f002e7ab-1181-428f-2a4e-da97f8cba570",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Cancels any pending timer and sends downstream command when ROS bridge disconnection commands are received.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Required for the method invocation. Its exact nature is not specified by this code snippet, but it likely represents a command related to ROSBridge disconnection."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_simulation = AbsenceSimulationRequirementNode()\ncommand = Command(CommandType.ROSBRIDGE_DISCONNECT)\nabsence_simulation.handle_downstream_command(command)",
              "description": ""
            },
            "name": "handle_rosbridge_disconnection_commands",
            "location": {
              "start": 92,
              "insert": 93,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 92,
                "end": 99
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "8c2dcefd-db45-6a99-314f-084c34fc894c",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Processes an upstream command, specifically checking if the command is of type STATUS_CHANGE. If so, it calls the `handle_children_status_change` method to handle status changes for its children nodes.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to hold an instance of a class representing a command with a specific type, namely CommandType.STATUS_CHANGE."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_node = AbsenceSimulationRequirementNode()\ncommand = Command(CommandType.STATUS_CHANGE, ...)\nabsence_node.handle_upstream_command(command)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 103,
              "insert": 104,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 103,
                "end": 110
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "f873adf4-ba4c-8792-0048-d290f4b9d4cc",
            "ancestors": [
              "af2b6efb-a607-2382-624e-f72b82e2fd47"
            ],
            "description": "Handles downstream commands received from other nodes or systems. It dispatches the commands based on their type, processing ROSbridge connection and disconnection requests, and triggering specific actions for other command types.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Required to be processed by the function. Its type attribute determines which specific handling method should be executed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "absence_sim_node = AbsenceSimulationRequirementNode()\ncommand_rosbridge_connect = Command(CommandType.ROSBRIDGE_CONNECT)\nabsence_sim_node.handle_downstream_command(command_rosbridge_connect)",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 114,
              "insert": 115,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 114,
                "end": 121
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "disjoint.py",
    "path": "rigel/plugins/core/test/introspection/requirements/disjoint.py",
    "content": {
      "structured": {
        "description": "A DisjointSimulationRequirementNode class that is part of a ROS (Robot Operating System) simulation framework. The node represents a logical requirement for a simulation and has children nodes representing specific requirements. It assesses its satisfiability based on the state of its children and notifies its father node when it changes.",
        "items": [
          {
            "id": "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead",
            "ancestors": [],
            "description": "Simulates a node in a hierarchical system, managing its children's status and triggering actions upon certain events or commands from upstream or downstream nodes. It updates its own state based on child node satisfaction and sends notifications accordingly.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Initialized to an empty list during object creation. It stores child nodes that are connected to this node."
              },
              {
                "name": "father",
                "type_name": "None|SimulationRequirementNode",
                "description": "Initialized to None. It represents the parent node for a child node within a hierarchical simulation requirement structure."
              },
              {
                "name": "trigger",
                "type_name": "bool",
                "description": "Initially set to False. It is used to track whether a trigger event has occurred, which can affect the node's state and downstream commands."
              },
              {
                "name": "last_message",
                "type_name": "float",
                "description": "0.0 by default. It keeps track of the last message received, possibly indicating a timestamp for messages or events processed by this node."
              }
            ],
            "name": "DisjointSimulationRequirementNode",
            "location": {
              "start": 9,
              "insert": 10,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 9,
                "end": 12
              }
            },
            "item_type": "class",
            "length": 48,
            "docLength": 3
          },
          {
            "id": "d69a05ac-433b-f085-c647-ab38bf9fe1df",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Initializes an instance by setting up three attributes: `children` (a list), `father` (None), and two booleans (`trigger` and `last_message`). This suggests that the class is used for node-based simulations or requirements tracking.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "disjoint_node = DisjointSimulationRequirementNode()\ndisjoint_node.children.append(SimulationRequirementNode())\ndisjoint_node.father = SimulationRequirementNode()\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 14,
              "insert": 15,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 7,
            "docLength": null
          },
          {
            "id": "8c05f0fa-2bc0-0595-af49-ceb1085560d6",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Converts the object to its string representation by recursively concatenating the string representations of all child objects stored in the children attribute.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A string representation of an object, generated by concatenating strings from its child objects."
            },
            "usage": {
              "language": "python",
              "code": "node = DisjointSimulationRequirementNode()\nnode.children.append(SimulationRequirementNode())\nnode.children.append(SimulationRequirementNode())\n\nresult = str(node)\n",
              "description": ""
            },
            "name": "__str__",
            "location": {
              "start": 24,
              "insert": 25,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "b28a50ca-4337-aeaf-8b4a-8df99dc84a7a",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Traverses its children, checks if any child's `satisfied` attribute is True, and returns True as soon as it finds a satisfied child. If no satisfied child is found, it returns False.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "True if any child node's `satisfied` attribute is True, and False otherwise, indicating whether at least one child node has satisfied its requirements."
            },
            "usage": {
              "language": "python",
              "code": "disjoint_simulation_requirement_node = DisjointSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\ndisjoint_simulation_requirement_node.children.append(child1)\ndisjoint_simulation_requirement_node.children.append(child2)\n\nchild1.satisfied = True\n\nresult = disjoint_simulation_requirement_node.assess_children_nodes()",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 30,
              "insert": 31,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 30,
                "end": 37
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 7
          },
          {
            "id": "2493a77c-57aa-bbae-da43-9091708dbbe1",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Sets the `trigger` attribute to True and sends a downstream command when triggered.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an object that represents a command or instruction that needs to be executed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = DisjointSimulationRequirementNode()\ncommand = Command(type=CommandType.TRIGGER, data=\"Trigger\")\nnode.handle_trigger(command)",
              "description": ""
            },
            "name": "handle_trigger",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 51,
                "end": 57
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "1ee1db90-18e6-b6a1-be41-1247387af483",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Handles changes in the status of its child nodes by updating its own satisfied state and sending an upstream command to notify about the change. It only considers state changes if they are not already satisfied.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node1 = DisjointSimulationRequirementNode()\nnode2 = SimulationRequirementNode()\nnode3 = SimulationRequirementNode()\n\nnode1.children.append(node2)\nnode1.children.append(node3)\n\nnode2.satisfied = True\n\nnode1.handle_children_status_change()",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 61,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 61,
                "end": 65
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 4
          },
          {
            "id": "2e2ed2b0-4892-2d9a-cf4c-c421bb3e4976",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Handles an upstream command by checking its type. If the command is a status change, it invokes the `handle_children_status_change` method to process this event. The function does not return any value.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an object with a defined attribute `type`. The `CommandType` is presumably an enumeration or class that defines different types of commands."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "disjoint_simulation_requirement_node = DisjointSimulationRequirementNode()\ncommand = Command(type=CommandType.STATUS_CHANGE)\ndisjoint_simulation_requirement_node.handle_upstream_command(command)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 73,
              "insert": 74,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 73,
                "end": 80
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "f5a7d95e-8f40-f286-4e4d-26fe98467085",
            "ancestors": [
              "0fa3b0a2-3039-d6ba-b942-ea31f4b53ead"
            ],
            "description": "Processes incoming downstream commands and dispatches them to appropriate handlers based on their types. It sends connect/disconnect commands to a specified function, while trigger commands are handled by another method within the class.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Required for the execution of this method. It represents a downstream command that needs to be processed by the class instance."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "disjoint_simulation_requirement_node = DisjointSimulationRequirementNode()\ndownstream_command = Command(CommandType.TRIGGER)\ndisjoint_simulation_requirement_node.handle_downstream_command(downstream_command)",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 84,
              "insert": 85,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 84,
                "end": 91
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "existence.py",
    "path": "rigel/plugins/core/test/introspection/requirements/existence.py",
    "content": {
      "structured": {
        "description": "A class `ExistenceSimulationRequirementNode` that ensures at least one ROS message satisfying a condition is received within a specified timeout using the `rigel` plugin's `CommandBuilder` and `threading` module. The node has children nodes which are assessed for satisfaction, and if all satisfy, the parent node becomes satisfied.",
        "items": [
          {
            "id": "b4347bab-e298-8380-a142-d95e23b1dfa5",
            "ancestors": [],
            "description": "Simulates a node for existence-based requirements in a simulation. It maintains a list of child nodes, checks their satisfaction status, and handles timer events, ROS bridge connections/disconnections, and upstream commands to manage the simulation according to its timeout and status.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Initialized as an empty list during object creation. It stores child nodes that are part of the simulation requirement tree structure."
              },
              {
                "name": "father",
                "type_name": "SimulationRequirementNode|None",
                "description": "Initialized as None in its constructor. It represents a reference to the parent node, if any, in the tree-like structure."
              },
              {
                "name": "timeout",
                "type_name": "float|inf",
                "description": "0 seconds by default, which means no timeout for handling commands or status changes."
              },
              {
                "name": "__timer",
                "type_name": "threadingTimer|None",
                "description": "Initialized with a Timer object that calls the `handle_timeout` method when it expires after the specified timeout period, if the node's satisfaction status remains unchanged."
              },
              {
                "name": "handle_timeout",
                "type_name": "NoneNone",
                "description": "Called when the timer associated with the node times out. If the satisfaction status of the node is False, it sends a stop simulation command upstream."
              }
            ],
            "name": "ExistenceSimulationRequirementNode",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 11,
                "end": 15
              }
            },
            "item_type": "class",
            "length": 63,
            "docLength": 4
          },
          {
            "id": "0e133740-96b8-bebe-bc44-c91a12658c5e",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Initializes an instance of the node with optional timeout. It sets up lists to hold child nodes, references its father node, and schedules a timer to call the `handle_timeout` method after the specified timeout period if it's not infinite.",
            "params": [
              {
                "name": "timeout",
                "type_name": "float",
                "description": "0 by default. It sets the time limit for the timer. If this value is not provided, it defaults to infinity. This means that if no timeout is specified, the thread will run indefinitely."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode(timeout=5)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 17,
              "insert": 18,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 5,
            "docLength": null
          },
          {
            "id": "6d2983c9-9cc7-cabc-3445-fa956e5fabd5",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Recursively concatenates the string representations of its child nodes and returns the result as a string, representing the node's hierarchical structure.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A string representation of an object. The returned string is constructed by concatenating the string representations of all child objects stored in the `self.children` list."
            },
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode()\nnode.children.append(SimulationRequirementNode())\nnode.children.append(SimulationRequirementNode())\n\nresult = str(node)\n",
              "description": "\nIn this case, `result` will hold a string representation of all children nodes in the `ExistenceSimulationRequirementNode`."
            },
            "name": "__str__",
            "location": {
              "start": 23,
              "insert": 24,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "7f0b274d-aaaa-bda2-c94b-c249df02cae4",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Traverses its children nodes, checks if each child node's `satisfied` attribute is True, and returns False as soon as it finds a non-satisfied child node; otherwise, it returns True.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "`True` if all children nodes are satisfied and `False` otherwise. It checks each child node's `satisfied` attribute, returning immediately if any node is not satisfied. If all nodes are satisfied, it returns `True`."
            },
            "usage": {
              "language": "python",
              "code": "sim = ExistenceSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nsim.children.append(child1)\nsim.children.append(child2)\n\nchild1.satisfied = True\nchild2.satisfied = False\n\nresult = sim.assess_children_nodes()",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 29,
              "insert": 30,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 29,
                "end": 36
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 7
          },
          {
            "id": "348bf422-ae58-7397-ac46-d44c562f98bc",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Updates the node's status when its children nodes change their status, cancels any ongoing timers, and sends commands to stop receiving ROS messages and notify upstream nodes about the status change.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode()\nnode.children.append(SimulationRequirementNode())\nnode.children.append(SimulationRequirementNode())\n\nif node.handle_children_status_change():\n    # This code will execute if all children nodes' status is satisfied.\n    pass",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 50,
                "end": 54
              }
            },
            "item_type": "method",
            "length": 10,
            "docLength": 4
          },
          {
            "id": "7b335d28-a029-3da5-0244-c1140d1f1a55",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Stops a simulation when a timeout occurs if the requirement is not already satisfied.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode(timeout=10)\n# some actions here...\n",
              "description": "\nPlease note that this is a simplified version and in real scenarios more complex setup should be done."
            },
            "name": "handle_timeout",
            "location": {
              "start": 66,
              "insert": 67,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 66,
                "end": 70
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "70523e0f-1d17-b5ab-da44-a5e5c47b5e95",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Handles ROS bridge connection commands, sending them downstream and starting a timer if a time limit is specified.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Passed to this function. The actual details about the structure or content of the `Command` are not provided here, but it seems to be related to ROS (Robot Operating System) commands."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode(timeout=10)\ncommand = Command(CommandType.ROSBRIDGE_CONNECT, \"localhost\")\nnode.handle_rosbridge_connection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_connection_commands",
            "location": {
              "start": 74,
              "insert": 75,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 74,
                "end": 81
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 7
          },
          {
            "id": "b5a57190-b749-dbaa-3e4c-3bbbf515eda5",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Handles ROSBridge disconnection commands by canceling any existing timer and sending a downstream command to handle the disconnection event.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Passed into this function. The exact nature and structure of the Command object are not provided, but it appears to be some sort of input or data that the function operates on."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode()\ncommand = Command(CommandType.ROSBRIDGE_DISCONNECT, \"disconnect\")\nnode.handle_rosbridge_disconnection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_disconnection_commands",
            "location": {
              "start": 88,
              "insert": 89,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 88,
                "end": 95
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "17d67e56-7c90-919f-a74d-6c93d114b4ef",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Handles an upstream command by checking its type. If the command type is STATUS_CHANGE, it calls the `handle_children_status_change` method to handle the status change of children nodes.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an instance of the class or one of its subclasses, representing some type of command with specific properties and methods."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode()\ncommand = Command(CommandType.STATUS_CHANGE)\nnode.handle_upstream_command(command)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 99,
              "insert": 100,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 99,
                "end": 106
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "69d45bdb-33a1-c8a3-0448-7a0f303243b4",
            "ancestors": [
              "b4347bab-e298-8380-a142-d95e23b1dfa5"
            ],
            "description": "Processes incoming commands from downstream systems. Based on the command type, it dispatches to separate methods for handling rosbridge connection/disconnection and trigger events.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Used to determine which specific handling method should be invoked based on its type."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ExistenceSimulationRequirementNode()\ncommand = Command(CommandType.TRIGGER)\nnode.handle_downstream_command(command)",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 110,
              "insert": 111,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 110,
                "end": 117
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "manager.py",
    "path": "rigel/plugins/core/test/introspection/requirements/manager.py",
    "content": {
      "structured": {
        "description": "A class `SimulationRequirementsManager` which manages simulation requirements and provides control over associated node trees. It uses ROSBridgeClient for communicating with ROS messages and CommandBuilder for creating commands. The manager is responsible for assessing satisfaction of all simulation requirements by monitoring children nodes, stopping simulation when all requirements are satisfied or after timeout.",
        "items": [
          {
            "id": "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86",
            "ancestors": [],
            "description": "Manages simulation requirements and their children, connecting to a ROSBridge client, starting/stopping timers, sending commands downstream, assessing child nodes' satisfaction, and handling state changes and stop simulations requests.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Initialized as an empty list during object creation."
              },
              {
                "name": "father",
                "type_name": "SimulationRequirementNode|None",
                "description": "Initialized to None. It represents the parent node in a tree-like structure, where children are added using the add_child method."
              },
              {
                "name": "finished",
                "type_name": "bool",
                "description": "Initially set to False. It indicates whether a simulation has finished or not, which can be changed by calling the stop_simulation method."
              },
              {
                "name": "__introspection_started",
                "type_name": "bool",
                "description": "Initially set to False when a simulation starts. It tracks whether the introspection process has been started or not."
              },
              {
                "name": "__start_timer",
                "type_name": "threadingTimer|None",
                "description": "Initialized to a Timer object that calls the `handle_start_timeout` method after a specified time (min_timeout) has passed."
              },
              {
                "name": "handle_start_timeout",
                "type_name": "NoneNone",
                "description": "Scheduled to be called after a certain period (min_timeout) has passed. It sets `__introspection_started` to True, sends a trigger command downstream, and calls the `handle_children_status_change` method."
              },
              {
                "name": "__stop_timer",
                "type_name": "threadingTimer|None",
                "description": "Initialized with a timeout value equal to `max_timeout`. It triggers the `handle_stop_timeout` method when the timer expires, which stops the simulation."
              },
              {
                "name": "handle_stop_timeout",
                "type_name": "None",
                "description": "Associated with a timer that starts after a certain timeout period (max_timeout)."
              }
            ],
            "name": "SimulationRequirementsManager",
            "location": {
              "start": 12,
              "insert": 13,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 12,
                "end": 16
              }
            },
            "item_type": "class",
            "length": 87,
            "docLength": 4
          },
          {
            "id": "c3faafd8-1fab-f5a2-2a4d-0d1e7b4b5586",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Initializes an instance by setting up timers for starting and stopping timeouts, maintaining lists of children nodes and a father node, tracking whether the simulation has finished, and keeping track of introspection start status.",
            "params": [
              {
                "name": "max_timeout",
                "type_name": "float",
                "description": "Passed to the Timer object for stopping the execution after a maximum allowed time."
              },
              {
                "name": "min_timeout",
                "type_name": "float",
                "description": "0.0 by default. It represents the minimum timeout period for starting a timer that will trigger the `handle_start_timeout` method."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(10.0, 5.0)\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nmanager.add_child(child1)\nmanager.add_child(child2)\n\nmanager.connect_to_rosbridge(ROSBridgeClient())",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 18,
              "insert": 19,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 9,
            "docLength": null
          },
          {
            "id": "9af0bc6d-bcb0-a6a5-fb4b-e20fcfd82192",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Adds a new child node to its list of children, establishing a hierarchical relationship between parent and child nodes by setting the father attribute of the child node to itself (the manager).",
            "params": [
              {
                "name": "child",
                "type_name": "SimulationRequirementNode",
                "description": "Expected to be an instance of this class. It represents the child node that will be added to the current object's list of children."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(10.0, 5.0)\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nmanager.add_child(child1)\nmanager.add_children([child2])",
              "description": ""
            },
            "name": "add_child",
            "location": {
              "start": 28,
              "insert": 29,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "35a70d42-f61c-fa8d-644a-537772b183d3",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Iterates over a list of child nodes, each representing a simulation requirement, and adds each one as a direct child to its parent node using the inherited `add_child` method.",
            "params": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Expected to contain multiple SimulationRequirementNode objects that are going to be added as child nodes to the current node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "simulation_requirements_manager = SimulationRequirementsManager(10.0, 5.0)\nnode1 = SimulationRequirementNode()\nnode2 = SimulationRequirementNode()\nnode3 = SimulationRequirementNode()\n\nsimulation_requirements_manager.add_children([node1, node2, node3])",
              "description": ""
            },
            "name": "add_children",
            "location": {
              "start": 32,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "a5d20904-513d-588b-e247-b293f9ce0d08",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Constructs a string representation of its own simulation requirements by recursively calling itself on child nodes, appending each result with a newline character, and returning the combined string if there are children; otherwise, it returns a default message.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "Either a formatted string representation of all child objects indented with newline characters, if `self.children` is not empty, or the message 'No simulation requirements were provided.' otherwise."
            },
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(max_timeout=10, min_timeout=5)\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nmanager.add_child(child1)\nmanager.add_child(child2)\n\nmanager_str = str(manager)",
              "description": ""
            },
            "name": "__str__",
            "location": {
              "start": 36,
              "insert": 37,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "d34ce33c-95e3-b4be-1045-73623b96bfb2",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Establishes a connection to a ROSBridge client by sending a command through downstream communication, and then starts two timers: start_timer and stop_timer.",
            "params": [
              {
                "name": "rosbridge_client",
                "type_name": "ROSBridgeClient",
                "description": "Expected to be an instance of the ROSBridgeClient class, which represents a client that connects to a ROS bridge."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ros_bridge_client = ROSBridgeClient(\"localhost\", 9090)\nsim_manager = SimulationRequirementsManager(10, 5)\nsim_manager.connect_to_rosbridge(ros_bridge_client)",
              "description": ""
            },
            "name": "connect_to_rosbridge",
            "location": {
              "start": 45,
              "insert": 46,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 45,
                "end": 51
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 6
          },
          {
            "id": "12d37d13-8e78-6bbf-6e4a-ddafcc8c09f1",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Disconnects from a ROS bridge by building a command to do so using CommandBuilder and sending it downstream through send_downstream_cmd.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(5, 1)\nros_bridge_client = ROSBridgeClient()\nmanager.connect_to_rosbridge(ros_bridge_client)\n\n# Later in the code...\n\nmanager.disconnect_from_rosbridge()",
              "description": ""
            },
            "name": "disconnect_from_rosbridge",
            "location": {
              "start": 58,
              "insert": 59,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 58,
                "end": 61
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "86fead26-dd99-cc8b-344b-421bed9d6856",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Cancels two timers, __start_timer and __stop_timer, likely used to manage simulation timing requirements.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(10, 5)\n# Perform actions that trigger the simulation and its timers\n# ...\nmanager.stop_timers()\n",
              "description": "\nIn this example, manager is an instance of the class `SimulationRequirementsManager`, which has two timer instances (`__start_timer` and `__stop_timer`) set to trigger after 5 seconds and 10 seconds respectively. After performing some actions that trigger the simulation and its timers, it cancels both timers using the stop_timers method."
            },
            "name": "stop_timers",
            "location": {
              "start": 65,
              "insert": 66,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "a3d04cea-aeaa-c5b4-a74c-72e12c13142c",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Disconnects from ROSBridge and sets the `finished` flag to True, indicating the simulation has been stopped.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "sim_manager = SimulationRequirementsManager(max_timeout=10, min_timeout=5)\nsim_manager.connect_to_rosbridge(rosbridge_client)\n# Do some simulation-related tasks...\nsim_manager.stop_simulation()",
              "description": ""
            },
            "name": "stop_simulation",
            "location": {
              "start": 69,
              "insert": 70,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 69,
                "end": 72
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "5ef1e5eb-492e-6da6-014f-99129697bd98",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Triggers a command to start the simulation, sets an introspection flag to True, and then handles changes in child status when the simulation starts or times out.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(max_timeout=10, min_timeout=0)\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nmanager.add_child(child1)\nmanager.add_child(child2)\n\nmanager.connect_to_rosbridge(rosbridge_client)",
              "description": ""
            },
            "name": "handle_start_timeout",
            "location": {
              "start": 76,
              "insert": 77,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 76,
                "end": 79
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 3
          },
          {
            "id": "9c1f4e4c-19e3-a2b8-5e4f-f01bee27814e",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Checks if all child nodes (CommandHandler instances) have been satisfied, returning True only if all are satisfied; otherwise, it returns False. The satisfaction state is determined by the `satisfied` attribute of each child node.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "True if all children nodes are satisfied, i.e., their `satisfied` property is True; otherwise, it returns False."
            },
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(1.0, 2.0)\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nmanager.add_child(child1)\nmanager.add_child(child2)\n\nchild1.satisfied = False\nchild2.satisfied = True\n\nprint(manager.assess_children_nodes())",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 91,
              "insert": 92,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 91,
                "end": 97
              }
            },
            "item_type": "method",
            "length": 15,
            "docLength": 6
          },
          {
            "id": "c9ddccde-6ef1-e7aa-124c-2eea0f8a820c",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Updates its internal state (`satisfied`) based on changes in child nodes' statuses and performs corresponding actions: stopping timers if satisfied, and simulation if previously unsatisfied.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "simulation_requirements_manager = SimulationRequirementsManager(max_timeout=60, min_timeout=30)\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nsimulation_requirements_manager.add_child(child1)\nsimulation_requirements_manager.add_child(child2)\n\nsimulation_requirements_manager.connect_to_rosbridge(rosbridge_client)\n\n# At some point in the simulation\nchild1.set_satisfied(True)\nchild2.set_satisfied(False)\n\nsimulation_requirements_manager.handle_children_status_change()",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 116,
              "insert": 117,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 116,
                "end": 120
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 4
          },
          {
            "id": "4d8a5fa1-64bc-95a8-cb47-49ad614fc93b",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Stops all timers and simulation processes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(10, 5)\nmanager.connect_to_rosbridge(rosbridge_client)\n\n# assume simulation runs for a while...\n\nmanager.handle_stop_simulation()\n",
              "description": ""
            },
            "name": "handle_stop_simulation",
            "location": {
              "start": 129,
              "insert": 130,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 129,
                "end": 133
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "7a554e2b-6084-adab-a444-ad9a44e07d21",
            "ancestors": [
              "5b5b5a50-98d2-3cba-ba4d-0687d1c29f86"
            ],
            "description": "Handles incoming commands from an upstream source, executing specific actions based on the command type: either updating children's statuses if the command is a STATUS_CHANGE or stopping the simulation if it's a STOP_SIMULATION.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an instance of the `Command` class, representing an upstream command that has been received by the system or application."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "manager = SimulationRequirementsManager(10, 5) \ncommand = Command(CommandType.STOP_SIMULATION)\nmanager.handle_upstream_command(command)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 137,
              "insert": 138,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 137,
                "end": 144
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "node.py",
    "path": "rigel/plugins/core/test/introspection/requirements/node.py",
    "content": {
      "structured": {
        "description": "A class SimulationRequirementNode that inherits from CommandHandler and serves as a base class for nodes in a simulation requirements tree. The class declares an interface that must be complied with by its subclasses. It also initializes a boolean flag satisfied indicating whether each requirement was met or not, using the bool type and defaulting to False.",
        "items": [
          {
            "id": "a64781d1-cfcb-e7a5-c146-7f248f16732d",
            "ancestors": [],
            "description": "Handles commands related to simulation requirements and keeps track of the satisfaction status of each requirement, represented by a boolean flag `satisfied`.",
            "attributes": [
              {
                "name": "satisfied",
                "type_name": "bool",
                "description": "Initialized to False by default. It indicates whether or not a specific requirement within a simulation has been fulfilled."
              }
            ],
            "name": "SimulationRequirementNode",
            "location": {
              "start": 4,
              "insert": 5,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 4,
                "end": 9
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 5
          }
        ]
      }
    }
  },
  {
    "name": "prevention.py",
    "path": "rigel/plugins/core/test/introspection/requirements/prevention.py",
    "content": {
      "structured": {
        "description": "A PreventionSimulationRequirementNode class that implements a simulation requirement node in ROS (Robot Operating System) using the Rigel framework. It ensures that if a ROS message is received that satisfies anterior requirements, then no other message is received that satisfies posterior requirements within a specified timeout period. The node handles commands of various types, such as TRIGGER, ROSBRIDGE_CONNECT, and ROSBRIDGE_DISCONNECT, to manage the simulation and assess the satisfaction of its requirements.",
        "items": [
          {
            "id": "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac",
            "ancestors": [],
            "description": "Represents a node in a simulation requirement tree, which assesses child nodes' satisfaction and sends commands based on their status to upstream or downstream nodes. It also handles timeout events and ROS bridge connection/disconnection commands.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Initialized in the constructor to be an empty list. It stores child nodes of the node."
              },
              {
                "name": "father",
                "type_name": "SimulationRequirementNode|None",
                "description": "Set to None by default. It seems that this attribute represents a reference to the parent node in the simulation requirement tree structure."
              },
              {
                "name": "timeout",
                "type_name": "float|inf",
                "description": "0 by default, representing a timer that starts when a ROS bridge connection command is received and stops after the specified timeout has expired."
              },
              {
                "name": "__timer",
                "type_name": "threadingTimer",
                "description": "Initialized with a timeout value in its constructor. It starts when ROSbridge connection commands are received if a time limit was specified. The timer triggers the `handle_timeout` method after the timeout period."
              },
              {
                "name": "handle_timeout",
                "type_name": "None",
                "description": "Invoked by the timer when a timeout occurs. It assesses the status of child nodes, updates its own satisfied state based on their status, and sends relevant commands upstream or downstream accordingly."
              }
            ],
            "name": "PreventionSimulationRequirementNode",
            "location": {
              "start": 13,
              "insert": 14,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 13,
                "end": 18
              }
            },
            "item_type": "class",
            "length": 81,
            "docLength": 5
          },
          {
            "id": "575da3b7-52aa-a398-b44c-caba0b64bc54",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Initializes an object with its attributes, including children, father node, and timeout value. It also sets up a timer to handle timeouts using a separate thread. The timer is scheduled to trigger the `handle_timeout` method after the specified timeout period.",
            "params": [
              {
                "name": "timeout",
                "type_name": "float",
                "description": "0 by default, which indicates that no timeout should occur. The timer is set with this value, which means when the time exceeds this duration, the method `handle_timeout` will be called."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "prn = PreventionSimulationRequirementNode(timeout=5)\n",
              "description": "\nThis creates an instance of the class PreventionSimulationRequirementNode with a timeout set to 5 seconds."
            },
            "name": "__init__",
            "location": {
              "start": 20,
              "insert": 21,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 5,
            "docLength": null
          },
          {
            "id": "d579550b-b263-079a-b844-b9931199f67b",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Converts its children into strings and concatenates them, returning the resulting string representation. This allows for easy debugging or logging of the node's structure by converting it to a human-readable format.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A string representation of the object, constructed by concatenating the string representations of all its children objects."
            },
            "usage": {
              "language": "python",
              "code": "node1 = PreventionSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\nnode1.children.append(child1)\nnode1.children.append(child2)\nprint(str(node1))\n",
              "description": "\nThis code creates a new instance of `PreventionSimulationRequirementNode`, two instances of `SimulationRequirementNode`, and adds these nodes as children to the parent node. The output would be: `<__main__.SimulationRequirementNode object at 0x7f9a5f4e6d90> <__main__.SimulationRequirementNode object at 0x7f9a5f4e6da0>`"
            },
            "name": "__str__",
            "location": {
              "start": 26,
              "insert": 27,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "f82298fb-fbab-63bd-164f-9dd61705558a",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Evaluates the satisfaction state of two child nodes, anterior and posterior, both being instances of SimulationRequirementNode. It returns True if the anterior node is satisfied and the posterior node is not, indicating a specific condition.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "Determined by the satisfaction status of two children nodes (`anterior` and `posterior`) of a parent node. The return value is `True` if `anterior` is satisfied and `posterior` is not, otherwise it's `False`."
            },
            "usage": {
              "language": "python",
              "code": "prn = PreventionSimulationRequirementNode()\nprn.children.append(SimulationRequirementNode())\nprn.children.append(SimulationRequirementNode())\n\nresult = prn.assess_children_nodes()",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 32,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 32,
                "end": 39
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 7
          },
          {
            "id": "97a72d4f-a85d-a8bd-c441-b5d18909d4b9",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Assesses satisfaction status by evaluating children nodes, and then sends appropriate commands to upstream and downstream based on this status, either for a normal simulation stop or for a simulation restart.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = PreventionSimulationRequirementNode()\nnode.children.append(SimulationRequirementNode())\nnode.children.append(SimulationRequirementNode())\n\n# Set a time limit for the simulation\nnode.timeout = 10.0\n\n# Start the timer and initiate the simulation\nif node.timeout != inf: \n    node.__timer.start()",
              "description": ""
            },
            "name": "handle_timeout",
            "location": {
              "start": 53,
              "insert": 54,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 53,
                "end": 57
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 4
          },
          {
            "id": "9f67b46e-692d-76ba-d44c-ea817608e4cd",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Handles status changes in its child nodes, specifically DisjointSimulationRequirementNodes or SimpleSimulationRequirementNodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "prevention_simulation = PreventionSimulationRequirementNode(timeout=5)\nprevention_simulation.children.append(SimpleSimulationRequirementNode())\nprevention_simulation.children.append(DisjointSimulationRequirementNode())\n\n# Perform some action to trigger the change in status\nprevention_simulation.handle_children_status_change()\n",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 65,
              "insert": 66,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 65,
                "end": 69
              }
            },
            "item_type": "method",
            "length": 13,
            "docLength": 4
          },
          {
            "id": "328433a3-f92f-c285-9548-b5256ed6de41",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Notifies the first child node (`anterior`) of a command and sends it downstream, ensuring that only this node is triggered while posterior nodes start listening for ROS messages after their satisfaction requirements are met.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an instance of the Command class or its subclass. It represents a command that triggers a process, and it's used to notify and interact with the anterior requirement node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = PreventionSimulationRequirementNode()\ncommand = Command()  # Assuming Command is already defined and instantiated properly.\nnode.handle_trigger(command)",
              "description": ""
            },
            "name": "handle_trigger",
            "location": {
              "start": 88,
              "insert": 89,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 88,
                "end": 95
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 7
          },
          {
            "id": "f799a534-67fc-43b4-7746-5bc3c6af8232",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Sends a downstream command and starts a timer if a time limit has been specified, ensuring that subsequent code execution is conditional on ROS message handlers being registered.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an object representing a ROS (Robot Operating System) message command."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "prn = PreventionSimulationRequirementNode(timeout=10)\ncommand = Command('rosbridge_connect')\nprn.handle_rosbridge_connection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_connection_commands",
            "location": {
              "start": 101,
              "insert": 102,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 101,
                "end": 108
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 7
          },
          {
            "id": "59c56fad-c2aa-9988-0449-7258bd58f62c",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Cancels a timer, assesses the satisfaction status of child nodes, sends a command to update upstream simulation, and sends the received command downstream after ROS bridge disconnection commands are handled.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Required for execution of this method. It is used as an argument to send_downstream_cmd method at the end of the function body."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "pr_node = PreventionSimulationRequirementNode()\ncommand = Command(\"disconnect_command\")\npr_node.handle_rosbridge_disconnection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_disconnection_commands",
            "location": {
              "start": 115,
              "insert": 116,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 115,
                "end": 122
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 7
          },
          {
            "id": "f10fdd2e-52ae-41b7-204a-43a1974fc1aa",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Processes incoming commands from an upstream component, specifically handling status change commands by invoking the `handle_children_status_change` method to handle changes in the children's statuses.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to hold an instance that represents an upstream command. The type of this command is specified by its attribute `type`."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "prevention_simulation_requirement_node = PreventionSimulationRequirementNode()\ncommand = Command(type=CommandType.STATUS_CHANGE)\nprevention_simulation_requirement_node.handle_upstream_command(command)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 131,
              "insert": 132,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 131,
                "end": 138
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "0abdb6f7-c855-4e8c-3144-2d61a51d7c05",
            "ancestors": [
              "f1a398f0-49f3-63a8-d84c-0cd0351ea7ac"
            ],
            "description": "Handles downstream commands by routing them to respective methods based on their command types: ROSBRIDGE connection, disconnection, and trigger actions.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an instance of a class that represents a command sent downstream. Its value determines which type of command handling logic should be executed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = PreventionSimulationRequirementNode()\ncmd1 = Command(type=CommandType.ROSBRIDGE_CONNECT)\ncmd2 = Command(type=CommandType.TRIGGER)\n\nnode.handle_downstream_command(cmd1)  # Handles ROS bridge connection command\nnode.handle_downstream_command(cmd2)  # Handles trigger command",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 142,
              "insert": 143,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 142,
                "end": 149
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "requirement.py",
    "path": "rigel/plugins/core/test/introspection/requirements/requirement.py",
    "content": {
      "structured": {
        "description": "A class RequirementSimulationRequirementNode which ensures that if a ROS message is received that satisfies anterior requirements then all posterior requirements were already previously satisfied. It uses threading for timeout handling and ROS bridge connection/disconnection commands. The class can handle various types of commands including STATUS_CHANGE, ROSBRIDGE_CONNECT, ROSBRIDGE_DISCONNECT and TRIGGER.",
        "items": [
          {
            "id": "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b",
            "ancestors": [],
            "description": "Simulates a requirement node that monitors and responds to ROS bridge connection/disconnection, status changes, and timeouts. It assesses its children nodes' statuses, sends commands upstream and downstream accordingly, and handles timer events.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]|List[CommandHandler]",
                "description": "Initialized to an empty list during object creation."
              },
              {
                "name": "father",
                "type_name": "SimulationRequirementNode|None",
                "description": "Set to None by default. It represents a reference to the parent node in the simulation requirement tree structure."
              },
              {
                "name": "timeout",
                "type_name": "float|inf",
                "description": "Set by default to infinity (inf). It represents the maximum time allowed for a simulation requirement node to remain unsatisfied."
              },
              {
                "name": "__timer",
                "type_name": "threadingTimer|None",
                "description": "Initialized with a timeout value specified during initialization. It starts when a ROSBRIDGE connection command is received, canceling itself when a disconnection or status change occurs."
              },
              {
                "name": "handle_timeout",
                "type_name": "None",
                "description": "A method that cancels any ongoing simulation if a timeout has occurred but the requirement has not been satisfied. It sends an upstream command to stop the simulation."
              }
            ],
            "name": "RequirementSimulationRequirementNode",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 11,
                "end": 16
              }
            },
            "item_type": "class",
            "length": 62,
            "docLength": 5
          },
          {
            "id": "28b5b7b9-4c54-7dbc-1c40-3093bf20910d",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Initializes an instance with a list to store children, a reference to its father node, a timeout value, and starts a timer that calls the handle_timeout method when the specified timeout is reached.",
            "params": [
              {
                "name": "timeout",
                "type_name": "float",
                "description": "0 by default. It represents the time in seconds after which the handle_timeout method will be executed if no other operation has been performed on the object during this period."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = RequirementSimulationRequirementNode(timeout=10)\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 18,
              "insert": 19,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 5,
            "docLength": null
          },
          {
            "id": "8a0cce0b-cadf-a69e-6e48-8c7d6ce41f6a",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Recursively concatenates the string representations of its child nodes into a single string, providing a human-readable representation of the node's subtree.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A string representation of the object, constructed by concatenating the string representations of its child objects."
            },
            "usage": {
              "language": "python",
              "code": "root = RequirementSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\n\nroot.children.append(child1)\nroot.children.append(child2)\n\nrepr_value = str(root)",
              "description": ""
            },
            "name": "__str__",
            "location": {
              "start": 24,
              "insert": 25,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "87d56d6a-e1f0-0fb1-4042-66386becfba0",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Checks the satisfaction status of two child nodes, anterior and posterior, and sends an upstream command to stop simulation if only one is satisfied. It returns a boolean indicating whether both children are satisfied or not.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "True if both `anterior` and `posterior` nodes are satisfied, False otherwise. The satisfaction status determines whether to send a stop simulation command upstream or not."
            },
            "usage": {
              "language": "python",
              "code": "sim_node = RequirementSimulationRequirementNode()\nsim_node.children.append(SimulationRequirementNode())\nsim_node.children.append(SimulationRequirementNode())\n\nif sim_node.assess_children_nodes():\n    # do something",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 30,
              "insert": 31,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 30,
                "end": 35
              }
            },
            "item_type": "method",
            "length": 13,
            "docLength": 5
          },
          {
            "id": "a31571d5-39e3-c68c-9440-51e7a86964ee",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Updates its own state and sends commands to other nodes when there are changes in the status of its child nodes. It cancels a timer, disconnects from a Rosbridge server, and sends commands to upstream and downstream nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = RequirementSimulationRequirementNode()\nnode.children.append(SimulationRequirementNode())\nnode.children.append(SimulationRequirementNode())\n\n# Assuming children status change here...\n\nnode.handle_children_status_change()",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 51,
                "end": 55
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 4
          },
          {
            "id": "9665f3d0-1281-1cbd-9c46-18bdaeb9beeb",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Sends a stop simulation command to an upstream component if the requirement has not been satisfied. This action is triggered when a timeout occurs.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "requirement_node = RequirementSimulationRequirementNode(timeout=10)\nrequirement_node.satisfied = False  # set the requirement node as unsatisfied\n# after a certain time, the handle_timeout method will send stop_simulation_cmd.",
              "description": ""
            },
            "name": "handle_timeout",
            "location": {
              "start": 63,
              "insert": 64,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 63,
                "end": 67
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "2d0df6c1-2a2f-a6a3-b74c-5a9e4142a52a",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Processes ROS bridge connection commands and sends downstream commands to unknown destinations. If a timeout is set, it starts a timer. This method executes after all ROS message handlers are registered.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an instance of a class that represents a command. The exact nature of this command is not specified."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = RequirementSimulationRequirementNode(timeout=10)  # Create a node with a timeout of 10 seconds\ncommand = Command(type=CommandType.ROSBRIDGE_CONNECT, data=\"example\")  # Define a command to connect to ROS bridge\nnode.handle_rosbridge_connection_commands(command)  # Send the command to handle rosbridge connection commands",
              "description": ""
            },
            "name": "handle_rosbridge_connection_commands",
            "location": {
              "start": 71,
              "insert": 72,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 71,
                "end": 78
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 7
          },
          {
            "id": "a2e8abc7-556e-59b7-c842-968c14c78dba",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Cancels an ongoing timer and sends a downstream command when ROSBridge disconnection commands are received.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Passed as an argument. Its exact definition or implementation is not provided, but it appears to represent some kind of command or instruction being handled by this method."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = RequirementSimulationRequirementNode(timeout=5)\ncommand = CommandBuilder.build_rosbridge_disconnect_cmd()\nnode.handle_rosbridge_disconnection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_disconnection_commands",
            "location": {
              "start": 85,
              "insert": 86,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 85,
                "end": 92
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 7
          },
          {
            "id": "e538cc1c-ef2a-6691-074c-d7f23ebcaa77",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Processes an upstream command, specifically handling commands of type STATUS_CHANGE by calling the `handle_children_status_change` method.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an object that represents a command of some kind, specifically one with a type attribute."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "command_node = RequirementSimulationRequirementNode()\ncommand = Command(CommandType.STATUS_CHANGE)\ncommand_node.handle_upstream_command(command)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 97,
              "insert": 98,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 97,
                "end": 104
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "cbcf088f-726f-59ad-264c-77845b1d094c",
            "ancestors": [
              "5921f939-d7a2-fb8b-7a4c-cf684b2d1d8b"
            ],
            "description": "Handles incoming downstream commands by delegating processing to specific methods based on the command type, which can be ROSBRIDGE_CONNECT, ROSBRIDGE_DISCONNECT, or TRIGGER.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to contain information about an incoming command from downstream, such as its type and possibly additional data specific to that type of command."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "simulation_node = RequirementSimulationRequirementNode()\ncommand1 = Command(CommandType.ROSBRIDGE_CONNECT)\ncommand2 = Command(CommandType.TRIGGER)\nsimulation_node.handle_downstream_command(command1)\nsimulation_node.handle_downstream_command(command2)",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 108,
              "insert": 109,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 108,
                "end": 115
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "response.py",
    "path": "rigel/plugins/core/test/introspection/requirements/response.py",
    "content": {
      "structured": {
        "description": "A ResponseSimulationRequirementNode class that ensures no ROS (Robot Operating System) message is received that satisfies posterior requirements before anterior requirements were previously satisfied. It utilizes threading and math libraries along with rigel plugins core test introspection command classes. The node assesses its children nodes for satisfaction and handles timeout events, status changes, triggers, rosbridge connections and disconnections accordingly.",
        "items": [
          {
            "id": "e5716392-c521-9ab7-7b41-3ac4f83c838d",
            "ancestors": [],
            "description": "Simulates a node in a simulation requirement tree, handling commands and timeouts to assess satisfaction of its children nodes and send appropriate upstream or downstream commands.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[SimulationRequirementNode]",
                "description": "Initialized to an empty list during object creation. It holds references to child nodes that are managed by this node."
              },
              {
                "name": "father",
                "type_name": "SimulationRequirementNode|None",
                "description": "Used to represent the parent node in a hierarchical structure of requirement nodes."
              },
              {
                "name": "timeout",
                "type_name": "float|int",
                "description": "0 by default. It represents the time limit for which the node should wait before sending a specific command when a child node becomes satisfied."
              },
              {
                "name": "__timer",
                "type_name": "threadingTimer",
                "description": "Initialized in the `__init__` method with a timeout period specified by the `timeout` parameter. It is responsible for triggering the `handle_timeout` method when the timer expires."
              },
              {
                "name": "handle_timeout",
                "type_name": "None",
                "description": "Defined as a method. It cancels the timer, assesses the satisfaction of child nodes based on their status, and sends appropriate commands to upstream or downstream nodes if necessary."
              }
            ],
            "name": "ResponseSimulationRequirementNode",
            "location": {
              "start": 13,
              "insert": 14,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 13,
                "end": 18
              }
            },
            "item_type": "class",
            "length": 85,
            "docLength": 5
          },
          {
            "id": "d875cc9d-7bd7-ff94-544a-6e97271e9d6c",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Initializes an object with an empty list of children, no father node by default, a specified timeout period, and sets up a timer to trigger the handle_timeout method when the timeout expires.",
            "params": [
              {
                "name": "timeout",
                "type_name": "float",
                "description": "Infinity (`inf`) by default. It represents the timeout value in seconds for which the timer will wait before calling the `handle_timeout` method if no event occurs."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ResponseSimulationRequirementNode(timeout=10)\n",
              "description": "\nThis code creates a new instance of the class, setting its timeout value to 10."
            },
            "name": "__init__",
            "location": {
              "start": 20,
              "insert": 21,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 5,
            "docLength": null
          },
          {
            "id": "c437c977-5ba9-2d8e-5441-16392d410274",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Converts its children nodes into strings and concatenates them into a single string representation, allowing for easy stringification of the node's contents.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A string representation of the object, constructed by concatenating the string representations of all child objects in the list `self.children`."
            },
            "usage": {
              "language": "python",
              "code": "root = ResponseSimulationRequirementNode()\nchild1 = SimulationRequirementNode()\nchild2 = SimulationRequirementNode()\nroot.children.append(child1)\nroot.children.append(child2)\n\nprint(root)",
              "description": ""
            },
            "name": "__str__",
            "location": {
              "start": 26,
              "insert": 27,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "2617cb97-402e-1ca2-2d4a-69ff902de2f1",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Checks if both child nodes, anterior and posterior, are satisfied, returning True only if they are both satisfied.",
            "params": [],
            "returns": {
              "type_name": "bool",
              "description": "True if both child nodes (`anterior` and `posterio`) satisfy their conditions, otherwise it returns False."
            },
            "usage": {
              "language": "python",
              "code": "simulation_requirement_node = ResponseSimulationRequirementNode()\nsimulation_requirement_node.children.append(SimulationRequirementNode())\nsimulation_requirement_node.children.append(SimulationRequirementNode())\n\nif simulation_requirement_node.assess_children_nodes():\n    # Perform action when children are satisfied.\nelse:\n    # Perform alternative action when children are not satisfied.",
              "description": ""
            },
            "name": "assess_children_nodes",
            "location": {
              "start": 32,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 32,
                "end": 39
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 7
          },
          {
            "id": "39dffc44-75dc-189f-0547-e92f8dd4f9c7",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Assesses the satisfaction of its children nodes, then sends either status change, disconnect, or stop simulation commands upstream and downstream depending on whether the requirement is satisfied or not.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ResponseSimulationRequirementNode()\nnode.children = [SimpleSimulationRequirementNode(), SimpleSimulationRequirementNode()]\nnode.handle_timeout()",
              "description": ""
            },
            "name": "handle_timeout",
            "location": {
              "start": 53,
              "insert": 54,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 53,
                "end": 57
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 4
          },
          {
            "id": "29343e2a-c466-3f87-154e-fdc755c14415",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Monitors the status changes of its two child nodes, anterior and posterior, and updates the node's own status accordingly. It cancels a timer, sends disconnect and status change commands to downstream and upstream nodes respectively if the children are satisfied.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ResponseSimulationRequirementNode()\nnode.children.append(DisjointSimulationRequirementNode())\nnode.children.append(SimpleSimulationRequirementNode())\n\n# Some code that triggers a status change...\n\nnode.handle_children_status_change()",
              "description": ""
            },
            "name": "handle_children_status_change",
            "location": {
              "start": 67,
              "insert": 68,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 67,
                "end": 71
              }
            },
            "item_type": "method",
            "length": 17,
            "docLength": 4
          },
          {
            "id": "bd74e295-442b-9a92-3d4e-de349fc15f0a",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Notifies the anterior requirement node of an incoming command, ensuring that only the anterior node is notified initially, while posterior nodes start listening for ROS messages after satisfying their requirements.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be passed from outside the function. It represents some kind of instruction or request that needs to be handled by this function."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "requirement_node = ResponseSimulationRequirementNode()\nanterior = DisjointSimulationRequirementNode()\nposterior = SimpleSimulationRequirementNode()\n\nrequirement_node.children.extend([anterior, posterior])\nrequirement_node.father = None\n\nrequirement_node.handle_trigger(CommandBuilder.build_trigger_cmd(anterior.last_message))\n",
              "description": ""
            },
            "name": "handle_trigger",
            "location": {
              "start": 92,
              "insert": 93,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 92,
                "end": 99
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 7
          },
          {
            "id": "8dc15e89-c3fd-5286-0d48-f3570a099f74",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Sends downstream commands and starts a timer if a timeout was specified. The timer will only be started after all ROS message handlers are registered.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an instance of a class representing ROS (Robot Operating System) commands, which are used for communication between ROS nodes."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ResponseSimulationRequirementNode(timeout=30)  # specify a time limit of 30 seconds\ncmd = Command('some_command')\nnode.handle_rosbridge_connection_commands(cmd)",
              "description": ""
            },
            "name": "handle_rosbridge_connection_commands",
            "location": {
              "start": 105,
              "insert": 106,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 105,
                "end": 112
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 7
          },
          {
            "id": "73f3f364-42e4-c584-fe46-0517c6003205",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Handles ROSBridge disconnection commands, cancels a timer if it's running, assesses the satisfaction of its children nodes, and sends upstream and downstream commands accordingly.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Passed to the method during its invocation. It represents a command that is being handled or processed by the method."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ResponseSimulationRequirementNode()\ncommand = CommandBuilder.build_status_change_cmd()\nnode.handle_rosbridge_disconnection_commands(command)",
              "description": ""
            },
            "name": "handle_rosbridge_disconnection_commands",
            "location": {
              "start": 119,
              "insert": 120,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 119,
                "end": 126
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 7
          },
          {
            "id": "1b25f074-9df0-8e8d-ee4d-9cb297fc6491",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Handles incoming commands and executes specific actions based on the command type. If the received command is of type STATUS_CHANGE, it invokes the `handle_children_status_change` method to perform subsequent operations.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "An instance that represents a specific upstream command sent to this process or thread. Its type, CommandType, determines the action it needs to perform."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = ResponseSimulationRequirementNode()\nstatus_change_cmd = Command(type=CommandType.STATUS_CHANGE)\nnode.handle_upstream_command(status_change_cmd)",
              "description": ""
            },
            "name": "handle_upstream_command",
            "location": {
              "start": 135,
              "insert": 136,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 135,
                "end": 142
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "c8e0acd7-3139-54ad-4041-48296a7b74cd",
            "ancestors": [
              "e5716392-c521-9ab7-7b41-3ac4f83c838d"
            ],
            "description": "Processes downstream commands, specifically ROSBRIDGE connection and disconnection requests, as well as trigger events. It dispatches these commands to respective handling methods based on their types.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to hold data that can be processed by the method. The specific details and properties of this command depend on its type."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "response_simulation_requirement_node = ResponseSimulationRequirementNode()\ncommand = Command(CommandType.ROSBRIDGE_CONNECT)\nresponse_simulation_requirement_node.handle_downstream_command(command)",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 146,
              "insert": 147,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 146,
                "end": 153
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "simple.py",
    "path": "rigel/plugins/core/test/introspection/requirements/simple.py",
    "content": {
      "structured": {
        "description": "A class `SimpleSimulationRequirementNode` that simulates requirements for a simulation assessment strategy using ROS (Robot Operating System) messages. It subscribes to specific ROS topics and handles incoming messages by applying a predicate condition to assess the requirement satisfaction. The node can also trigger events based on timestamps and send commands upstream or downstream as necessary.",
        "items": [
          {
            "id": "8f6f514e-0674-0598-2b43-77664c6c960e",
            "ancestors": [],
            "description": "Represents a node in a simulation requirement graph, managing connections to ROSBridge, handling messages from a specific topic, and triggering events based on message reception and predicates. It also handles upstream and downstream commands for connection/disconnection and status changes.",
            "attributes": [
              {
                "name": "children",
                "type_name": "List[object]",
                "description": "Initialized as an empty list in its constructor. It does not have any specific functionality mentioned in this code snippet."
              },
              {
                "name": "father",
                "type_name": "SimpleSimulationRequirementNode|None",
                "description": "Used to store the parent node for this requirement, allowing it to track its hierarchical relationship with other nodes."
              },
              {
                "name": "ros_topic",
                "type_name": "str",
                "description": "Used to represent a topic name from the Robot Operating System (ROS). It stores the name of the ROS topic that this node is subscribed to."
              },
              {
                "name": "ros_message_type",
                "type_name": "str",
                "description": "Used to specify the type of ROS message being handled. It corresponds to a string representing the fully qualified name of the ROS message type, such as 'std_msgs/msg/String'."
              },
              {
                "name": "ros_message_callback",
                "type_name": "Callable",
                "description": "Expected to be a callback function that will be invoked whenever a ROS message matching the specified topic and message type is received by the node's associated ROS bridge client."
              },
              {
                "name": "predicate",
                "type_name": "str",
                "description": "Not clearly described as what it does. However, based on its use in the `__str__` method, it seems to be a string describing a condition or requirement that needs to be satisfied by the node."
              },
              {
                "name": "last_message",
                "type_name": "float|int",
                "description": "0 by default. It represents the timestamp of the last received ROS message for this node, updated upon successful processing of a message by the associated callback function."
              },
              {
                "name": "trigger",
                "type_name": "bool",
                "description": "Initially set to False. It is used to track whether a trigger event has occurred, and it is updated by the `handle_trigger` method when a trigger event is detected."
              }
            ],
            "name": "SimpleSimulationRequirementNode",
            "location": {
              "start": 17,
              "insert": 18,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 17,
                "end": 21
              }
            },
            "item_type": "class",
            "length": 75,
            "docLength": 4
          },
          {
            "id": "5471e4ac-d8c2-289a-ec41-d4a8b5b3c427",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Initializes an object with parameters for ROS topic, message type, callback function, and predicate. It also sets up attributes for children nodes, parent node, last received message timestamp, trigger status, and stores these values internally.",
            "params": [
              {
                "name": "ros_topic",
                "type_name": "str",
                "description": "Used to initialize the ros topic attribute of the class instance. This string represents the name of the ROS topic that this instance is subscribed to."
              },
              {
                "name": "ros_message_type",
                "type_name": "str",
                "description": "Used to specify the message type for a ROS (Robot Operating System) topic."
              },
              {
                "name": "ros_message_callback",
                "type_name": "Callable",
                "description": "Expected to be a callback function that handles ROS messages."
              },
              {
                "name": "predicate",
                "type_name": "str",
                "description": "Used to specify a condition that determines when the callback function should be triggered."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = SimpleSimulationRequirementNode(\n    \"chatter\",\n    \"std_msgs/String\",\n    lambda message: message.data == \"Hello, ROS!\",\n    \"Predicate for a specific message\"\n)\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 23,
              "insert": 30,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 29,
                "end": 38
              }
            },
            "item_type": "constructor",
            "length": 18,
            "docLength": 9
          },
          {
            "id": "a8e0ca8d-4d75-3782-3843-91a1baac68fc",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Generates a string representation of an object, describing its ROS topic, satisfaction status, and predicate. It uses labels to indicate whether the node is satisfied or unsatisfied based on the presence of its father node.",
            "params": [],
            "returns": {
              "type_name": "str",
              "description": "A formatted string representing an instance of the class, describing its state and properties."
            },
            "usage": {
              "language": "python",
              "code": "node = SimpleSimulationRequirementNode(\n    \"chatter\",\n    \"std_msgs/String\",\n    lambda message: message.data == \"hello\",\n    \"Receive a 'hello' ROS message\"\n)\n\n",
              "description": "\nNote that this is just a simple example and it does not cover all possible cases."
            },
            "name": "__str__",
            "location": {
              "start": 53,
              "insert": 55,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "5a48ff74-edd6-18b9-8c47-a195d8ea343d",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Handles incoming downstream commands by dispatching them to respective handlers based on their types: ROSBRIDGE_CONNECT, ROSBRIDGE_DISCONNECT, and TRIGGER. Each handler processes the command's data accordingly, connecting/disconnecting to a rosbridge or triggering an event.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Passed as an argument to this function. It is expected to contain information about the command being handled, including its type and possibly additional data."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = SimpleSimulationRequirementNode(\n    ros_topic=\"chatter\",\n    ros_message_type=\"std_msgs/String\",\n    ros_message_callback=lambda message: len(message.data) > 0,\n    predicate=\"Predicate description\"\n)\n\ncommand = Command(CommandType.ROSBRIDGE_CONNECT, {'client': 'rosbridge_client'})\nnode.handle_downstream_command(command)\n",
              "description": ""
            },
            "name": "handle_downstream_command",
            "location": {
              "start": 67,
              "insert": 68,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 67,
                "end": 74
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          },
          {
            "id": "58161b97-12df-c692-2e48-a78367b7cb0f",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Registers a message handler with a ROSBridgeClient instance to receive messages from a specified topic and handle them using the provided message type and handler function.",
            "params": [
              {
                "name": "rosbridge_client",
                "type_name": "ROSBridgeClient",
                "description": "Expected to be an instance of a class representing a ROS (Robot Operating System) bridge client."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = SimpleSimulationRequirementNode('my_topic', 'my_message_type', lambda m: True, 'My Predicate')\nrosbridge_client = ROSBridgeClient()\nnode.connect_to_rosbridge(rosbridge_client)",
              "description": ""
            },
            "name": "connect_to_rosbridge",
            "location": {
              "start": 82,
              "insert": 83,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 82,
                "end": 88
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 6
          },
          {
            "id": "7c23dc7e-7506-2d9d-6942-a762349b5157",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Removes a message handler from a ROSBridge client, indicating that the node no longer wants to receive messages from a specific topic with a certain type of message.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = SimpleSimulationRequirementNode(\n    ros_topic=\"my_topic\",\n    ros_message_type=\"my_message_type\",\n    ros_message_callback=lambda message: True,\n    predicate=\"my_predicate\"\n)\ncommand = Command(type=CommandType.ROSBRIDGE_DISCONNECT, data={})\nnode.handle_downstream_command(command)",
              "description": ""
            },
            "name": "disconnect_from_rosbridge",
            "location": {
              "start": 97,
              "insert": 98,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 97,
                "end": 100
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 3
          },
          {
            "id": "06d721cb-0551-e989-8446-579cdb19d4be",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Sets a flag indicating a trigger event and, if a recent message was older than the current timestamp, disconnects from the ROS bridge and sends a command to upstream nodes.",
            "params": [
              {
                "name": "timestamp",
                "type_name": "float",
                "description": "Required for the function to run. Its purpose is to pass a timestamp value that triggers an action within the function."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "node = SimpleSimulationRequirementNode('topic_name', 'message_type', lambda message: True, 'predicate')\nnode.handle_downstream_command(Command(CommandType.TRIGGER, {'timestamp': 123.45}))",
              "description": ""
            },
            "name": "handle_trigger",
            "location": {
              "start": 108,
              "insert": 109,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 108,
                "end": 112
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 4
          },
          {
            "id": "d544eaad-2098-3ca2-4a47-ab0730bc6389",
            "ancestors": [
              "8f6f514e-0674-0598-2b43-77664c6c960e"
            ],
            "description": "Processes an incoming ROS message and triggers a series of actions: it sets flags indicating satisfaction of requirements, updates timestamps, disconnects from the ROS bridge, and sends an upstream command to change status.",
            "params": [
              {
                "name": "message",
                "type_name": "ROS_MESSAGE_TYPE",
                "description": "Passed to the function when it is called. It represents the ROS message that triggered this function call."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "simple_simulation_requirement_node = SimpleSimulationRequirementNode(\n    ros_topic='chatter',\n    ros_message_type='std_msgs/String',\n    ros_message_callback=lambda message: isinstance(message.data, str),\n    predicate=\"example predicate\"\n)\n",
              "description": "\nThis example initializes a `SimpleSimulationRequirementNode` object with specified parameters."
            },
            "name": "message_handler",
            "location": {
              "start": 118,
              "insert": 119,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 118,
                "end": 126
              }
            },
            "item_type": "method",
            "length": 13,
            "docLength": 8
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/test/introspection/__init__.py",
    "content": {
      "structured": {
        "description": "Various components for building a simulation framework. It includes command and parser classes from the command module, as well as strategy classes from the strategy module. The SimulationRequirementsParser parses requirements, while CommandBuilder builds commands. AssessmentStrategy and SingleMatchAssessmentStrategy assess matches accordingly.",
        "items": []
      }
    }
  },
  {
    "name": "callback.py",
    "path": "rigel/plugins/core/test/introspection/callback.py",
    "content": {
      "structured": {
        "description": "A `CallbackGenerator` class that generates callback functions for ROS (Robot Operating System) messages based on various conditions specified using HPL (Haskell Programming Language) operators and literals. The generated callbacks can be used to process incoming ROS messages and trigger specific actions or behaviors. The class provides methods for generating callback functions for equal, different, lesser, greater, and logical operations, as well as a method for processing vacuum truth.",
        "items": [
          {
            "id": "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a",
            "ancestors": [],
            "description": "Generates callback functions for ROS (Robot Operating System) messages based on a specified operator and operands. The generated callbacks check whether the message's field value satisfies the specified condition, returning `True` or `False`.",
            "attributes": [],
            "name": "CallbackGenerator",
            "location": {
              "start": 9,
              "insert": 11,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 115,
            "docLength": null
          },
          {
            "id": "e27896bb-24d7-e1a8-c747-5a31506c3717",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Recursively traverses a nested dictionary-like object based on a provided path and returns the value at the specified location. If the key is missing, it raises a KeyError.",
            "name": "__field_path",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 11,
                "end": 21
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 10
          },
          {
            "id": "fb48ec8a-3879-3085-4c40-21988b1986f7",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a callback function that checks if the value of a specified field in a ROS message equals to a given value. The callback returns True if the condition is met and False otherwise.",
            "params": [
              {
                "name": "field",
                "type_name": "List[str]",
                "description": "Expected to be a list containing one or more field names as strings, which are used to access a value from a ROS message."
              },
              {
                "name": "value",
                "type_name": "ROSMessageValue",
                "description": "Used to compare with the result of `__field_path(msg, field)` for equality within the callback function."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A reference to an anonymous inner function `callback`. This callback function checks if the value returned by calling `__field_path` on a message with the given field name matches the provided value."
            },
            "usage": {
              "language": "python",
              "code": "callback = CallbackGenerator().generate_callback_equal(['field1', 'field2'], 5)\n",
              "description": "\nThis will return a callback function that checks if the fields 'field1' and 'field2' in any message equal to 5."
            },
            "name": "generate_callback_equal",
            "location": {
              "start": 30,
              "insert": 31,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 30,
                "end": 42
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 12
          },
          {
            "id": "561aaf4f-5f55-b1b2-cc45-7e483aa9e942",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a callback function that compares the value of a specified field in a ROS message with a given value. The callback returns True if the values are different and False otherwise.",
            "params": [
              {
                "name": "field",
                "type_name": "List[str]",
                "description": "Expected to contain one or more strings representing the path to a field in a ROS message."
              },
              {
                "name": "value",
                "type_name": "ROSMessageValue",
                "description": "Expected to be used for comparison with the result of calling `self.__field_path(msg, field)` in the generated callback function."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callback function named `callback`. This callback function checks if the message passed to it satisfies the condition specified by the input field and value. It returns True if the condition is not met, otherwise False."
            },
            "usage": {
              "language": "python",
              "code": "generator = CallbackGenerator()\ncallback = generator.generate_callback_different(field=[\"a\", \"b\"], value=\"Hello\")\n",
              "description": "\nNote: The actual usage may vary based on the specific context and requirements."
            },
            "name": "generate_callback_different",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 47,
                "end": 59
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 12
          },
          {
            "id": "046cf809-16d1-9cb8-1840-30d1140f8a7c",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a callback function that checks if the value of a specified field in a ROS message is lesser than a given value, and returns True if this condition holds.",
            "params": [
              {
                "name": "field",
                "type_name": "List[str]",
                "description": "Expected to contain a list of strings representing the path of a field within a ROS message. The field is used by the callback function to retrieve its value from the incoming ROS message."
              },
              {
                "name": "value",
                "type_name": "ROSMessageValue",
                "description": "Used as a comparison value for the lesser operator in the callback function. It determines whether the message path in the input message is less than the provided value."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callback function that takes an argument of type ROSMessageType and returns a boolean value indicating whether the value of a specified field in a message is less than the given value."
            },
            "usage": {
              "language": "python",
              "code": "callback = CallbackGenerator().generate_callback_lesser(['a', 'b'], 10)\n",
              "description": "\nIn this example, the generate_callback_lesser method of the CallbackGenerator class creates a callback function that checks if the value at path ['a', 'b'] in a ROS message is less than 10."
            },
            "name": "generate_callback_lesser",
            "location": {
              "start": 64,
              "insert": 65,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 64,
                "end": 76
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 12
          },
          {
            "id": "9b44c613-e6ab-0885-cf41-5c94cdb48a08",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a callback function that checks if the value of a specified field in a ROS message is less than or equal to a given value, and returns True if this condition is met.",
            "params": [
              {
                "name": "field",
                "type_name": "List[str]",
                "description": "Expected to be a list of strings. The strings are likely names of fields or paths within ROS messages that will be accessed during the callback processing."
              },
              {
                "name": "value",
                "type_name": "ROSMessageValue",
                "description": "Expected to hold a value that will be used for comparison with the result of the `__field_path` method."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callable function that takes one argument of type ROSMessageType and returns a boolean value indicating whether the given message field's value is less than or equal to the specified value."
            },
            "usage": {
              "language": "python",
              "code": "generator = CallbackGenerator()\ncallback = generator.generate_callback_lesser_than(['field1', 'sub_field'], 10)\n",
              "description": "\nIn this example, `CallbackGenerator` is an instance of the class that has implemented various callback generation methods. The method `generate_callback_lesser_than` generates a callback function for the message subscriber, which will be triggered whenever the value in the specified field of the received ROS messages is lesser than 10."
            },
            "name": "generate_callback_lesser_than",
            "location": {
              "start": 81,
              "insert": 82,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 81,
                "end": 93
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 12
          },
          {
            "id": "be6cfd9b-3562-a199-b447-c04ec6fb7b7d",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a ROS callback function that checks if the value of a specified field in an incoming ROS message is greater than a provided value. The callback returns True if the condition is met, False otherwise.",
            "params": [
              {
                "name": "field",
                "type_name": "List[str]",
                "description": "Expected to be a list of strings representing the path to a field within ROS messages. The path is used to extract a value from the message for comparison."
              },
              {
                "name": "value",
                "type_name": "ROSMessageValue",
                "description": "Expected to hold a comparison value for comparing with the result of the `__field_path` method."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callable that takes an input message of type ROSMessageType and returns a boolean indicating whether the comparison between a field path in the message and a given value is greater than the value."
            },
            "usage": {
              "language": "python",
              "code": "callback = CallbackGenerator().generate_callback_greater(['my_field', 'sub_field'], 10)\n",
              "description": ""
            },
            "name": "generate_callback_greater",
            "location": {
              "start": 98,
              "insert": 99,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 98,
                "end": 110
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 12
          },
          {
            "id": "6a6b05ff-6be1-05b7-c441-57fb8497686c",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a callback function that checks if the value of a specified field (given as a list of strings) in a ROS message is greater than or equal to a given value, returning True if the condition is met and False otherwise.",
            "params": [
              {
                "name": "field",
                "type_name": "List[str]",
                "description": "Expected to be a list of strings."
              },
              {
                "name": "value",
                "type_name": "ROSMessageValue",
                "description": "Used to compare with the value obtained from the message using the provided field path."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callback function that takes a message of type ROSMessageType as input and returns a boolean indicating whether the specified field's value in the message is greater than or equal to a given value."
            },
            "usage": {
              "language": "python",
              "code": "callback = CallbackGenerator().generate_callback_greater_than(['field1', 'sub_field'], 10)\n",
              "description": ""
            },
            "name": "generate_callback_greater_than",
            "location": {
              "start": 115,
              "insert": 116,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 115,
                "end": 127
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 12
          },
          {
            "id": "dc0ce23b-0e87-8d93-f644-5862f4fac7d8",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates and returns a new callback function that applies two existing callback functions, anterior and posterior, with logical \"if-then\" semantics: if anterior is True for a message, then apply posterior to the same message; otherwise, return False.",
            "params": [
              {
                "name": "anterior",
                "type_name": "ROSCallbackType",
                "description": "Expected to be a callback function that takes one argument (a message of type ROSMessageType) and returns a boolean value indicating whether the message satisfies certain conditions."
              },
              {
                "name": "posterior",
                "type_name": "ROSCallbackType",
                "description": "Expected to be a callback function that takes a message of type ROSMessageType as an argument and returns a value indicating whether the message should be processed further."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callable object, specifically a function that takes an argument of type ROSMessageType and returns a boolean value. This returned function can be used as a callback."
            },
            "usage": {
              "language": "python",
              "code": "callback_generator = CallbackGenerator()\nanterior = callback_generator.generate_callback_greater([['field1', 'sub_field2']], 10)\nposterior = callback_generator.generate_callback_equal([['field1', 'sub_field2']], 20)\nresulting_callback = callback_generator.generate_callback_iff(anterior, posterior)\n\n# The resulting_callback would now be used for further processing\n",
              "description": ""
            },
            "name": "generate_callback_iff",
            "location": {
              "start": 132,
              "insert": 133,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 132,
                "end": 144
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 12
          },
          {
            "id": "2b0ebcde-84a8-9099-9040-c047a5f81998",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a",
              "dc0ce23b-0e87-8d93-f644-5862f4fac7d8"
            ],
            "description": "Evaluates whether a given message `msg` satisfies the condition specified by the `anterior` predicate. If true, it applies the `posterior` predicate to `msg`. If both conditions fail, the function returns `False`, indicating no match.",
            "params": [
              {
                "name": "msg",
                "type_name": "ROSMessageType",
                "description": "Expected to be an instance of a message type defined by ROS (Robot Operating System)."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "Either the result of calling `posterior` with `msg` as an argument or False, depending on whether the condition specified by `anterior` is met for `msg`."
            },
            "usage": {
              "language": "python",
              "code": "msg = ROSMessageType()\ncallback(msg)",
              "description": ""
            },
            "name": "callback",
            "location": {
              "start": 145,
              "insert": 146,
              "offset": " ",
              "indent": 12,
              "comment": null
            },
            "item_type": "function",
            "length": 4,
            "docLength": null
          },
          {
            "id": "655b0e01-ae35-d699-7d49-2fc9e04bbaa3",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a new callback function by combining two existing ROS callbacks (`anterior` and `posterior`) using the logical AND operator. The resulting callback returns True if both input callbacks return True for a given message.",
            "params": [
              {
                "name": "anterior",
                "type_name": "ROSCallbackType",
                "description": "Expected to be a callback function that takes one argument, namely a message of type ROSMessageType, and returns a boolean value."
              },
              {
                "name": "posterior",
                "type_name": "ROSCallbackType",
                "description": "Expected to be a function that takes a message of type ROSMessageType as input and returns a value of unknown type, which is then used in conjunction with the output of another callback function."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A higher-order function that takes messages of type ROSMessageType as input, applies two callbacks (anterior and posterior) to these messages, and returns the logical AND of their results."
            },
            "usage": {
              "language": "python",
              "code": "callback = CallbackGenerator().generate_callback_and(\n    CallbackGenerator().generate_callback_equal(['a', 'b'], 10),\n    CallbackGenerator().generate_callback_greater(['c'], 5)\n)\n",
              "description": ""
            },
            "name": "generate_callback_and",
            "location": {
              "start": 151,
              "insert": 152,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 151,
                "end": 163
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 12
          },
          {
            "id": "6ef6325c-dc17-3e9c-6844-aaf36304b148",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a",
              "655b0e01-ae35-d699-7d49-2fc9e04bbaa3"
            ],
            "description": "Takes a message of type `ROSMessageType`, applies functions `anterior` and `posterior` to it, and returns the logical AND (`and`) of the results, indicating whether both conditions are satisfied.",
            "params": [
              {
                "name": "msg",
                "type_name": "ROSMessageType",
                "description": "Expected to be an object or value that conforms to the ROS (Robot Operating System) message type, which represents a data structure for exchanging information between ROS nodes."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True if both `anterior_value` and `posterior_value` are true, otherwise it returns false."
            },
            "usage": {
              "language": "python",
              "code": "if __name__ == \"__main__\":\n    msg = ROSMessageType(\"Hello\")\n    callback(msg)",
              "description": ""
            },
            "name": "callback",
            "location": {
              "start": 164,
              "insert": 165,
              "offset": " ",
              "indent": 12,
              "comment": null
            },
            "item_type": "function",
            "length": 4,
            "docLength": null
          },
          {
            "id": "eb3bf84c-0c93-98a4-7c49-5049abdd5a06",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Generates a vacuous callback function. The returned function always returns True, regardless of its input. This means that it will not filter out any messages and will pass all incoming messages to the subscribed node without modification or filtering.",
            "params": [],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "A callable function named `callback`. This returned function, when invoked, takes a message of type ROSMessageType as input and always returns True."
            },
            "usage": {
              "language": "python",
              "code": "callback_generator = CallbackGenerator()\nvacuous_callback = callback_generator.generate_callback_vacuous()\n\n# Subscribe to a ROS topic and apply the generated callback\nros_node.subscribe('my_topic', vacuous_callback)\n",
              "description": "\nNote that this is just one possible way of using generate_callback_vacuous."
            },
            "name": "generate_callback_vacuous",
            "location": {
              "start": 171,
              "insert": 172,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 171,
                "end": 178
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 7
          },
          {
            "id": "bc2c2622-4e16-17ab-174a-80121fbb1728",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Processes binary operators and generates corresponding ROS callback functions based on the operator's type, taking into account two operands as arguments.",
            "params": [
              {
                "name": "operator",
                "type_name": "HplBinaryOperator",
                "description": "Expected to be an instance of a binary operator class, representing a comparison or logical operation between two operands."
              }
            ],
            "returns": {
              "type_name": "ROSCallbackType",
              "description": "Generated based on the operation defined by the binary operator `operator`. The returned value represents a callback that can be used to perform the specified operation."
            },
            "usage": {
              "language": "python",
              "code": "generator = CallbackGenerator()\noperator1 = HplBinaryOperator(op='=', operand1=['field1', 'subfield1'], operand2=10)\ncallback = generator.process_binary_operator(operator1)\n",
              "description": ""
            },
            "name": "process_binary_operator",
            "location": {
              "start": 193,
              "insert": 194,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 193,
                "end": 201
              }
            },
            "item_type": "method",
            "length": 22,
            "docLength": 8
          },
          {
            "id": "d7055f8e-3b9e-b6a7-fd4d-8d872b44599d",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Extracts an argument from a given operand, which can be either a binary operator, a field access or a literal. The extraction process involves calling different methods depending on the type of operand.",
            "name": "__extract_argument",
            "location": {
              "start": 225,
              "insert": 229,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 228,
                "end": 234
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 6
          },
          {
            "id": "f59dc153-d320-389f-094e-60652ea034d7",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Extracts and concatenates field paths from an HplFieldAccess object, which represents an operand. It splits the message and field names by '.' and returns the resulting path as a list of strings.",
            "name": "__extract_field_path",
            "location": {
              "start": 240,
              "insert": 241,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 240,
                "end": 248
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 8
          },
          {
            "id": "b316e573-77ca-0484-144f-fa299c304266",
            "ancestors": [
              "6cfe1fe3-2528-92a2-7a4f-70c74bc2545a"
            ],
            "description": "Extracts the value from an operand, which can be either a HplLiteral or a HplBinaryOperator. For HplLiteral, it checks if the value is an integer, float, or boolean and returns it directly; otherwise, it removes quotes from the value string.",
            "name": "__extract_value",
            "location": {
              "start": 255,
              "insert": 259,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 258,
                "end": 266
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 8
          }
        ]
      }
    }
  },
  {
    "name": "command.py",
    "path": "rigel/plugins/core/test/introspection/command.py",
    "content": {
      "structured": {
        "description": "A hierarchical system for managing commands between nodes in a simulation. The system uses ROSBridgeClient and Enum classes from Python's standard library and rigel.clients module respectively. It provides classes for commands, command handlers, and command builders, allowing users to create and manage commands that can be sent between nodes.",
        "items": [
          {
            "id": "ffc49f04-6452-21b7-f24a-c2b45b8f57dd",
            "ancestors": [],
            "description": "Defines a set of enumerations that represent different types of commands. These commands are used to manage connections, status changes, and simulation control within a ROSBridge system. The enumeration values range from 1 to 5, each corresponding to a unique command type.",
            "attributes": [
              {
                "name": "ROSBRIDGE_CONNECT",
                "type_name": "int",
                "description": "1. It represents a command to connect to the ROS bridge."
              },
              {
                "name": "ROSBRIDGE_DISCONNECT",
                "type_name": "int",
                "description": "2, indicating a command to disconnect from a ROS (Robot Operating System) bridge."
              },
              {
                "name": "STATUS_CHANGE",
                "type_name": "int",
                "description": "3. It represents a command for status change, indicating a request to modify or update the current system state."
              },
              {
                "name": "STOP_SIMULATON",
                "type_name": "int",
                "description": "4, indicating a stop command for simulation."
              },
              {
                "name": "TRIGGER",
                "type_name": "int",
                "description": "5. It represents a command type for triggering an action or event in the system."
              }
            ],
            "name": "CommandType",
            "location": {
              "start": 7,
              "insert": 8,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 6,
            "docLength": null
          },
          {
            "id": "94dc6f8e-735a-b4b3-e741-a68ff277effd",
            "ancestors": [],
            "description": "Initializes an instance with a specified `type` and `data`, which is expected to be a dictionary. It sets these attributes for future use, providing a basic structure for commands that require type identification and data storage.",
            "attributes": [
              {
                "name": "type",
                "type_name": "CommandType",
                "description": "Initialized with a value during object creation. It represents the type or classification of the command being defined."
              },
              {
                "name": "data",
                "type_name": "Dict[str,Any]",
                "description": "Initialized with a dictionary where keys are strings and values can be any type of data (e.g., numbers, strings, objects). It represents additional information specific to each command."
              }
            ],
            "name": "Command",
            "location": {
              "start": 15,
              "insert": 16,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 15,
                "end": 18
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 3
          },
          {
            "id": "80dcfc4d-685d-f485-c140-49b85d2b3434",
            "ancestors": [
              "94dc6f8e-735a-b4b3-e741-a68ff277effd"
            ],
            "description": "Initializes two instance variables: `type`, which is an object of type CommandType, and `data`, which is a dictionary with string keys and values of any type.",
            "params": [
              {
                "name": "type",
                "type_name": "CommandType",
                "description": "Assigned to an instance variable `self.type`. It represents the type or category of the object being initialized. The specific meaning and values of this type are not specified in the provided code."
              },
              {
                "name": "data",
                "type_name": "Dict[str, Any]",
                "description": "Used to store key-value pairs of data. The keys are strings (str) and the values can be any type (Any)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "cmd = Command(CommandType.ADD, {'username': 'John', 'password': 'secret'})\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 19,
              "insert": 20,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "544fc150-e272-32b0-694f-033c3e9f0ea2",
            "ancestors": [],
            "description": "Represents a hierarchical tree structure for handling commands. It provides methods to handle and send upstream and downstream commands, allowing nodes to communicate with their parents and children respectively.",
            "attributes": [
              {
                "name": "father",
                "type_name": "Optional[CommandHandler]",
                "description": "A reference to the parent node in the hierarchical tree, allowing commands to be sent upstream to it."
              },
              {
                "name": "children",
                "type_name": "List[CommandHandler]",
                "description": "Used to store a collection of child command handlers within the current handler's tree structure, forming a hierarchical relationship between nodes."
              }
            ],
            "name": "CommandHandler",
            "location": {
              "start": 24,
              "insert": 25,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 24,
                "end": 27
              }
            },
            "item_type": "class",
            "length": 26,
            "docLength": 3
          },
          {
            "id": "27cf6056-2f3d-f981-8a40-2e917aa87bfa",
            "ancestors": [
              "544fc150-e272-32b0-694f-033c3e9f0ea2"
            ],
            "description": "Sends an upstream command to its father if it exists, allowing for hierarchical handling of commands. The method takes a `command` object as input and returns None.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be passed as an argument. It represents the command that needs to be sent upstream for processing."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "child_handler = CommandHandler()\ngrand_child_handler = CommandHandler()\nchild_handler.father = grand_child_handler\nchild_handler.children = [CommandHandler()]\nchild_handler.send_upstream_cmd(Command())",
              "description": ""
            },
            "name": "send_upstream_cmd",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 47,
                "end": 53
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "4c386cc5-5da1-8da8-d74a-38ceedcf9e40",
            "ancestors": [
              "544fc150-e272-32b0-694f-033c3e9f0ea2"
            ],
            "description": "Iterates over its children, invoking their `handle_downstream_command` methods with the given command as an argument. This allows the command to be propagated and handled by downstream components.",
            "params": [
              {
                "name": "command",
                "type_name": "Command",
                "description": "Expected to be an object that represents a command. It is passed as an argument to the function, which then iterates over its children and calls their `handle_downstream_command` method with this command."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "handler1 = CommandHandler()\nhandler2 = CommandHandler()\nhandler3 = CommandHandler()\n\nhandler1.children.append(handler2)\nhandler2.children.append(handler3)\n\ncommand = Command()  # Initialize a command object\n\nhandler1.send_downstream_cmd(command)",
              "description": ""
            },
            "name": "send_downstream_cmd",
            "location": {
              "start": 59,
              "insert": 60,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 59,
                "end": 65
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 6
          },
          {
            "id": "aaf11568-c624-ee8a-bc44-c5c239e24eea",
            "ancestors": [],
            "description": "Provides methods to create various commands for a system, including connecting and disconnecting to ROSBridge, changing status, stopping simulation, and triggering an event with a specified timestamp. Each method returns a `Command` object with the corresponding type and optional parameters.",
            "attributes": [],
            "name": "CommandBuilder",
            "location": {
              "start": 83,
              "insert": 84,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 83,
                "end": 86
              }
            },
            "item_type": "class",
            "length": 35,
            "docLength": 3
          },
          {
            "id": "c9f6ba2e-e087-478b-5e4e-8cd8d385cd08",
            "ancestors": [
              "aaf11568-c624-ee8a-bc44-c5c239e24eea"
            ],
            "description": "Builds and returns a ROSBRIDGE_CONNECT command with a specified ROSBridgeClient object as its parameter, encapsulating it within a Command data structure.",
            "params": [
              {
                "name": "rosbridge_client",
                "type_name": "ROSBridgeClient",
                "description": "Expected to be an instance of the ROSBridgeClient class, which is likely a client for connecting to a ROS (Robot Operating System) bridge."
              }
            ],
            "returns": {
              "type_name": "Command",
              "description": "An instance of a class representing a command with two properties: CommandType set to ROSBRIDGE_CONNECT and a dictionary containing the client property with the value of rosbridge_client."
            },
            "usage": {
              "language": "python",
              "code": "client = ROSBridgeClient()\ncmd = CommandBuilder.build_rosbridge_connect_cmd(client)\n",
              "description": ""
            },
            "name": "build_rosbridge_connect_cmd",
            "location": {
              "start": 88,
              "insert": 90,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 89,
                "end": 97
              }
            },
            "item_type": "staticmethod",
            "length": 6,
            "docLength": 8
          },
          {
            "id": "e3460128-9339-9eb7-8c4f-0475b63d4fd0",
            "ancestors": [
              "aaf11568-c624-ee8a-bc44-c5c239e24eea"
            ],
            "description": "Creates and returns a ROSBridge disconnect command, represented as an instance of the `Command` class, with type set to `ROSBRIDGE_DISCONNECT` and no additional data (i.e., an empty dictionary).",
            "params": [],
            "returns": {
              "type_name": "Command",
              "description": "An instance of a class, specifically constructed with the following arguments: `CommandType.ROSBRIDGE_DISCONNECT` and an empty dictionary `{}` as its data."
            },
            "usage": {
              "language": "python",
              "code": "disconnect_cmd = CommandBuilder.build_rosbridge_disconnect_cmd()\n",
              "description": ""
            },
            "name": "build_rosbridge_disconnect_cmd",
            "location": {
              "start": 103,
              "insert": 105,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 104,
                "end": 110
              }
            },
            "item_type": "staticmethod",
            "length": 6,
            "docLength": 6
          },
          {
            "id": "f79e502c-5e85-279d-2841-821d717cf530",
            "ancestors": [
              "aaf11568-c624-ee8a-bc44-c5c239e24eea"
            ],
            "description": "Constructs and returns an instance of the Command class, specifying its type as STATUS_CHANGE with an empty dictionary as its payload.",
            "params": [],
            "returns": {
              "type_name": "Command",
              "description": "Initialized with CommandType.STATUS_CHANGE and an empty dictionary `{}` as its arguments."
            },
            "usage": {
              "language": "python",
              "code": "status_change_cmd = CommandBuilder.build_status_change_cmd()\n",
              "description": "\nThis line of code creates a status change command and assigns it to the variable status_change_cmd."
            },
            "name": "build_status_change_cmd",
            "location": {
              "start": 116,
              "insert": 118,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 117,
                "end": 123
              }
            },
            "item_type": "staticmethod",
            "length": 6,
            "docLength": 6
          },
          {
            "id": "fc9b639f-5c23-a7ac-584f-a35172212b0f",
            "ancestors": [
              "aaf11568-c624-ee8a-bc44-c5c239e24eea"
            ],
            "description": "Creates and returns a Command object with the type STOP_SIMULATION and an empty dictionary as its payload. The purpose is to build a command that stops a simulation process.",
            "params": [],
            "returns": {
              "type_name": "Command",
              "description": "Initialized with two parameters: the command type as STOP_SIMULATION and an empty dictionary `{}`."
            },
            "usage": {
              "language": "python",
              "code": "builder = CommandBuilder()\nstop_simulation_cmd = builder.build_stop_simulation_cmd()\n",
              "description": ""
            },
            "name": "build_stop_simulation_cmd",
            "location": {
              "start": 129,
              "insert": 131,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 130,
                "end": 137
              }
            },
            "item_type": "staticmethod",
            "length": 6,
            "docLength": 7
          },
          {
            "id": "a6c38222-80a0-a99c-2844-27a1831a3b44",
            "ancestors": [
              "aaf11568-c624-ee8a-bc44-c5c239e24eea"
            ],
            "description": "Constructs a Trigger command with an optional timestamp parameter. The returned command has a CommandType of TRIGGER and a payload containing the specified timestamp. This command is used to trigger some action or event at the given time.",
            "params": [
              {
                "name": "timestamp",
                "type_name": "float",
                "description": "0.0 by default. It represents a time value that will be included as part of the `Command` object being returned."
              }
            ],
            "returns": {
              "type_name": "Command",
              "description": "Instantiated with two parameters: CommandType.TRIGGER and a dictionary containing a single key-value pair 'timestamp' with default value 0.0."
            },
            "usage": {
              "language": "python",
              "code": "command = CommandBuilder.build_trigger_cmd(1.5)\n",
              "description": "\nThis code creates a Command object for triggering at timestamp 1.5."
            },
            "name": "build_trigger_cmd",
            "location": {
              "start": 143,
              "insert": 145,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 144,
                "end": 153
              }
            },
            "item_type": "staticmethod",
            "length": 6,
            "docLength": 9
          }
        ]
      }
    }
  },
  {
    "name": "parser.py",
    "path": "rigel/plugins/core/test/introspection/parser.py",
    "content": {
      "structured": {
        "description": "A parser and visitor for HPL (High-Level Protocol) simulation requirements. The parser uses the `property_parser` class from the `hpl.parser` package to parse HPL language syntax. The visitor is responsible for traversing the parsed Abstract Syntax Tree (AST) and extracting specific information about the simulation requirements, such as node types, event topics, and timeouts.",
        "items": [
          {
            "id": "ff974993-2f92-56be-cb45-7f9ec1ee3b74",
            "ancestors": [],
            "description": "Traverses an abstract syntax tree (AST) and extracts simulation requirements from it, creating a hierarchical structure of `SimulationRequirementNode` objects based on various types of events and patterns in the AST.",
            "attributes": [
              {
                "name": "requirement",
                "type_name": "Optional[SimulationRequirementNode]",
                "description": "Initialized to None. It is updated during the visit_hpl_pattern method based on the node's pattern type."
              }
            ],
            "name": "SimulationRequirementsVisitor",
            "location": {
              "start": 24,
              "insert": 25,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 24,
                "end": 27
              }
            },
            "item_type": "class",
            "length": 63,
            "docLength": 3
          },
          {
            "id": "7a5f88aa-f3a0-45b4-e446-dcf85ae99bcc",
            "ancestors": [
              "ff974993-2f92-56be-cb45-7f9ec1ee3b74"
            ],
            "description": "Parses an HplEventDisjunction object, extracting and linking its constituent simulation requirement nodes into a DisjointSimulationRequirementNode structure, representing a disjunction requirement event.",
            "name": "__initialize_disjunction_requirement_event",
            "location": {
              "start": 38,
              "insert": 39,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 38,
                "end": 46
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 8
          },
          {
            "id": "7560df67-f6ea-87b5-e541-84b472d68bfd",
            "ancestors": [
              "ff974993-2f92-56be-cb45-7f9ec1ee3b74"
            ],
            "description": "Initializes a SimpleSimulationRequirementNode with properties from an event and a callback function generated based on the predicate type (vacuous truth or binary operator).",
            "name": "__initialize_simple_requirement_node",
            "location": {
              "start": 61,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 61,
                "end": 69
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 8
          },
          {
            "id": "5e325869-30cf-3880-0249-8bc977a3ca5c",
            "ancestors": [
              "ff974993-2f92-56be-cb45-7f9ec1ee3b74"
            ],
            "description": "Extracts a simulation requirement node from an input event, returning it as a SimulationRequirementNode object. It handles three types of events: HplSimpleEvent, HplEventDisjunction, and raises an exception for unknown event subclasses.",
            "name": "__extract_simulation_requirement_node",
            "location": {
              "start": 84,
              "insert": 85,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 84,
                "end": 92
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 8
          },
          {
            "id": "434e9e64-bbe2-efb7-0b4e-f665bd93b950",
            "ancestors": [
              "ff974993-2f92-56be-cb45-7f9ec1ee3b74"
            ],
            "description": "Visits an HPLPattern node and creates a corresponding simulation requirement node based on the pattern type, setting its timeout value. It also extracts child nodes and adds them to the created requirement node's children list.",
            "params": [
              {
                "name": "node",
                "type_name": "HplPattern",
                "description": "Expected to be an instance of this class."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "visitor = SimulationRequirementsVisitor()\npattern_node = HplPattern(is_existence=True, max_time=5)\nvisitor.visit_hpl_pattern(pattern_node)",
              "description": ""
            },
            "name": "visit_hpl_pattern",
            "location": {
              "start": 101,
              "insert": 102,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 101,
                "end": 107
              }
            },
            "item_type": "method",
            "length": 18,
            "docLength": 6
          },
          {
            "id": "c95edabb-e78f-15b0-aa42-ce2e4811bc8e",
            "ancestors": [],
            "description": "Parses a string input representing simulation requirements and returns a structured representation of the requirements as an instance of `SimulationRequirementNode`.",
            "attributes": [
              {
                "name": "__parser",
                "type_name": "property_parser",
                "description": "Used to parse HPL requirement strings into abstract syntax trees (ASTs)."
              }
            ],
            "name": "SimulationRequirementsParser",
            "location": {
              "start": 127,
              "insert": 128,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 127,
                "end": 131
              }
            },
            "item_type": "class",
            "length": 17,
            "docLength": 4
          },
          {
            "id": "1caf1836-d1cb-dc8e-f048-5a2e2b4ca6e6",
            "ancestors": [
              "c95edabb-e78f-15b0-aa42-ce2e4811bc8e"
            ],
            "description": "Parses an HPL requirement string using a parser, traverses the resulting Abstract Syntax Tree (AST), and applies a visitor to each node to extract the simulation requirement into a SimulationRequirementNode object.",
            "params": [
              {
                "name": "hpl_requirement",
                "type_name": "str",
                "description": "Expected to contain an HPL (High Performance Linpack) requirement. The exact format and structure of this string are not specified."
              }
            ],
            "returns": {
              "type_name": "SimulationRequirementNode",
              "description": "Initialized by a SimulationRequirementsVisitor after parsing an HPL requirement string and traversing its abstract syntax tree (AST)."
            },
            "usage": {
              "language": "python",
              "code": "parser = SimulationRequirementsParser()\nhpl_requirement = \"some_input_string\"\nrequirement_node = parser.parse(hpl_requirement)\n",
              "description": ""
            },
            "name": "parse",
            "location": {
              "start": 139,
              "insert": 140,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 139,
                "end": 148
              }
            },
            "item_type": "method",
            "length": 10,
            "docLength": 9
          }
        ]
      }
    }
  },
  {
    "name": "strategy.py",
    "path": "rigel/plugins/core/test/introspection/strategy.py",
    "content": {
      "structured": {
        "description": "A set of comparison functions and an assessment strategy class for ROS (Robot Operating System) message fields. The comparison functions assess whether a given field is equal to, different from, lesser than, or greater than a specified value. The assessment strategy class provides a way to evaluate multiple conditions on ROS messages and stop evaluating once one condition is met.",
        "items": [
          {
            "id": "0d5b7dea-99bb-1fba-5741-759e2b8cb2e2",
            "ancestors": [],
            "description": "Evaluates a condition based on the provided operator and value against a given field. It determines whether the field satisfies the condition by calling helper functions corresponding to each operator, returning `True` if true or raising an exception for unknown operators.",
            "params": [
              {
                "name": "field",
                "type_name": "Any",
                "description": "Expected to hold some value. The exact type and nature of this value are unknown, as it is represented by the generic placeholder \"Any\"."
              },
              {
                "name": "operator",
                "type_name": "Any",
                "description": "Expected to be one of the following values: '=', '!=', '<', '<=', '>', '>='. This value determines which condition will be assessed based on the provided field and value."
              },
              {
                "name": "value",
                "type_name": "Any",
                "description": "Expected to be compared with the value of the given field using the specified operator. The nature of this comparison depends on the selected operator."
              }
            ],
            "returns": {
              "type_name": "bool",
              "description": "True if the specified condition is met and False otherwise, depending on the comparison operator and the values provided."
            },
            "usage": {
              "language": "python",
              "code": "result = assess_condition(10, '=', 5)\n",
              "description": ""
            },
            "name": "assess_condition",
            "location": {
              "start": 94,
              "insert": 95,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 94,
                "end": 107
              }
            },
            "item_type": "function",
            "length": 15,
            "docLength": 13
          },
          {
            "id": "80669450-72d3-87a1-0948-82639d7caa76",
            "ancestors": [],
            "description": "Defines an abstract interface for assessing a given field against an operator and a value. It has a boolean attribute `finished` initially set to `False`. The `assess` method is implemented as a no-op that raises an exception, indicating the absence of concrete implementation.",
            "attributes": [
              {
                "name": "finished",
                "type_name": "bool",
                "description": "Initialized to `False`. Its purpose is likely to track whether a simulation has finished its assessment process, but this is not explicitly stated within the provided code snippet."
              }
            ],
            "name": "AssessmentStrategy",
            "location": {
              "start": 124,
              "insert": 125,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 124,
                "end": 130
              }
            },
            "item_type": "class",
            "length": 5,
            "docLength": 6
          },
          {
            "id": "93caf2ca-7fae-8f9e-6143-2a62ae291c40",
            "ancestors": [],
            "description": "Assesses a condition on a given field with an operator and a value, marking it as finished once the condition is met. It ensures that assessment is done only once by checking the `finished` flag.",
            "attributes": [],
            "name": "SingleMatchAssessmentStrategy",
            "location": {
              "start": 138,
              "insert": 139,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 138,
                "end": 142
              }
            },
            "item_type": "class",
            "length": 5,
            "docLength": 4
          },
          {
            "id": "de174c2f-d400-a6ac-6844-5f29f4872fe9",
            "ancestors": [
              "93caf2ca-7fae-8f9e-6143-2a62ae291c40"
            ],
            "description": "Assesses a condition specified by a field, operator, and value. If the condition is met, it marks the assessment as finished by setting the `finished` attribute to True.",
            "params": [
              {
                "name": "field",
                "type_name": "Any",
                "description": "Likely to be an attribute or property of an object that needs to be evaluated against a condition specified by the `operator` and `value`."
              },
              {
                "name": "operator",
                "type_name": "str",
                "description": "Used to specify an operator for comparing the provided field with the given value. The allowed operators are not explicitly defined, but they likely include standard comparison operators such as '=', '!=', '<', '>' etc."
              },
              {
                "name": "value",
                "type_name": "Any",
                "description": "Expected to hold a value that can be used for comparison with the given field using the specified operator. The type is declared as `Any`, indicating that it can be any type of data."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "assessment_strategy = SingleMatchAssessmentStrategy()\nassessment_strategy.assess(\"age\", \"==\", 30)",
              "description": ""
            },
            "name": "assess",
            "location": {
              "start": 144,
              "insert": 145,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 144,
                "end": 155
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 11
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/test/__init__.py",
    "content": {
      "structured": {
        "description": "An import statement for a class named Plugin from a package named plugin. The Plugin class is likely responsible for implementing some functionality specific to this plugin. This import statement suggests that the plugin may be part of a larger system or framework that utilizes plugins to extend its capabilities.",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/plugins/core/test/models.py",
    "content": {
      "structured": {
        "description": "A custom data model using Pydantic's BaseModel class. It consists of required fields such as requirements and hostname, and optional fields port, timeout, and ignore with default values. The model enforces type constraints on these fields.",
        "items": [
          {
            "id": "75528e3f-7afa-d9aa-7743-6a40d09a9360",
            "ancestors": [],
            "description": "Defines a model for plugin configuration. It contains requirements, hostname, port number (defaulting to 9090), timeout period (defaulting to 300 seconds), and an ignore value (defaulting to 0). This class serves as a template for storing and managing plugin settings.",
            "attributes": [
              {
                "name": "requirements",
                "type_name": "List[str]",
                "description": "Intended to hold a list of string values representing software requirements for the plugin."
              },
              {
                "name": "hostname",
                "type_name": "str",
                "description": "Initialized with no value. It represents a hostname which is usually the name of a host or server on a network, but it can also be any string."
              },
              {
                "name": "port",
                "type_name": "int",
                "description": "Set to a default value of 9090. This means that if no port number is specified when creating an instance of this model, it will automatically use port 9090."
              },
              {
                "name": "timeout",
                "type_name": "float",
                "description": "300.0 by default, which specifies the time interval (in seconds) within which a connection or operation should be completed."
              },
              {
                "name": "ignore",
                "type_name": "float",
                "description": "0.0 by default."
              }
            ],
            "name": "PluginModel",
            "location": {
              "start": 5,
              "insert": 8,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 7,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/core/test/plugin.py",
    "content": {
      "structured": {
        "description": "A plugin class that implements a ROS (Robot Operating System) bridge client and manages simulation requirements for testing an application. The plugin connects to a ROS bridge server, sets up introspection for requirements parsing and connects to the server for processing.",
        "items": [
          {
            "id": "fa48cbd1-59be-3385-4145-57e2fbc79d84",
            "ancestors": [],
            "description": "Initializes and manages a plugin for a ROS (Robot Operating System) application, connecting to a ROS bridge server, parsing requirements, starting introspection, processing data, and stopping the process safely.",
            "attributes": [
              {
                "name": "model",
                "type_name": "PluginModel",
                "description": "Initialized by calling `ModelBuilder(PluginModel).build([], self.raw_data)`. It represents a model for the plugin, used to configure the plugin's behavior."
              },
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed as a parameter to its constructor. Its purpose is not explicitly defined within this code snippet."
              },
              {
                "name": "__rosbridge_client",
                "type_name": "Optional[ROSBridgeClient]",
                "description": "Used to ensure a safe stop at any moment by keeping track of the ROS bridge client connection status. It is initialized as None in the `__init__` method."
              },
              {
                "name": "__requirements_manager",
                "type_name": "Optional[SimulationRequirementsManager]",
                "description": "Initialized as None in the `__init__` method. It is used to manage simulation requirements, specifically for ROS bridge connections."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 17,
              "insert": 19,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 75,
            "docLength": null
          },
          {
            "id": "338058e0-9e44-0889-8942-487aa6cb7c38",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Initializes the plugin with given data and builds a model using the ModelBuilder. It also sets up optional instances for ROSBridgeClient and SimulationRequirementsManager, ensuring safe stop at any moment. An assertion ensures that the built model is indeed a PluginModel.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Expected to be passed during object initialization. It seems to hold raw data related to plugins. The specific purpose or structure of this data is not directly mentioned in this code snippet."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Not explicitly used within this function. Its purpose is unknown from the provided code snippet."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Passed to the parent class (`super().__init__`). Its purpose is not explicitly stated but it is likely related to the application context or environment within which this plugin operates."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Passed as an argument to the class constructor. It represents data related to providers."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional, having a default value of an empty dictionary."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'key1': 'value1', 'key2': 'value2'},\n    shared_data={'shared_key1': 'shared_value1'}\n)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 19,
              "insert": 27,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 24,
            "docLength": null
          },
          {
            "id": "6c98006d-e78f-d3b0-4443-f96c6f24352d",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Establishes a connection to a ROS bridge server at a specified hostname and port, then logs an informational message upon successful connection.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {})\nplugin.setup()\nplugin.connect_to_rosbridge_server()\n",
              "description": "\n\nNote that this example does not provide a complete code for usage of the `connect_to_rosbridge_server` function, but rather illustrates how to use it within the context of the provided class."
            },
            "name": "connect_to_rosbridge_server",
            "location": {
              "start": 48,
              "insert": 50,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "75226f21-5d1e-ec9b-134b-e01ff4a6cd1f",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Disconnects from a ROS bridge server and resets its client instance if one exists, then logs an informational message indicating successful disconnection.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {\"provider1\": \"value1\"})\nplugin.connect_to_rosbridge_server()\n# Perform some operations...\nplugin.disconnect_from_rosbridge_server()",
              "description": ""
            },
            "name": "disconnect_from_rosbridge_server",
            "location": {
              "start": 54,
              "insert": 55,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "e897b575-d656-8684-0541-3fc876da007c",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Initializes and configures introspection requirements for a plugin. It parses requirements, adds them to a manager, and connects the manager to a ROSbridge client for handling communication with ROS nodes.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.setup()\nplugin.start()",
              "description": ""
            },
            "name": "start_introspection",
            "location": {
              "start": 60,
              "insert": 62,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "c10f047a-1b28-6d87-a845-1fa9ee7df8bb",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Disconnects from ROSBridge if a requirements manager exists, indicating that introspection has been stopped or terminated. This function stops any ongoing communication with the ROSBridge component.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.start()\n# Do some work\nplugin.stop()\n",
              "description": ""
            },
            "name": "stop_introspection",
            "location": {
              "start": 69,
              "insert": 71,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "8d9c32ad-0080-6f90-e14a-155fca046ed4",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Initializes the plugin by connecting to a ROSBridge server and creating instances of SimulationRequirementsManager and SimulationRequirementsParser, passing parameters from the model to these objects.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.setup()\n",
              "description": ""
            },
            "name": "setup",
            "location": {
              "start": 74,
              "insert": 76,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "c1cb1c10-3c3b-fb9b-cb41-db7435a3a047",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Logs an informational message, then enters a loop that continues until the requirements manager indicates it has finished processing. Once done, it prints the requirements manager's status.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.setup()\nplugin.start()\nplugin.process()",
              "description": ""
            },
            "name": "process",
            "location": {
              "start": 91,
              "insert": 92,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "5afad087-a5e3-c994-354a-30ab03ad7024",
            "ancestors": [
              "fa48cbd1-59be-3385-4145-57e2fbc79d84"
            ],
            "description": "Stops introspection and disconnects from the ROSBridge server, indicating that the plugin's execution has been terminated.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.start()\n# Some processing happens here...\nplugin.stop()",
              "description": ""
            },
            "name": "stop",
            "location": {
              "start": 97,
              "insert": 98,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/__init__.py",
    "content": {
      "structured": {
        "description": "Four plugins: BuildXPlugin, ComposePlugin, DockerfilePlugin, and TestPlugin, each from a different package. The plugins appear to be used for building and testing container images in a Docker-based workflow. The BuildXPlugin and DockerfilePlugin are likely related to the build process, while the ComposePlugin may be used for managing complex application stacks with docker-compose.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/__init__.py",
    "content": {
      "structured": {
        "description": "An import statement that imports a class called Plugin from a module named plugin. The imported Plugin class is not immediately used in the provided code snippet, as indicated by the comment # noqa: F401, which means the line is intentionally ignored for code analysis purposes.",
        "items": []
      }
    }
  },
  {
    "name": "manager.py",
    "path": "rigel/plugins/manager.py",
    "content": {
      "structured": {
        "description": "A PluginManager class responsible for loading and initializing plugins based on their entrypoints, ensuring compliance with a base plugin class, and providing configuration data. The load method imports modules, retrieves classes, and builds instances of plugins using a builder pattern. It handles errors by raising exceptions when plugins are not found or do not comply with the required interface.",
        "items": [
          {
            "id": "db8d42f0-07ea-3192-2b44-dccfadafaad9",
            "ancestors": [],
            "description": "Manages plugins by checking compliance with a base class and loading them from modules. It resolves module and class names, verifies the plugin's structure, and constructs the plugin object using provided data.",
            "attributes": [],
            "name": "PluginManager",
            "location": {
              "start": 17,
              "insert": 19,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 38,
            "docLength": null
          },
          {
            "id": "c02bb853-665a-4fb5-514d-fd83c84613ed",
            "ancestors": [
              "db8d42f0-07ea-3192-2b44-dccfadafaad9"
            ],
            "description": "Loads and initializes a plugin based on an entrypoint, using raw data, global data, application data, providers data and shared data to construct the plugin instance. It also checks for compliance with specific requirements.",
            "params": [
              {
                "name": "entrypoint",
                "type_name": "str",
                "description": "Expected to be a fully qualified class name of a plugin. It represents the entry point for loading the plugin."
              },
              {
                "name": "plugin_raw_data",
                "type_name": "PluginRawData",
                "description": "Likely used to provide raw data required for creating a plugin instance, including any necessary configuration or setup information."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Used to build the plugin instance with other data such as raw data, application, providers data, and shared data."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Not explicitly used within the function, but it seems to be an object representing a Rigelfile application."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary that stores data about providers for plugins, where keys are provider names and values are their corresponding data."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Used to create an instance of the Plugin class using ModelBuilder. It contains shared data that can be accessed by the plugin."
              }
            ],
            "returns": {
              "type_name": "Plugin",
              "description": "A constructed plugin object built from the specified entrypoint class and data passed as arguments."
            },
            "usage": {
              "language": "python",
              "code": "plugin_manager = PluginManager()\nplugin = plugin_manager.load('my_plugin.module.MyPlugin', \n                             some_plugin_raw_data, \n                             global_data, \n                             application_instance, \n                             {'provider1': 'value1', 'provider2': 'value2'}, \n                             {'shared_key': 'shared_value'})",
              "description": ""
            },
            "name": "load",
            "location": {
              "start": 32,
              "insert": 41,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 40,
                "end": 56
              }
            },
            "item_type": "method",
            "length": 33,
            "docLength": 16
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/plugin.py",
    "content": {
      "structured": {
        "description": "A plugin class that conforms to a specific interface, ensuring consistency across all plugins. The plugin initializes itself with various data, including raw and shared data, and uses a YAML decoder to process it. It provides methods for setup, start, process, and stop operations, allowing the plugin to execute its business logic and manage resources accordingly.",
        "items": [
          {
            "id": "05fe1eb9-8a75-40a6-574c-62316054d61c",
            "ancestors": [],
            "description": "Initializes and manages a plugin for a RigelFile application, providing access to raw data, global data, application instance, and shared data. It also decodes raw data using YAMLDataDecoder. The plugin implements setup, start, process, and stop methods for its execution life cycle.",
            "attributes": [
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Initialized in the constructor (`__init__`) method with a value provided as argument to the class constructor."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Initialized during object creation. It seems to represent a reference to the main application instance, likely used for communication or access to its functionality within the plugin."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str,Any]",
                "description": "Initialized with a dictionary mapping strings to any type of object during the constructor."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str,Any]|Dict[str,Any]",
                "description": "Optional with a default value of `{}`. It represents data that can be shared among plugins."
              },
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Set by decoding raw data from a YAML file using the YAMLDataDecoder class. It is initialized in the `__init__` method during object creation."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 11,
                "end": 13
              }
            },
            "item_type": "class",
            "length": 32,
            "docLength": 2
          },
          {
            "id": "e7662d6a-dc41-758f-a14f-7114b33cfea2",
            "ancestors": [
              "05fe1eb9-8a75-40a6-574c-62316054d61c"
            ],
            "description": "Initializes instances of its attributes: global data, application, providers data, and shared data. It also decodes raw data using YAMLDataDecoder and stores it as an instance variable.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Used as input for decoding by YAMLDataDecoder. It seems to represent raw data in some format, possibly YAML or similar. The decoded output is stored in self.raw_data."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Assigned to an instance variable with the same name. It represents data that has global scope and relevance."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Expected to be passed when initializing an instance of the class. Its purpose is not explicitly mentioned, but it could represent the main application or program that is being used in this context."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to contain data related to providers. It is initialized with an empty dictionary."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional. It represents additional data that can be shared across different parts of the program and can be used during the decoding process."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(\"raw_data\"),\n    global_data=RigelfileGlobalData(\"global_data\"),\n    application=Application(\"application\"),\n    providers_data={\"provider1\": \"value1\", \"provider2\": \"value2\"}\n)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 15,
              "insert": 24,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 19,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/providers/aws/__init__.py",
    "content": {
      "structured": {
        "description": "Imports from modules. The first import statement brings in the AWSProvider class from a module named provider. The second import statement brings in the AWSProviderOutputModel class from a module named models. These classes likely provide functionality related to Amazon Web Services (AWS) and data output models for AWS providers, respectively.",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/providers/aws/models.py",
    "content": {
      "structured": {
        "description": "Two classes using Pydantic's BaseModel: AWSProviderModel and AWSProviderOutputModel. The former is used for input validation while the latter represents output data. The AWSProviderModel validates the required fields, including aws_access_key_id, aws_secret_access_key, region_name, and services (a list of strings), ensuring that at least one service is selected.",
        "items": [
          {
            "id": "4f8bcef6-59b9-638d-b644-590c2b8373c2",
            "ancestors": [],
            "description": "Defines a data model for Amazon Web Services (AWS) provider configuration. It has properties for AWS access key ID, secret access key, region name, and list of supported services. The `validate_services` method checks if the service list is not empty.",
            "attributes": [
              {
                "name": "aws_access_key_id",
                "type_name": "str",
                "description": "Required."
              },
              {
                "name": "aws_secret_access_key",
                "type_name": "str",
                "description": "Part of the AWS provider model definition. It represents a sensitive secret key for accessing Amazon Web Services (AWS) resources."
              },
              {
                "name": "region_name",
                "type_name": "str",
                "description": "A mandatory field in this model. It represents the region name where AWS resources are located, required for interacting with Amazon Web Services."
              },
              {
                "name": "services",
                "type_name": "List[str]",
                "description": "Validated using a validator function, ensuring it contains at least one service name string. If no services are provided, it raises an InvalidValueError."
              },
              {
                "name": "ecr_servers",
                "type_name": "List[str]",
                "description": "Initialized with an empty list. This means it can store a collection of strings representing ECR server names."
              }
            ],
            "name": "AWSProviderModel",
            "location": {
              "start": 6,
              "insert": 9,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 14,
            "docLength": null
          },
          {
            "id": "8fa9915f-d9a9-58b4-434b-822caae547e3",
            "ancestors": [
              "4f8bcef6-59b9-638d-b644-590c2b8373c2"
            ],
            "description": "Validates the input services list. If it's empty, it raises an InvalidValueError; otherwise, it returns the original list. This function is typically used for data validation during model creation or update operations in an application.",
            "params": [
              {
                "name": "services",
                "type_name": "List[str]",
                "description": "Expected to be a list of strings, representing various services."
              }
            ],
            "returns": {
              "type_name": "List[str]",
              "description": "An unchanged list of service strings, if no error is raised. If the input list is empty, it raises an exception instead of returning anything."
            },
            "usage": {
              "language": "python",
              "code": "provider = AWSProviderModel(aws_access_key_id='access', aws_secret_access_key='secret', region_name='region', services=['ecr1', 'ecr2'])\n",
              "description": ""
            },
            "name": "validate_services",
            "location": {
              "start": 17,
              "insert": 19,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 18,
                "end": 21
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 3
          },
          {
            "id": "2e6552b6-8ecd-a295-6542-9b6d208f67b6",
            "ancestors": [],
            "description": "Defines a data model for output from an AWS provider. It inherits from `BaseModel` and has one attribute, `robomaker_client`, which is optional (can be `None`) and of type `Any`. This class ensures that the provided data conforms to its expected structure.",
            "attributes": [
              {
                "name": "robomaker_client",
                "type_name": "Optional[Any]",
                "description": "Initialized as None. This means that this attribute can either be a value of any data type or it can be None, indicating that no value has been assigned to it yet."
              }
            ],
            "name": "AWSProviderOutputModel",
            "location": {
              "start": 27,
              "insert": 30,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "provider.py",
    "path": "rigel/providers/aws/provider.py",
    "content": {
      "structured": {
        "description": "An AWSProvider class which extends Provider class from Rigel library. It provides functionality for connecting and disconnecting with AWS services such as Elastic Container Registry (ECR) and Robomaker. The provider uses boto3 and DockerClient to interact with these services. When connected, it authenticates with ECR using Docker login and retrieves Robomaker client using boto3 client.",
        "items": [
          {
            "id": "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4",
            "ancestors": [],
            "description": "Provides connectivity to AWS services such as ECR and RoboMaker for a Rigel file. It initializes with model data, logs into ECR servers, and connects/disconnects from RoboMaker based on service declarations.",
            "attributes": [
              {
                "name": "model",
                "type_name": "AWSProviderModel",
                "description": "Initialized during the object's initialization process. It represents a model specific to AWS providers and contains data related to services such as ECR and Robomaker."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Passed to the parent class's constructor (`super().__init__`). Its purpose is not explicitly defined in this snippet, but it likely contains raw data specific to the AWS provider."
              },
              {
                "name": "__docker",
                "type_name": "DockerClient",
                "description": "Initialized as an instance of the DockerClient class when the `AWSProvider` object is created. It provides methods to interact with Docker services, specifically login and logout for ECR (Elastic Container Registry)."
              },
              {
                "name": "__raw_output_model",
                "type_name": "Dict[str,Any]",
                "description": "Initialized as an empty dictionary in the constructor. It stores raw output data generated by AWS services during the connection process."
              }
            ],
            "name": "AWSProvider",
            "location": {
              "start": 18,
              "insert": 20,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 94,
            "docLength": null
          },
          {
            "id": "1cfa07f1-5b3d-58b7-c247-5400fa2f4034",
            "ancestors": [
              "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4"
            ],
            "description": "Initializes an instance of the class with four parameters: identifier, raw_data, global_data, and providers_data. It also builds an AWS provider model and sets up a Docker client for further use.",
            "params": [
              {
                "name": "identifier",
                "type_name": "str",
                "description": "Expected to be an identifier or name for this instance."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Expected to be an instance of that class or any other object compatible with it. It represents raw data related to providers, which may include various provider-specific attributes or parameters."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Expected to be passed as an argument when initializing an instance of this class."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be passed with dictionary values that map string keys to any type (Any) of data."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "aws_provider = AWSProvider('my_identifier', ProviderRawData(), RigelfileGlobalData(), {'providers_data': 'value'})\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 20,
              "insert": 27,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 19,
            "docLength": null
          },
          {
            "id": "9ca47c2a-69ab-d6b4-104f-8f40fbe0da94",
            "ancestors": [
              "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4"
            ],
            "description": "Connects to various AWS services and builds an output model based on the connected services, raising an error if an unsupported service is encountered.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "aws_provider = AWSProvider('my_id', raw_data, global_data, providers_data)\naws_provider.connect()\n",
              "description": "\nThis code creates a new instance of the AWSProvider class and then calls its connect method."
            },
            "name": "connect",
            "location": {
              "start": 41,
              "insert": 42,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "2e4f794c-9603-55b6-4b4f-e9235b37dbd3",
            "ancestors": [
              "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4"
            ],
            "description": "Iterates over the services listed in self.model.services, disconnecting ECR and Robomaker services specifically, and raises an error for unsupported or invalid services.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "aws_provider = AWSProvider(identifier='aws', raw_data=..., global_data=..., providers_data={})\naws_provider.connect()\n# ... perform some operations ...\naws_provider.disconnect()",
              "description": ""
            },
            "name": "disconnect",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "ebd25eb8-feaa-9280-b545-1caea9ca1e54",
            "ancestors": [
              "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4"
            ],
            "description": "Logs into Amazon Elastic Container Registry (ECR) servers declared by the model instance, attempting login for each server and raising an exception if any error occurs during the process.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "aws_provider = AWSProvider(identifier=\"my_aws_identifier\", raw_data=None, global_data=None, providers_data=None)\naws_provider.connect()\n",
              "description": "\nThis will initiate a connection to all ECR servers defined for this AWS provider."
            },
            "name": "connect_ecr",
            "location": {
              "start": 65,
              "insert": 67,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 17,
            "docLength": null
          },
          {
            "id": "bf7a8aba-bb33-928b-d345-2e60e27fcfc2",
            "ancestors": [
              "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4"
            ],
            "description": "Logs out from all ECR servers associated with the model. It iterates over each server, attempts to log out using Docker's logout function, and handles any exceptions that may occur during the process.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "provider = AWSProvider('my_identifier', raw_data, global_data, providers_data)\nprovider.connect()\n# Use your services\nprovider.disconnect()\n",
              "description": ""
            },
            "name": "disconnect_ecr",
            "location": {
              "start": 83,
              "insert": 85,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "566c5a24-ccae-af8e-644e-b9887f787c76",
            "ancestors": [
              "b7dd0ec4-f10b-c5b3-ed4f-f2b7a75868a4"
            ],
            "description": "Authenticates with AWS RoboMaker using provided AWS access key ID, secret access key, and region name, then establishes an API client connection. If authentication fails, it raises a ClientError.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "aws_provider = AWSProvider(\"my_identifier\", raw_data, global_data, providers_data)\naws_provider.connect()\n",
              "description": "\nThis example initializes an instance of the AWSProvider class and then calls its connect method."
            },
            "name": "connect_robomaker",
            "location": {
              "start": 99,
              "insert": 101,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 17,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/providers/core/registry/models.py",
    "content": {
      "structured": {
        "description": "A model using Pydantic's `BaseModel` and restricts extra fields from being added to it. The model is named `ContainerRegistryProviderModel`. It has three required fields: `server`, `username`, and `password`.",
        "items": [
          {
            "id": "5c2d5a20-77f0-c3a8-e846-9f4110b67268",
            "ancestors": [],
            "description": "Defines a model for managing container registry providers' settings. It consists of three attributes: `server`, `username`, and `password`, which store the details required to connect to a container registry server, such as Docker Hub or Amazon ECR.",
            "attributes": [
              {
                "name": "server",
                "type_name": "str",
                "description": "Expected to contain a string representing the server name or URL for container registry."
              },
              {
                "name": "username",
                "type_name": "str",
                "description": "Part of the data model for a container registry provider. It represents the username required to access the registry."
              },
              {
                "name": "password",
                "type_name": "str",
                "description": "Part of the model definition, which is used for serializing and deserializing JSON data."
              }
            ],
            "name": "ContainerRegistryProviderModel",
            "location": {
              "start": 4,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "provider.py",
    "path": "rigel/providers/core/registry/provider.py",
    "content": {
      "structured": {
        "description": "A class ContainerRegistryProvider that acts as an interface for interacting with container registries such as Docker Hub. It uses various packages including Rigel, Python on Whales and typing to manage login, logout and other operations. The code initializes a Docker client object in its constructor and then provides methods connect and disconnect for managing the connection with the registry.",
        "items": [
          {
            "id": "e3dd6c0e-9d23-2697-3b41-f220d0007f3d",
            "ancestors": [],
            "description": "Provides a connection to a container registry, such as Docker Hub, and manages the login and logout process for accessing the registry's resources. It utilizes a `ModelBuilder` to construct a model of the registry provider and a `DockerClient` to interact with the registry.",
            "attributes": [
              {
                "name": "model",
                "type_name": "ContainerRegistryProviderModel",
                "description": "Initialized during the `__init__` method by using the ModelBuilder class to build a model based on the raw data provided."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Initialized in the constructor. Its purpose is not explicitly described, but it likely contains raw data or configuration needed for building the ContainerRegistryProviderModel instance."
              },
              {
                "name": "__docker",
                "type_name": "DockerClient",
                "description": "Initialized in the constructor (`__init__`) method. It represents a Docker client object used for interactions with a Docker registry during login and logout operations."
              }
            ],
            "name": "ContainerRegistryProvider",
            "location": {
              "start": 15,
              "insert": 17,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 48,
            "docLength": null
          },
          {
            "id": "a7146112-e379-8587-fa4d-21dc9a5ba66e",
            "ancestors": [
              "e3dd6c0e-9d23-2697-3b41-f220d0007f3d"
            ],
            "description": "Initializes an instance with provided identifier, raw data, global data, and providers' data. It also constructs a model using the ModelBuilder and DockerClient, verifying that the model is an instance of ContainerRegistryProviderModel.",
            "params": [
              {
                "name": "identifier",
                "type_name": "str",
                "description": "Likely used to uniquely identify an instance of the class. It is passed to the superclass's `__init__` method along with other parameters."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Used to initialize the object. Its exact usage depends on the class definition, but it may contain raw data relevant for initialization."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Used to initialize an object. The exact nature and purpose of this data are not specified by the provided code snippet."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Used to store data related to providers. It allows for storing arbitrary key-value pairs which are later referenced as `self.providers_data`."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "registry = ContainerRegistryProvider(\n    \"my-identifier\",\n    ProviderRawData(),\n    RigelfileGlobalData(),\n    {\"some\": \"data\"}\n)\n",
              "description": "\nThis code creates a new instance of `ContainerRegistryProvider`, passing in the required parameters."
            },
            "name": "__init__",
            "location": {
              "start": 17,
              "insert": 24,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 18,
            "docLength": null
          },
          {
            "id": "95b6e23d-185d-88b0-cb48-3888af7b74db",
            "ancestors": [
              "e3dd6c0e-9d23-2697-3b41-f220d0007f3d"
            ],
            "description": "Logs into a Docker registry using provided credentials and server URL, attempting to establish a connection for further Docker operations.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "registry_provider = ContainerRegistryProvider(\n    identifier='my_registry',\n    raw_data={},\n    global_data={},\n    providers_data={}\n)\nregistry_provider.connect()\n",
              "description": ""
            },
            "name": "connect",
            "location": {
              "start": 37,
              "insert": 39,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "0700365b-d595-9d80-494c-dd946f7950c6",
            "ancestors": [
              "e3dd6c0e-9d23-2697-3b41-f220d0007f3d"
            ],
            "description": "Logs out from a Docker server and handles any exceptions that might occur during the process, reporting success or failure accordingly.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "registry_provider = ContainerRegistryProvider(\"my_identifier\", ProviderRawData(), RigelfileGlobalData(), {})\nregistry_provider.connect()\n# perform operations with the registry\nregistry_provider.disconnect()",
              "description": ""
            },
            "name": "disconnect",
            "location": {
              "start": 54,
              "insert": 56,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/providers/core/ssh/models.py",
    "content": {
      "structured": {
        "description": "Input and output models using Pydantic library. The models describe SSH key groups and providers, with validation for mutually exclusive fields 'env' and 'path'. The code uses inheritance to create output models from input models, inheriting all the same fields. It also utilizes the RigelError exception for error handling during validation.",
        "items": [
          {
            "id": "22d29a81-9f87-e5bd-004e-b4bba5bc41e5",
            "ancestors": [],
            "description": "Validates the presence and exclusivity of two optional fields: `env` and `path`. It ensures that either one or neither field is provided, preventing both from being declared simultaneously.",
            "attributes": [
              {
                "name": "hostname",
                "type_name": "str",
                "description": "Required by default, as indicated by its absence from the list of optional attributes. It is not directly validated or checked for validity within this code snippet."
              },
              {
                "name": "env",
                "type_name": "Optional[str]",
                "description": "Optional, meaning it can be None or a string representing an environment variable name."
              },
              {
                "name": "path",
                "type_name": "Optional[str]",
                "description": "Optional, meaning it can be set to `None`. It represents a path to a file containing SSH key information."
              }
            ],
            "name": "SSHKeyGroup",
            "location": {
              "start": 10,
              "insert": 13,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 15,
            "docLength": null
          },
          {
            "id": "29285538-3fb4-2cb7-6448-e1f0656a724d",
            "ancestors": [
              "22d29a81-9f87-e5bd-004e-b4bba5bc41e5"
            ],
            "description": "Validates the presence and exclusivity of two fields ('env' and 'path') when declaring an SSH key. It ensures that either both or neither of these fields are declared, preventing contradictory configurations.",
            "params": [
              {
                "name": "values",
                "type_name": "Dict[str, Any]",
                "description": "An instance of a Pydantic model's configuration class. It represents the input data that is being validated by this decorator."
              }
            ],
            "returns": {
              "type_name": "Dict[str,Any]",
              "description": "The input dictionary `values`."
            },
            "usage": {
              "language": "python",
              "code": "ssh_key = SSHKeyGroup(hostname='example.com', env='dev')\n",
              "description": "\nor\n"
            },
            "name": "check_mutually_exclusive_fields",
            "location": {
              "start": 17,
              "insert": 19,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "dab579c2-4ad0-e2be-ac41-10e75e49afd7",
            "ancestors": [],
            "description": "Defines a data model for storing and validating SSH key information. It inherits from `BaseModel` and restricts extra attributes with `extra=Extra.forbid`. The `keys` attribute is a list of `SSHKeyGroup` objects, which represents the collection of SSH keys provided by this model.",
            "attributes": [
              {
                "name": "keys",
                "type_name": "List[SSHKeyGroup]",
                "description": "Forbidden from having extra values through the `extra=Extra.forbid` argument, ensuring that only valid SSH key groups are assigned to it."
              }
            ],
            "name": "SSHProviderModel",
            "location": {
              "start": 28,
              "insert": 31,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 3,
            "docLength": null
          },
          {
            "id": "86e892bd-9130-a688-d243-177ff5a6059a",
            "ancestors": [],
            "description": "Validates whether a SSH key has either its `env` or `path` attribute set, but not both simultaneously. It also checks if either of these attributes is missing when validating model instances.",
            "attributes": [
              {
                "name": "hostname",
                "type_name": "str",
                "description": "Required to be set when creating an instance of this class, as it is not marked as optional or nullable."
              },
              {
                "name": "env",
                "type_name": "Optional[str]",
                "description": "Optional, meaning it can be left undefined. It represents a environment variable for the SSH key."
              },
              {
                "name": "path",
                "type_name": "Optional[str]",
                "description": "Optional, meaning it can be either present or absent from a model instance."
              }
            ],
            "name": "SSHKeyGroup",
            "location": {
              "start": 38,
              "insert": 41,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 15,
            "docLength": null
          },
          {
            "id": "25bcdf4c-e19a-a5ac-9148-e10204ffa1a9",
            "ancestors": [
              "86e892bd-9130-a688-d243-177ff5a6059a"
            ],
            "description": "Validates whether 'env' and 'path' fields are declared simultaneously for an SSH key or not. If both fields are present, it raises an error; if neither is present, it also raises an error.",
            "params": [
              {
                "name": "values",
                "type_name": "Dict[str, Any]",
                "description": "Obtained from the `@root_validator` decorator. It represents the input data that is being validated for an SSH key configuration."
              }
            ],
            "returns": {
              "type_name": "Dict[str,Any]",
              "description": "The validated values passed to it. If no errors are found during validation, the original input is returned."
            },
            "usage": {
              "language": "python",
              "code": "ssh_key_group = SSHKeyGroup(hostname=\"example.com\", env=\"dev\")\n",
              "description": "\nor\n"
            },
            "name": "check_mutually_exclusive_fields",
            "location": {
              "start": 45,
              "insert": 47,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "provider.py",
    "path": "rigel/providers/core/ssh/provider.py",
    "content": {
      "structured": {
        "description": "An SSH provider class that builds and verifies SSH key groups for remote connections. The provider uses the rigel framework to manage data and models, and leverages os and typing modules for environment variable and file path checks. It initializes a model instance from raw data and global data, then connects by verifying environment variables and file paths of each SSH key group before storing the result in output model.",
        "items": [
          {
            "id": "86f75d4c-36f1-94b2-b147-04f988b578ac",
            "ancestors": [],
            "description": "Initializes a SSH provider with its identifier, raw data, global data, and providers' data. It verifies SSH keys by checking environment variables or file existence, connects to SSH server using verified keys, and disconnects from the server.",
            "attributes": [
              {
                "name": "model",
                "type_name": "SSHProviderModel",
                "description": "Initialized by calling `ModelBuilder(SSHProviderModel).build([], self.raw_data)`. It represents a model that describes the SSH provider's configuration."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Initialized during the object's instantiation. Its purpose and content are not explicitly described, but it is likely used to store raw data related to SSH provider connections or configuration."
              }
            ],
            "name": "SSHProvider",
            "location": {
              "start": 10,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 42,
            "docLength": null
          },
          {
            "id": "8e02b422-0693-498a-3f4d-3b6070570214",
            "ancestors": [
              "86f75d4c-36f1-94b2-b147-04f988b578ac"
            ],
            "description": "Initializes an instance by calling its superclass's constructor and then builds an SSH provider model using raw data. The model is expected to be an instance of SSHProviderModel, as verified by an assertion.",
            "params": [
              {
                "name": "identifier",
                "type_name": "str",
                "description": "Used to initialize the object with an identifier."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Expected to be an object that contains raw data related to providers."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Initialized with an instance of this data type. The purpose or contents of this global data are not specified within the provided code snippet."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to contain data related to providers. The exact structure of this dictionary is not specified."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ssh_provider = SSHProvider(\"example_identifier\", ProviderRawData(), RigelfileGlobalData(), {\"key1\": \"value1\"})\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 12,
              "insert": 19,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 16,
            "docLength": null
          },
          {
            "id": "4addde2e-d551-ad85-794c-53471a088a27",
            "ancestors": [
              "86f75d4c-36f1-94b2-b147-04f988b578ac"
            ],
            "description": "Checks if an environment variable exists for a given SSH key group. If the variable is set, it returns the key; otherwise, it raises an exception with an error message specifying the missing variable name.",
            "params": [
              {
                "name": "key",
                "type_name": "SSHKeyGroup",
                "description": "Required for the function's execution. It represents an environment variable name to be checked in the operating system's environment."
              }
            ],
            "returns": {
              "type_name": "SSHKeyGroup",
              "description": "A reference to the original input object if the environment variable associated with it exists, otherwise it raises an exception."
            },
            "usage": {
              "language": "python",
              "code": "ssh_provider = SSHProvider('my_identifier', ..., ...)\nssh_key_group = SSHKeyGroup(env='MY_SSH_KEY')\nssh_provider.verify_env(ssh_key_group)",
              "description": ""
            },
            "name": "verify_env",
            "location": {
              "start": 30,
              "insert": 31,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "b2916eaf-27f9-659c-9046-ccd19bd63718",
            "ancestors": [
              "86f75d4c-36f1-94b2-b147-04f988b578ac"
            ],
            "description": "Verifies if a given SSH key path exists as a file and returns it if true, otherwise raises an exception with an error message describing the invalid path.",
            "params": [
              {
                "name": "key",
                "type_name": "SSHKeyGroup",
                "description": "Passed to the function when called. It represents an instance of SSHKeyGroup, which likely encapsulates information about a Secure Shell (SSH) key."
              }
            ],
            "returns": {
              "type_name": "SSHKeyGroup",
              "description": "The input key if the corresponding file exists and can be accessed, otherwise it raises an exception with an error message."
            },
            "usage": {
              "language": "python",
              "code": "ssh_provider = SSHProvider(\"test\", ..., ...)\nkey = SSHKeyGroup(path=\"/path/to/ssh/key\")\nverified_key = ssh_provider.verify_file(key)",
              "description": ""
            },
            "name": "verify_file",
            "location": {
              "start": 36,
              "insert": 37,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "6a24073e-4e8b-8086-b84d-d14ee9adee7b",
            "ancestors": [
              "86f75d4c-36f1-94b2-b147-04f988b578ac"
            ],
            "description": "Iterates over its model keys, verifying environment settings for some and file paths for others. Then it constructs a new ModelBuilder object with the same content as the input model.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ssh_provider = SSHProvider(\"provider1\", ProviderRawData(), RigelfileGlobalData(), {})\nssh_provider.connect()\n",
              "description": "\nIn this example, a new instance of `SSHProvider` class named `ssh_provider` is created with identifier \"provider1\". The `connect` method is then called on the `ssh_provider` object."
            },
            "name": "connect",
            "location": {
              "start": 42,
              "insert": 43,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/providers/core/__init__.py",
    "content": {
      "structured": {
        "description": "Imports from other modules in a registry system. It includes ContainerRegistryProvider and SSHProvider which provide functionality for container registry and SSH connections respectively. The code also imports models such as SSHProviderOutputModel.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/providers/__init__.py",
    "content": {
      "structured": {
        "description": "An import statement from the provider package in the same module namespace. The imported Provider class is not utilized within this code snippet. The purpose of this line appears to be for future use or reference within the module.",
        "items": []
      }
    }
  },
  {
    "name": "manager.py",
    "path": "rigel/providers/manager.py",
    "content": {
      "structured": {
        "description": "A ProviderManager class that is responsible for loading and instantiating provider plugins. It uses importlib to dynamically load modules based on a provided entrypoint string, checks if the loaded module is compliant with the provider interface by verifying its inheritance from the Provider class, and finally builds an instance of the provider using ModelBuilder. The loaded provider can then be used to connect and disconnect with some external service or resource.",
        "items": [
          {
            "id": "ce60c6c3-4bec-6e84-3240-8817427e2857",
            "ancestors": [],
            "description": "Loads and validates providers by checking their compliance with a base `Provider` class and instantiates them with necessary data to create instances of the providers. It handles errors during importation, checks for correct inheritance and returns the provider instance.",
            "attributes": [],
            "name": "ProviderManager",
            "location": {
              "start": 16,
              "insert": 18,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 37,
            "docLength": null
          },
          {
            "id": "aa255bbc-479d-c5a6-844b-5d0d6fe7458c",
            "ancestors": [
              "ce60c6c3-4bec-6e84-3240-8817427e2857"
            ],
            "description": "Loads and configures a provider entrypoint, ensuring it is compliant with the 'Provider' class requirements. It returns a configured Provider object built from the loaded module, data, and identifier.",
            "params": [
              {
                "name": "entrypoint",
                "type_name": "str",
                "description": "Required for loading the provider. It represents the full name of the module where the provider class is defined, with the package name and class name separated by a dot (e.g., \"package.module:Provider\")."
              },
              {
                "name": "identifier",
                "type_name": "str",
                "description": "Used to identify a provider. It is one of the inputs required by the `ModelBuilder` class to build a `Provider` object."
              },
              {
                "name": "provider_raw_data",
                "type_name": "ProviderRawData",
                "description": "Used as input data for building the provider."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Used to pass global data that is required for loading the provider. The exact nature and usage of this data is not specified within this code snippet."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary that contains data for providers. Its structure and content are not specified."
              }
            ],
            "returns": {
              "type_name": "Provider",
              "description": "An instance of a class that inherits from 'Provider' and provides connection and disconnection functionality."
            },
            "usage": {
              "language": "python",
              "code": "manager = ProviderManager()\nprovider = manager.load('my.module:MyProvider', '12345', provider_raw_data, global_data, providers_data)",
              "description": ""
            },
            "name": "load",
            "location": {
              "start": 31,
              "insert": 39,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 38,
                "end": 54
              }
            },
            "item_type": "method",
            "length": 32,
            "docLength": 16
          }
        ]
      }
    }
  },
  {
    "name": "provider.py",
    "path": "rigel/providers/provider.py",
    "content": {
      "structured": {
        "description": "A Provider class that implements an interface for connecting and disconnecting from various provider services using the Rigel framework. The Provider class initializes with required data such as identifier, raw data, global data, and providers' data. It utilizes logging through the get_logger function from rigel.loggers package to log events.",
        "items": [
          {
            "id": "f1315ddd-f5b8-6aa5-8c4a-c82d3964eda1",
            "ancestors": [],
            "description": "Initializes and manages connections to a resource, represented by an identifier. It holds three types of data: raw provider data, global data, and providers' data. The class provides two methods: `connect` and `disconnect`, which are currently empty but can be implemented to establish and terminate the connection.",
            "attributes": [
              {
                "name": "identifier",
                "type_name": "str",
                "description": "Set during initialization with a provided value. It does not have any specific functionality or connection to other attributes, but it provides a unique identifier for each instance of the class."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Initialized during object creation with a value of ProviderRawData."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Initialized with a value during object creation. Its purpose is not explicitly stated, but it may contain global data related to the provider or the system."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str,Any]",
                "description": "Initialized during object creation with the value provided as argument."
              }
            ],
            "name": "Provider",
            "location": {
              "start": 9,
              "insert": 10,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 9,
                "end": 11
              }
            },
            "item_type": "class",
            "length": 18,
            "docLength": 2
          },
          {
            "id": "59b30252-1e24-38a2-6742-fb30adec0cb0",
            "ancestors": [
              "f1315ddd-f5b8-6aa5-8c4a-c82d3964eda1"
            ],
            "description": "Initializes an object with four parameters: identifier, raw data, global data, and providers' data. It sets these parameters as instance variables for future use.",
            "params": [
              {
                "name": "identifier",
                "type_name": "str",
                "description": "Assigned to the instance variable `self.identifier`."
              },
              {
                "name": "raw_data",
                "type_name": "ProviderRawData",
                "description": "Assigned to the instance variable `self.raw_data`."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Assigned to an instance variable named `global_data`."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary where keys are strings and values can be any data type (Any). It represents the provider-related data."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "provider = Provider(\"provider_id\", my_raw_data, global_data, {\"key\": \"value\"})",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 13,
              "insert": 20,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 11,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/__init__.py",
    "content": {
      "structured": {
        "description": "A version number with the value '0.3.0'.",
        "items": []
      }
    }
  },
  {
    "name": "exceptions.py",
    "path": "rigel/exceptions.py",
    "content": {
      "structured": {
        "description": "Various custom exceptions that can be raised during the execution of a program. The exceptions are categorized into different classes based on their functionality and purpose. These classes inherit from the base Exception class or other exception classes defined in this module.",
        "items": [
          {
            "id": "a9c81a1d-6c8a-e7ad-4d40-016970b57245",
            "ancestors": [],
            "description": "Defines a custom exception type, inheriting from Python's built-in `Exception`. It takes an optional base message and returns it as a string when converted to a string representation using `str()`. This allows for customized error messages in Rigel applications.",
            "attributes": [
              {
                "name": "base",
                "type_name": "str",
                "description": "Initialized by default to 'Generic Rigel error.' It stores a descriptive message for each instance of the exception, providing additional information about the error."
              }
            ],
            "name": "RigelError",
            "location": {
              "start": 4,
              "insert": 5,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 4,
                "end": 12
              }
            },
            "item_type": "class",
            "length": 8,
            "docLength": 8
          },
          {
            "id": "3771d020-8d1c-d4aa-7d45-e0069527844a",
            "ancestors": [],
            "description": "Instantiates an error with a custom message, including the name of the client and the underlying exception. It inherits from `RigelError`, which is not shown in this code snippet. The class sets instance variables for the client and exception.",
            "attributes": [
              {
                "name": "client",
                "type_name": "str",
                "description": "Initialized with a string value passed to the __init__ method, which represents the name or identifier of the client that reported the error."
              },
              {
                "name": "exception",
                "type_name": "Exception",
                "description": "Initialized with a specific exception object during the construction of the error object. This exception object likely holds information about the error that occurred."
              }
            ],
            "name": "ClientError",
            "location": {
              "start": 23,
              "insert": 24,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 23,
                "end": 31
              }
            },
            "item_type": "class",
            "length": 5,
            "docLength": 8
          },
          {
            "id": "9202cff7-982a-049e-6d4d-25173e594a3f",
            "ancestors": [
              "3771d020-8d1c-d4aa-7d45-e0069527844a"
            ],
            "description": "Initializes an object with error information from a client and an exception. It sets the parent's `__init__` method with a formatted string, then assigns the client name and exception to instance variables.",
            "params": [
              {
                "name": "client",
                "type_name": "str",
                "description": "Required to be passed when an instance of this class is created. It represents the name or description of the client reporting the error."
              },
              {
                "name": "exception",
                "type_name": "Exception",
                "description": "Used to pass an instance of an exception class, which provides detailed information about the error reported by the client."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    # Code that may throw an exception\nexcept Exception as e:\n    client_error = ClientError(\"MyClient\", e)\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 32,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 4,
            "docLength": null
          },
          {
            "id": "8849e294-032a-20be-134b-d9137e9e837b",
            "ancestors": [],
            "description": "Inherits from the `RigelError` class and overrides its `__init__` method to create an error object with a custom message that includes the original exception raised while calling the Docker API, along with storing the exception for further reference.",
            "attributes": [
              {
                "name": "exception",
                "type_name": "Exception",
                "description": "Used to store the exception that occurred while calling the Docker API. It is then included in the error message for further debugging purposes."
              }
            ],
            "name": "DockerAPIError",
            "location": {
              "start": 39,
              "insert": 40,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 39,
                "end": 45
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 6
          },
          {
            "id": "ce10ad0c-dfa4-8789-8847-3035dda55d77",
            "ancestors": [
              "8849e294-032a-20be-134b-d9137e9e837b"
            ],
            "description": "Initializes an instance with a specified Exception object. It calls the superclass's `__init__` method, passing a formatted string including the exception message, and sets the 'exception' attribute to the provided Exception object.",
            "params": [
              {
                "name": "exception",
                "type_name": "Exception",
                "description": "Not None. It represents an error that occurred during the call to the Docker API, which will be included in the initialization message for this exception object."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    # Docker API call\nexcept Exception as e:\n    docker_error = DockerAPIError(e)\n    # Handle the error\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 46,
              "insert": 47,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "03cc88ef-89a0-be92-264a-b24fcb915642",
            "ancestors": [],
            "description": "Represents an error that occurs when a Pydantic model fails to validate its data. It takes a `ValidationError` as input, stores it internally, and initializes with an error message describing the validation failure.",
            "attributes": [
              {
                "name": "exception",
                "type_name": "ValidationError",
                "description": "Initialized to store the error details when a Pydantic model fails validation."
              }
            ],
            "name": "PydanticValidationError",
            "location": {
              "start": 51,
              "insert": 52,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 51,
                "end": 58
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 7
          },
          {
            "id": "7683a16e-6a0a-ddb1-174c-6c0c46a0c943",
            "ancestors": [
              "03cc88ef-89a0-be92-264a-b24fcb915642"
            ],
            "description": "Initializes an instance by calling its superclass's constructor with a custom error message, and then assigns the provided exception to the instance's `exception` attribute.",
            "params": [
              {
                "name": "exception",
                "type_name": "ValidationError",
                "description": "Passed to this method during object initialization. It represents an error that occurred while validating a Pydantic model."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    model = UserSchema(username=\"test\", email=\"test\")\nexcept ValidationError as e:\n    error = PydanticValidationError(exception=e)\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 59,
              "insert": 60,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "cd81efc0-7fd1-1090-1f40-9dad0b7c015d",
            "ancestors": [],
            "description": "Represents an error that occurs when an environment variable is not declared or defined. It initializes with a message indicating the undeclared environment variable and provides access to the variable name through the `env` attribute.",
            "attributes": [
              {
                "name": "env",
                "type_name": "str",
                "description": "Initialized with a string value representing the name of the undeclared environment variable during object creation."
              }
            ],
            "name": "UndeclaredEnvironmentVariableError",
            "location": {
              "start": 64,
              "insert": 65,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 64,
                "end": 70
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 6
          },
          {
            "id": "a718a88b-18e3-ffbe-bd49-65f8ad8bc61d",
            "ancestors": [
              "cd81efc0-7fd1-1090-1f40-9dad0b7c015d"
            ],
            "description": "Initializes an instance with an error message and stores the name of the undeclared environment variable. It inherits from the `RigelError` class, indicating that it's a custom error type for handling undefined environment variables.",
            "params": [
              {
                "name": "env",
                "type_name": "str",
                "description": "Used to initialize an instance variable `self.env` with the value of the environment variable provided as argument. It is a required parameter for the object's initialization."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    my_error = UndeclaredEnvironmentVariableError(\"MY_VAR\")\nexcept RigelError as e:\n    pass  # Handle the error\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 71,
              "insert": 72,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "cfe95339-80d5-ab82-874d-fc4aedadf160",
            "ancestors": [],
            "description": "Specifies an error that occurs when a field is set to have the value of an undeclared global variable, providing information about the affected field and the undefined global variable.",
            "attributes": [
              {
                "name": "field",
                "type_name": "str",
                "description": "Used to store a string value representing the name of a field where an undeclared global variable has been set."
              },
              {
                "name": "var",
                "type_name": "str",
                "description": "Used to store the name of the undeclared global variable that is causing the error."
              }
            ],
            "name": "UndeclaredGlobalVariableError",
            "location": {
              "start": 76,
              "insert": 77,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 76,
                "end": 84
              }
            },
            "item_type": "class",
            "length": 5,
            "docLength": 8
          },
          {
            "id": "27dbf5a7-8413-a6aa-2449-70071378b718",
            "ancestors": [
              "cfe95339-80d5-ab82-874d-fc4aedadf160"
            ],
            "description": "Initializes an instance with a given field and variable name, setting its parent class (RigelError) with an error message describing the undeclared global variable. It also assigns the provided field and variable to the instance's attributes.",
            "params": [
              {
                "name": "field",
                "type_name": "str",
                "description": "Assigned to an instance variable with the same name, `self.field`."
              },
              {
                "name": "var",
                "type_name": "str",
                "description": "Assigned to an instance variable `self.var`. It represents the name of an undeclared global variable whose value is being used for the given field."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "error = UndeclaredGlobalVariableError(\"price\", \"my_variable\")\n",
              "description": "\n\nThis code creates a new object of class UndeclaredGlobalVariableError, passing in the strings \"price\" and \"my_variable\" as arguments to the __init__ method."
            },
            "name": "__init__",
            "location": {
              "start": 85,
              "insert": 86,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 4,
            "docLength": null
          },
          {
            "id": "32d96253-495f-5eb5-cb47-66e31d0e0810",
            "ancestors": [],
            "description": "Inherits from `RigelError` and defines a custom exception for when a Rigel file is not found. The `__init__` method initializes an instance with a specific error message, indicating that the user should use the 'rigel init' command to create a new Rigel file.",
            "attributes": [],
            "name": "RigelfileNotFoundError",
            "location": {
              "start": 91,
              "insert": 92,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 91,
                "end": 94
              }
            },
            "item_type": "class",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "a1124f87-5b2e-4da5-5147-81509743f27f",
            "ancestors": [],
            "description": "Inherits from `RigelError`. It takes a `trace` string as input, formats it into an error message, and initializes itself with that error message.",
            "attributes": [
              {
                "name": "trace",
                "type_name": "str",
                "description": "Initialized with a specific string value in the `__init__` method. This attribute stores a detailed error message describing what went wrong during the process of parsing the Rigelfile, which is used to construct the error message displayed to the user."
              }
            ],
            "name": "UnformattedRigelfileError",
            "location": {
              "start": 99,
              "insert": 100,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 99,
                "end": 105
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 6
          },
          {
            "id": "3d2c7df5-c22c-87a4-f44f-c7b5e16c6890",
            "ancestors": [
              "a1124f87-5b2e-4da5-5147-81509743f27f"
            ],
            "description": "Initializes an instance with a message indicating that a rigelfile is not properly formatted, and it stores the trace information leading to this error.",
            "params": [
              {
                "name": "trace",
                "type_name": "str",
                "description": "Passed to the superclass's constructor. It is expected to contain information about why the Rigelfile is not properly formatted, which is then included in the error message."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    with open(\"rigelfile.txt\", \"r\") as file:\n        file_contents = file.read()\nexcept Exception as e:\n    raise UnformattedRigelfileError(str(e))",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 106,
              "insert": 107,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "5f9c726c-88d0-b9a6-a84d-3486b3c5ca42",
            "ancestors": [],
            "description": "Inherits from `RigelError`. It represents an error that occurs when a `Rigelfile` is provided but contains no data. The `__init__` method initializes the error with a custom message \"Provided Rigelfile is empty.\"",
            "attributes": [],
            "name": "EmptyRigelfileError",
            "location": {
              "start": 111,
              "insert": 112,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 111,
                "end": 114
              }
            },
            "item_type": "class",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "8fd694c5-b6b5-be85-c04d-e2b7ad4343f9",
            "ancestors": [],
            "description": "Inherits from `RigelError` and initializes an error object with a specific message, including the invalid field name and value. It sets instance variables for the field and value to be used later.",
            "attributes": [
              {
                "name": "field",
                "type_name": "str",
                "description": "Initialized by the constructor to store the name of the field that has passed an invalid value."
              },
              {
                "name": "value",
                "type_name": "str",
                "description": "Initialized with a string that represents the invalid value passed for a specific field. This value is used to construct the error message and provide additional context about the invalid input."
              }
            ],
            "name": "InvalidValueError",
            "location": {
              "start": 120,
              "insert": 121,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 120,
                "end": 128
              }
            },
            "item_type": "class",
            "length": 5,
            "docLength": 8
          },
          {
            "id": "ffe58fde-05c6-368b-f74e-0a07e3e186d0",
            "ancestors": [
              "8fd694c5-b6b5-be85-c04d-e2b7ad4343f9"
            ],
            "description": "Initializes an object with information about an invalid field value. It sets the parent's (RigelError) message with the specified field and value, then assigns these values as instance variables for further use.",
            "params": [
              {
                "name": "field",
                "type_name": "str",
                "description": "Required for initializing an object, representing the name or label of a field that has passed an invalid value."
              },
              {
                "name": "value",
                "type_name": "str",
                "description": "Used to assign an instance variable of the same name, which represents the invalid value that was passed for a given field."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    error = InvalidValueError('age', 'twenty')\nexcept InvalidValueError as e:\n    # Handle the exception",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 129,
              "insert": 130,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 4,
            "docLength": null
          },
          {
            "id": "d4e195a5-b6a8-e882-0749-fc1a0eb07ad0",
            "ancestors": [],
            "description": "Defines an error type that represents an unsupported compiler. It inherits from `RigelError` and provides an initialization method to set the specific compiler name, which is used in the error message.",
            "attributes": [
              {
                "name": "compiler",
                "type_name": "str",
                "description": "Initialized during the `__init__` method with the value passed to the constructor, which represents the name of the unsupported compiler that raised the error."
              }
            ],
            "name": "UnsupportedCompilerError",
            "location": {
              "start": 136,
              "insert": 137,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 136,
                "end": 142
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 6
          },
          {
            "id": "77949034-d535-5e80-7f44-0953a36bacb6",
            "ancestors": [
              "d4e195a5-b6a8-e882-0749-fc1a0eb07ad0"
            ],
            "description": "Initializes an instance with a specified compiler and sets its parent class, RigelError, to raise an error message describing the unsupported compiler. The method assigns the provided compiler to the instance variable.",
            "params": [
              {
                "name": "compiler",
                "type_name": "str",
                "description": "Used to set the value of the instance variable `self.compiler`. It represents an unsupported compiler."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "compiler = \"gcc\"\nexception = UnsupportedCompilerError(compiler)\n",
              "description": "\nThis code snippet creates an instance of the `UnsupportedCompilerError` class, passing a string argument `\"gcc\"` to the `__init__` method."
            },
            "name": "__init__",
            "location": {
              "start": 143,
              "insert": 144,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "21fdd299-e3bf-0aa9-b14a-293de304b1fc",
            "ancestors": [],
            "description": "Raises an exception when a specified platform is not supported by the system, providing an error message that includes the name of the unsupported platform. It inherits from the `RigelError` class and initializes with the platform name.",
            "attributes": [
              {
                "name": "platform",
                "type_name": "str",
                "description": "Initialized in the constructor (`__init__`) with a value passed as an argument to the constructor, representing the platform that is unsupported by the system."
              }
            ],
            "name": "UnsupportedPlatformError",
            "location": {
              "start": 149,
              "insert": 150,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 149,
                "end": 155
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 6
          },
          {
            "id": "4e60c25a-8305-5c87-e24c-9adafc507067",
            "ancestors": [
              "21fdd299-e3bf-0aa9-b14a-293de304b1fc"
            ],
            "description": "Initializes an instance, taking a platform string as input. It calls the parent class's `__init__` with a formatted error message and sets the `self.platform` attribute to the provided platform name.",
            "params": [
              {
                "name": "platform",
                "type_name": "str",
                "description": "Intended to represent the specific operating system or device on which the program will run. It is initialized as an attribute of the class instance."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    unsupported_platform_error = UnsupportedPlatformError(\"Windows\")\nexcept Exception as e:\n    pass\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 156,
              "insert": 157,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "cc8bd2b9-4e95-bfb9-4944-481dc59f31a5",
            "ancestors": [],
            "description": "Handles exceptions raised when a plugin cannot be loaded due to its absence from the system. It takes the name of the missing plugin as an argument and provides a descriptive error message, suggesting installation through the command 'rigel install --help'.",
            "attributes": [
              {
                "name": "plugin",
                "type_name": "str",
                "description": "Initialized with a value passed to the `__init__` method, which represents the name of the plugin that could not be loaded."
              }
            ],
            "name": "PluginNotFoundError",
            "location": {
              "start": 161,
              "insert": 162,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 161,
                "end": 167
              }
            },
            "item_type": "class",
            "length": 6,
            "docLength": 6
          },
          {
            "id": "f8c8ac05-b404-fcbf-4f47-d8af134f0b54",
            "ancestors": [
              "cc8bd2b9-4e95-bfb9-4944-481dc59f31a5"
            ],
            "description": "Initializes an instance with a specific error message related to the given plugin, then calls the superclass's constructor with this message and stores the plugin name for further use.",
            "params": [
              {
                "name": "plugin",
                "type_name": "str",
                "description": "Expected to be a string representing a specific plugin name or identifier."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    plugin = \"wrong_plugin\"\n    error = PluginNotFoundError(plugin)\nexcept PluginNotFoundError as e:\n    # handle the exception",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 168,
              "insert": 169,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 5,
            "docLength": null
          },
          {
            "id": "20d501ba-c673-d496-e14f-62670cc1e104",
            "ancestors": [],
            "description": "Raises an exception when a plugin fails to comply with the Rigel plugin protocol, providing the name of the non-compliant plugin and the reason for the failure as error messages.",
            "attributes": [
              {
                "name": "plugin",
                "type_name": "str",
                "description": "Initialized during object creation with a string value passed as an argument to the class constructor, representing the name of the non-compliant plugin."
              },
              {
                "name": "cause",
                "type_name": "str",
                "description": "Initialized during the object creation. It provides additional information about why the plugin does not comply with Rigel's plugin protocol."
              }
            ],
            "name": "PluginNotCompliantError",
            "location": {
              "start": 175,
              "insert": 176,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 175,
                "end": 184
              }
            },
            "item_type": "class",
            "length": 5,
            "docLength": 9
          },
          {
            "id": "3c606b17-463a-f29f-1245-54da06b64d61",
            "ancestors": [
              "20d501ba-c673-d496-e14f-62670cc1e104"
            ],
            "description": "Initializes an object with two attributes: plugin and cause, setting it up to inherit from RigelError's initialization with a specific error message.",
            "params": [
              {
                "name": "plugin",
                "type_name": "str",
                "description": "Assigned to the instance variable `self.plugin`. It represents the name of the plugin that does not comply with the Rigel plugin protocol."
              },
              {
                "name": "cause",
                "type_name": "str",
                "description": "Used to specify the reason why the specified plugin does not comply with Rigel plugin protocol. It provides additional information about the issue."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "try:\n    raise PluginNotCompliantError('my_plugin', 'missing_required_function')\nexcept PluginNotCompliantError as e:\n    # handle exception\n",
              "description": "\nPass a plugin name and a cause of non-compliance to create an instance of the `PluginNotCompliantError` class."
            },
            "name": "__init__",
            "location": {
              "start": 185,
              "insert": 186,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 4,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "executor.py",
    "path": "rigel/executor.py",
    "content": {
      "structured": {
        "description": "Multiple classes and methods that work together to execute sequences of stages in a pipeline-like fashion. It utilizes threading for concurrent execution and plugins loaded from YAML files. The Pipeline execution is managed by StageExecutors which orchestrate the loading of plugins, their setup, start, processing and stop.",
        "items": [
          {
            "id": "3eef578c-cbe5-79be-754b-351b70a8433f",
            "ancestors": [],
            "description": "Defines a blueprint for an executor that manages the execution of stages in a pipeline. It provides methods for cancelling and executing stages, with the latter requiring global data, application information, and provider data as inputs.",
            "attributes": [
              {
                "name": "job_shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Initialized with default values. It can be accessed as a shared data structure among all job executions within this executor."
              }
            ],
            "name": "StageExecutor",
            "location": {
              "start": 21,
              "insert": 23,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 14,
            "docLength": null
          },
          {
            "id": "9d19a793-1f48-6380-7c40-59d8cef32cca",
            "ancestors": [
              "3eef578c-cbe5-79be-754b-351b70a8433f"
            ],
            "description": "Takes three parameters and raises a NotImplementedError. Its purpose is to execute a stage, but it does not provide any concrete implementation, making it abstract or placeholder for actual execution functionality that may be implemented later.",
            "params": [
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Expected to be passed when the function is called. It represents global data related to Rigel, which is likely a software or system component."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Expected to be an instance of a class representing an application."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary where keys are strings and values can be any Python object (Any). The purpose of this parameter is not explicitly stated."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "executor = StageExecutor()\nglobal_data = RigelfileGlobalData()\napplication = Application()\nproviders_data = {\"provider1\": \"value\", \"provider2\": \"value\"}\nexecutor.execute(global_data, application, providers_data)",
              "description": ""
            },
            "name": "execute",
            "location": {
              "start": 28,
              "insert": 34,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "aba8c8da-e086-5e80-384b-dd6ab98e4380",
            "ancestors": [],
            "description": "Loads a plugin using data from a `job`, `global_data`, and other parameters. It decodes raw data into a decoded raw data format, then uses a plugin manager to load the plugin with the processed data.",
            "attributes": [
              {
                "name": "__plugin_manager",
                "type_name": "PluginManager",
                "description": "Initialized with a default value. It manages plugins for the loader stage executor."
              }
            ],
            "name": "LoaderStageExecutor",
            "location": {
              "start": 37,
              "insert": 39,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 32,
            "docLength": null
          },
          {
            "id": "2a8337ef-6bea-b0a8-2840-4d240f57e316",
            "ancestors": [
              "aba8c8da-e086-5e80-384b-dd6ab98e4380"
            ],
            "description": "Loads and initializes a plugin, given job data, global data, application data, provider data, shared data, and optional overwrite data. It decodes the job data using YAML and then uses the decoded data to load the plugin.",
            "params": [
              {
                "name": "job",
                "type_name": "PluginDataModel",
                "description": "Required. It contains data that needs to be loaded for a plugin."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Not defined within this code snippet. Its purpose would depend on its definition and usage elsewhere in the code."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Passed to the function when it is called."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary containing data related to providers. The exact structure and content of this dictionary are not specified in the provided code snippet."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Passed to the `decode` method of the YAMLDataDecoder class. It contains shared data used during decoding of job raw data."
              },
              {
                "name": "overwrite_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional with default value of an empty dictionary. It allows for overwriting data from the job's raw data with new data provided by this parameter."
              }
            ],
            "returns": {
              "type_name": "Plugin",
              "description": "Loaded by calling the method `self.__plugin_manager.load()` with the provided parameters."
            },
            "usage": {
              "language": "python",
              "code": "job = PluginDataModel(plugin='plugin1', with_='{\"key\": \"value\"}')\nglobal_data = RigelfileGlobalData()\napplication = Application()\nproviders_data = {}\nshared_data = {\"key2\": \"value2\"}\noverwrite_data = {\"key\": \"new_value\"}\n\nplugin = loader_stage_executor.load_plugin(job, global_data, application, providers_data, shared_data, overwrite_data)\n",
              "description": ""
            },
            "name": "load_plugin",
            "location": {
              "start": 41,
              "insert": 50,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 49,
                "end": 54
              }
            },
            "item_type": "method",
            "length": 28,
            "docLength": 5
          },
          {
            "id": "93cad3e2-7b40-4f8c-fa4d-e52b1e55debb",
            "ancestors": [],
            "description": "Executes a list of stages asynchronously, managing job shared data and interacting with global application data and providers. Each stage is executed by setting its job shared data and executing it with provided data. The current stage can be cancelled if needed.",
            "attributes": [
              {
                "name": "stages",
                "type_name": "List[Union[SequentialStage,ConcurrentStage]]",
                "description": "Initialized during the __init__ method with a list of stages which can be either SequentialStage or ConcurrentStage."
              },
              {
                "name": "job_shared_data",
                "type_name": "Dict[str,Any]",
                "description": "Initialized with a dictionary that contains data shared among all stages within a job during execution. This data is set from outside the class."
              },
              {
                "name": "__current_stage",
                "type_name": "Optional[Union[SequentialStage,ConcurrentStage]]",
                "description": "Used to keep track of the current stage being executed within the execution branch. It is initialized as None and updated in each iteration of the loop in the run method."
              },
              {
                "name": "__global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Initialized during the `__init__` method. It represents global data for a rigelfile application."
              },
              {
                "name": "__application",
                "type_name": "Application",
                "description": "Referenced by the `run` method. It appears to be a representation of an application related to job execution, possibly holding configuration or control data used during the execution process."
              },
              {
                "name": "__providers_data",
                "type_name": "Dict[str,Any]",
                "description": "Passed to the constructor. It likely holds data related to service providers or resources utilized by the stages during execution."
              }
            ],
            "name": "ExecutionBranch",
            "location": {
              "start": 78,
              "insert": 80,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 38,
            "docLength": null
          },
          {
            "id": "94a1bb24-09fa-ceaa-2c4e-a9a0330f67e9",
            "ancestors": [
              "93cad3e2-7b40-4f8c-fa4d-e52b1e55debb"
            ],
            "description": "Initializes an instance of the class, setting attributes for stages, shared data, global data, application, and providers data. It also initializes a current stage attribute to None.",
            "params": [
              {
                "name": "stages",
                "type_name": "List[Union[SequentialStage, ConcurrentStage]]",
                "description": "Expected to hold one or more instances of either SequentialStage or ConcurrentStage."
              },
              {
                "name": "job_shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Assigned to an instance variable with the same name. It appears to hold data shared among stages of an execution branch related to a job."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Assigned to the instance variable `self.__global_data`."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Stored in the instance variable `self.__application`. It represents an instance of the application class, which likely contains information about the application's configuration or state."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary containing data related to providers, which are not further specified. It will be stored as an instance variable in the `ExecutionBranch` class."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "execution_branch = ExecutionBranch(\n    stages=[SequentialStage(), ConcurrentStage()],\n    job_shared_data={'data': 'shared'},\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'provider1': 'data'}\n)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 80,
              "insert": 88,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 18,
            "docLength": null
          },
          {
            "id": "eae43c1b-fb45-b7b9-334f-2956b3916cdc",
            "ancestors": [
              "93cad3e2-7b40-4f8c-fa4d-e52b1e55debb"
            ],
            "description": "Cancels its current stage if it exists, and then resets the stage to None, effectively terminating any ongoing operation.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "execution_branch = ExecutionBranch([...], [...], ..., ..., ...)\nexecution_branch.start()\n# Perform some actions\nexecution_branch.cancel()\n",
              "description": ""
            },
            "name": "cancel",
            "location": {
              "start": 99,
              "insert": 100,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "f65d85d4-47cc-138b-5743-7e34399e73ef",
            "ancestors": [
              "93cad3e2-7b40-4f8c-fa4d-e52b1e55debb"
            ],
            "description": "Iterates through each stage in the stages list, assigns current stage and shared job data to it, then executes the stage with provided global data, application, and providers data.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "execution_branch = ExecutionBranch(\n    [SequentialStage(), ConcurrentStage()], \n    {\"job_id\": \"123\"}, \n    RigelfileGlobalData(),\n    Application(\"app_name\"),\n    {\"provider1\": \"data1\", \"provider2\": \"data2\"}\n)\nexecution_branch.start()\n",
              "description": ""
            },
            "name": "run",
            "location": {
              "start": 104,
              "insert": 106,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 12,
            "docLength": null
          },
          {
            "id": "98e896d6-07a9-5f80-ec46-390ebfb1e053",
            "ancestors": [],
            "description": "Executes multiple combinations of stages and shared data in parallel, utilizing threads for concurrency. It takes in a list of stages, a matrix of data, and various global and application-specific parameters to create and execute execution branches.",
            "attributes": [
              {
                "name": "stages",
                "type_name": "List[Union[SequentialStage,ConcurrentStage]]",
                "description": "Initialized during the `__init__` method. It contains a list of stages that can be either sequential or concurrent."
              },
              {
                "name": "matrix",
                "type_name": "Dict[str,List[Any]]",
                "description": "Initialized during the `__init__` method. It represents a matrix-like data structure where keys are strings and values are lists, possibly containing Any type objects."
              },
              {
                "name": "threads",
                "type_name": "List[ExecutionBranch]",
                "description": "Populated by instances of the ExecutionBranch class, each representing a separate thread for executing a stage executor's execution branch."
              }
            ],
            "name": "ParallelStageExecutor",
            "location": {
              "start": 118,
              "insert": 120,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 64,
            "docLength": null
          },
          {
            "id": "cf6ce447-7dcb-25ab-e246-ca8670f24a93",
            "ancestors": [
              "98e896d6-07a9-5f80-ec46-390ebfb1e053"
            ],
            "description": "Initializes three attributes: stages, matrix, and threads. The `stages` attribute holds a list of either Sequential or Concurrent stage objects, while `matrix` is a dictionary mapping strings to lists of arbitrary types. The `threads` attribute is initialized as an empty list.",
            "params": [
              {
                "name": "stages",
                "type_name": "List[Union[SequentialStage, ConcurrentStage]]",
                "description": "Initialized with a list of stages that can be either SequentialStage or ConcurrentStage objects."
              },
              {
                "name": "matrix",
                "type_name": "Dict[str, List[Any]]",
                "description": "Initialized with an empty dictionary. This parameter maps string keys to lists of any data type (`Any`)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "parallel_executor = ParallelStageExecutor([SequentialStage(), ConcurrentStage()], {'key1': [1, 2], 'key2': ['value1', 'value2']})\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 120,
              "insert": 121,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 4,
            "docLength": null
          },
          {
            "id": "da814996-8848-98a4-8b4c-f3072f47b455",
            "ancestors": [
              "98e896d6-07a9-5f80-ec46-390ebfb1e053"
            ],
            "description": "Generates all possible combinations of values from the input matrix, where each key corresponds to a list of values. It then constructs dictionaries for these combinations and returns them as a list.",
            "name": "__combine_matrix_data",
            "location": {
              "start": 125,
              "insert": 126,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "c2d60daa-d8d3-8dab-b24c-928c507c6ceb",
            "ancestors": [
              "98e896d6-07a9-5f80-ec46-390ebfb1e053"
            ],
            "description": "Decodes YAML data from a matrix using a YAMLDataDecoder instance, taking into account job-shared data and header shared data.",
            "name": "__decode_matrix_data",
            "location": {
              "start": 135,
              "insert": 137,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "fd3a0610-723d-bfb7-cf4e-697e0b6a74bf",
            "ancestors": [
              "98e896d6-07a9-5f80-ec46-390ebfb1e053"
            ],
            "description": "Cancels all threads associated with it by calling their respective `cancel` methods, effectively terminating any ongoing tasks or operations within those threads.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "executor = ParallelStageExecutor(stages, matrix)\nexecutor.execute(global_data, application, providers_data)\n# Later in the code...\nexecutor.cancel()",
              "description": ""
            },
            "name": "cancel",
            "location": {
              "start": 144,
              "insert": 145,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "276ef30e-3bdc-9f87-764e-ded598d98978",
            "ancestors": [
              "98e896d6-07a9-5f80-ec46-390ebfb1e053"
            ],
            "description": "Executes multiple threads concurrently, utilizing a combination of data from global_data and providers_data to create local execution stages. It initializes and runs these threads, then waits for their completion.",
            "params": [
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Passed as an argument when calling this method. It provides global data related to the Rigelfile application, likely including configuration settings, constants, or other shared information."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Passed as an argument to the function when it is called."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary where keys are string values and values can be of any type."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "parallel_executor = ParallelStageExecutor(stages, matrix)\nrigelfile_global_data = RigelfileGlobalData()\napplication = Application()\nproviders_data = {\"provider1\": \"data\", \"provider2\": \"other data\"}\nparallel_executor.execute(rigelfile_global_data, application, providers_data)",
              "description": ""
            },
            "name": "execute",
            "location": {
              "start": 148,
              "insert": 155,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 35,
            "docLength": null
          },
          {
            "id": "2a2f2ed8-4550-3b9a-e44d-377c89b95a06",
            "ancestors": [],
            "description": "Executes a list of jobs sequentially, loading each job from a model, setting it up, starting it, processing it, and stopping it, before moving on to the next job. It also allows for cancellation of the current job if needed.",
            "attributes": [
              {
                "name": "job_models",
                "type_name": "List[PluginDataModel]",
                "description": "Initialized with a list of jobs during object creation. It represents the collection of job models to be executed by the executor."
              },
              {
                "name": "__current_job",
                "type_name": "Optional[Plugin]",
                "description": "Initialized to `None`. It keeps track of the current job being executed, updated after each iteration in the execution loop."
              }
            ],
            "name": "SequentialStageExecutor",
            "location": {
              "start": 187,
              "insert": 189,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 37,
            "docLength": null
          },
          {
            "id": "f2b94982-6e33-c6a0-774c-7c1ee3eb23a4",
            "ancestors": [
              "2a2f2ed8-4550-3b9a-e44d-377c89b95a06"
            ],
            "description": "Initializes an instance, taking a list of PluginDataModel objects as input, and assigns it to self.job_models. It also initializes self.current_job as None, indicating no current job is set.",
            "params": [
              {
                "name": "jobs",
                "type_name": "List[PluginDataModel]",
                "description": "Assigned to an instance variable `self.job_models`. It accepts a collection of PluginDataModel objects, which are presumably used to initialize or configure the class."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "jobs = [PluginDataModel(\"job1\"), PluginDataModel(\"job2\")]\nSequentialStageExecutor(jobs)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 189,
              "insert": 190,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 3,
            "docLength": null
          },
          {
            "id": "0e956b6a-1b3a-ecb8-e447-f504f28868b9",
            "ancestors": [
              "2a2f2ed8-4550-3b9a-e44d-377c89b95a06"
            ],
            "description": "Cancels any ongoing job if one exists, by calling its `stop` method and then resetting `self.__current_job` to None, effectively releasing resources associated with the job.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "executor = SequentialStageExecutor([job_model1, job_model2])\n# Initialize and execute jobs in the executor\nexecutor.execute(global_data, application, providers_data)\n\n# Cancel any ongoing or recently executed job\nexecutor.cancel()\n",
              "description": ""
            },
            "name": "cancel",
            "location": {
              "start": 193,
              "insert": 194,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "3579422a-8cea-379c-e444-b9a9b0bdc171",
            "ancestors": [
              "2a2f2ed8-4550-3b9a-e44d-377c89b95a06"
            ],
            "description": "Iterates over job models, loads each job plugin, sets it up, starts it, processes its tasks, and stops it before moving to the next one. It also keeps track of the current job being executed.",
            "params": [
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Passed to the method."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Not further defined or described within this snippet. Its purpose is to be used as an argument for the `load_plugin` method."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to contain data related to providers. It can be any valid dictionary that maps strings to objects of varying types."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "executor = SequentialStageExecutor([job_model1, job_model2])\ndata = RigelfileGlobalData()\napp = Application()\nproviders_data = {\"provider1\": \"value1\", \"provider2\": \"value2\"}\nexecutor.execute(data, app, providers_data)\n",
              "description": ""
            },
            "name": "execute",
            "location": {
              "start": 198,
              "insert": 205,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 26,
            "docLength": null
          },
          {
            "id": "572677df-42a0-efb2-f943-ccd2d9c4d1a7",
            "ancestors": [],
            "description": "Executes a list of jobs and their dependencies concurrently, allowing for parallel processing. It loads plugins, sets up, starts, processes, and stops each job, managing dependencies and canceling jobs as needed.",
            "attributes": [
              {
                "name": "job_models",
                "type_name": "List[PluginDataModel]",
                "description": "Populated with a list of PluginDataModel objects during initialization of the class instance."
              },
              {
                "name": "dependency_models",
                "type_name": "List[PluginDataModel]",
                "description": "Used to store a list of PluginDataModel objects, representing the dependencies for the job execution process."
              },
              {
                "name": "__current_job",
                "type_name": "Optional[Plugin]",
                "description": "Initialized to None. It holds the reference to the currently executing job plugin, which changes during the execution process."
              },
              {
                "name": "__dependencies",
                "type_name": "List[Plugin]",
                "description": "Used to store instances of Plugin that are loaded from dependency_models. It stores the dependencies for processing after all jobs have been executed."
              }
            ],
            "name": "ConcurrentStagesExecutor",
            "location": {
              "start": 226,
              "insert": 228,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 62,
            "docLength": null
          },
          {
            "id": "3f2e839e-77f6-94a0-0e46-9203751e9cd5",
            "ancestors": [
              "572677df-42a0-efb2-f943-ccd2d9c4d1a7"
            ],
            "description": "Initializes its instance variables, storing lists of job and dependency models, and setting up two additional variables to track the current job and dependencies as Plugin objects.",
            "params": [
              {
                "name": "jobs",
                "type_name": "List[PluginDataModel]",
                "description": "Assigned to the instance variable `self.job_models`."
              },
              {
                "name": "dependencies",
                "type_name": "List[PluginDataModel]",
                "description": "Populated with PluginDataModel objects representing dependencies between jobs."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ConcurrentStagesExecutor(jobs=[PluginDataModel1(), PluginDataModel2()], \n                         dependencies=[PluginDataModel3(), PluginDataModel4()])\n",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 228,
              "insert": 229,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 6,
            "docLength": null
          },
          {
            "id": "4d160f67-35d7-54b1-c949-0ceeac650600",
            "ancestors": [
              "572677df-42a0-efb2-f943-ccd2d9c4d1a7"
            ],
            "description": "Cancels any active jobs and dependencies, stopping their execution by calling their respective stop methods. It ensures that all ongoing tasks are terminated when cancellation is requested.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "executor = ConcurrentStagesExecutor([job1, job2], [dependency1])\nexecutor.execute(...)  # Assume this initializes and starts all jobs\nexecutor.cancel()\n",
              "description": "\nThis will stop the current job if it exists, and then stop all the dependencies."
            },
            "name": "cancel",
            "location": {
              "start": 235,
              "insert": 237,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "e473a110-7bc2-5f81-ff49-c82b238e85e2",
            "ancestors": [
              "572677df-42a0-efb2-f943-ccd2d9c4d1a7"
            ],
            "description": "Initializes and runs multiple jobs based on provided data, dependencies, and application settings. It sets up, starts, processes, and stops each job before finally stopping all dependent jobs.",
            "params": [
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Passed to the `load_plugin` method for each dependency model or job model. It seems to be an object containing global data that can be used by plugins."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Passed to the method from outside its scope, possibly representing an instance of some application framework or class that provides context for job execution."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary that maps strings (keys) to objects of type Any (values)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "concurrent_stages_executor = ConcurrentStagesExecutor([job1, job2], [dependency])\ndata = RigelfileGlobalData()\napp = Application()\nproviders_data = {'provider': 'value'}\nconcurrent_stages_executor.execute(data, app, providers_data)\n",
              "description": "\nNote that this code snippet is highly dependent on the actual implementation of `ConcurrentStagesExecutor` and its related classes."
            },
            "name": "execute",
            "location": {
              "start": 244,
              "insert": 251,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 44,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "main.py",
    "path": "rigel/main.py",
    "content": {
      "structured": {
        "description": "A command-line interface (CLI) using Click for managing ROS pipelines with Rigel. It includes commands for creating and initializing Rigelfile, which is a file used by Rigel. The CLI uses Python packages like click, os, and shutil for file operations, and pkg_resources for accessing assets.",
        "items": [
          {
            "id": "e4bf88ec-5b6b-c980-5648-cdfeb407026e",
            "ancestors": [],
            "description": "Defines a Click command-line interface (CLI) group with no explicit commands or options, effectively creating an empty CLI namespace that can be extended later by adding subcommands and options using the Click decorators.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "cli()\n",
              "description": ""
            },
            "name": "cli",
            "location": {
              "start": 12,
              "insert": 14,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 13,
                "end": 16
              }
            },
            "item_type": "function",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "21e2da85-55d3-df84-5c4a-7dfb45c6e604",
            "ancestors": [],
            "description": "Initializes a Rigelfile in the current directory by copying an existing template file if it does not already exist, or overwrites an existing one if the `--force` flag is provided. It informs the user of any existing files and provides instructions on how to use Rigel.",
            "params": [
              {
                "name": "force",
                "type_name": "bool",
                "description": "Flag-like, indicating whether to overwrite an existing Rigelfile if it exists. It is used in conjunction with the `--force` command-line option."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "init()\n",
              "description": "\n\nor if the force flag needs to be set:\n\n"
            },
            "name": "init",
            "location": {
              "start": 20,
              "insert": 23,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 22,
                "end": 25
              }
            },
            "item_type": "function",
            "length": 17,
            "docLength": 3
          },
          {
            "id": "77f2248b-77f4-cf9e-ab4c-1e4c9ecca0a8",
            "ancestors": [],
            "description": "Sets up a command-line interface (CLI) by adding a job command and an initialization command, then executes the CLI.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "main()\n",
              "description": ""
            },
            "name": "main",
            "location": {
              "start": 43,
              "insert": 44,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 43,
                "end": 46
              }
            },
            "item_type": "function",
            "length": 5,
            "docLength": 3
          }
        ]
      }
    }
  },
  {
    "name": "orchestrator.py",
    "path": "rigel/orchestrator.py",
    "content": {
      "structured": {
        "description": "An Orchestrator class responsible for executing and managing Rigelfiles, which contain sequences of jobs that can be executed concurrently or sequentially. The orchestrator initializes providers, connects and disconnects from them, manages job data, and generates execution plans for sequences. It also runs single jobs and sequences by creating wrapper sequences and executing the corresponding plans.",
        "items": [
          {
            "id": "9e2855ce-54cb-7498-d347-daf8367bb785",
            "ancestors": [],
            "description": "Manages and executes workflows defined in a YAML file (Rigelfile). It parses the file, initializes providers, connects/disconnects them, handles signals for stopping execution, creates executors for different stage types, generates an execution plan, and runs jobs or sequences.",
            "attributes": [
              {
                "name": "rigelfile",
                "type_name": "Rigelfile|None",
                "description": "Initialized in the constructor method `__init__`. It contains a parsed YAML file, which is built using the ModelBuilder."
              },
              {
                "name": "providers",
                "type_name": "List[Provider]",
                "description": "Initially empty. It stores instances of Provider objects loaded from YAML data, representing various providers for executing jobs."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str,Any]",
                "description": "Used to store data related to providers. It appears that it stores provider-specific information, possibly loaded from YAML files, and is accessible to various methods in the Orchestrator class."
              },
              {
                "name": "__provider_manager",
                "type_name": "ProviderManager",
                "description": "Initialized as ProviderManager(). It seems to be responsible for managing providers, possibly loading or creating instances based on provider data from the Rigelfile."
              },
              {
                "name": "__job_shared_data",
                "type_name": "Dict[str,Any]",
                "description": "Used to share data between stages of a job. It is initially set to an empty dictionary when a new job starts executing and can be updated by each stage during its execution."
              },
              {
                "name": "__current_stage",
                "type_name": "Optional[StageExecutor]",
                "description": "Used to keep track of the current stage being executed. It is updated when a new stage is started with its corresponding job shared data."
              },
              {
                "name": "initializate_providers",
                "type_name": "NoneNone",
                "description": "Called during the initialization process of the Orchestrator object. It initializes providers from the Rigelfile by loading each provider based on its data in the Rigelfile and adding them to the list of providers."
              }
            ],
            "name": "Orchestrator",
            "location": {
              "start": 30,
              "insert": 32,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 167,
            "docLength": null
          },
          {
            "id": "4d5c1724-8230-f182-3e44-8b4997192169",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Initializes and parses YAML rigelfile data, constructs variables and yaml_data from it, builds Rigelfile model using ModelBuilder, and sets up internal state including providers, provider manager, job shared data, and current stage executor.",
            "params": [
              {
                "name": "rigelfile",
                "type_name": "str",
                "description": "Required to parse YAML Rigelfile."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator(\"path_to_rigelfile.yml\")\n",
              "description": "\nIn this example, \"path_to_rigelfile.yml\" should be replaced with the actual path to a YAML file named rigelfile."
            },
            "name": "__init__",
            "location": {
              "start": 32,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 32,
                "end": 38
              }
            },
            "item_type": "constructor",
            "length": 35,
            "docLength": 6
          },
          {
            "id": "9168432c-eb87-fea9-6742-e2e65c1d2074",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Initializes providers by iterating over the items in `self.rigelfile.providers`, loads each provider using `__provider_manager.load`, and appends it to `self.providers`.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yaml')\n",
              "description": "\nThis code creates an instance of the Orchestrator class, passing a path to a YAML Rigelfile."
            },
            "name": "initializate_providers",
            "location": {
              "start": 78,
              "insert": 79,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 11,
            "docLength": null
          },
          {
            "id": "435aa432-1d0b-2fb4-c147-712bb55f0fa7",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Connects to multiple providers by iterating over a list of providers and calling their respective `connect` methods.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yaml')\norchestrator.connect_providers()\n",
              "description": "\nThis code assumes that 'path_to_rigelfile.yaml' exists and has a valid Rigelfile structure. The Orchestrator class is initialized with the YAML file, then it connects all providers specified in the file."
            },
            "name": "connect_providers",
            "location": {
              "start": 90,
              "insert": 91,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 90,
                "end": 92
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 2
          },
          {
            "id": "2f0ecba1-39fe-7e87-0642-a105520215cd",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Disconnects from all registered providers by calling their respective `disconnect` methods, logging an informational message before starting the disconnection process.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yaml')\norchestrator.connect_providers()\n# Perform some operations with connected providers...\norchestrator.disconnect_providers()",
              "description": ""
            },
            "name": "disconnect_providers",
            "location": {
              "start": 97,
              "insert": 98,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 97,
                "end": 99
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 2
          },
          {
            "id": "260c0283-2e8d-3691-b249-a54fe72228da",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Sets up handlers for SIGINT and SIGTSTP signals, allowing the program to respond to user attempts to terminate it (e.g., pressing CTRL-C or CTRL-Z). A warning message is also logged to inform users of this possibility.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_your_rigelfile.yml')\norchestrator.handle_signals()\norchestrator.connect_providers()\n",
              "description": "\nThis code creates an instance of the `Orchestrator` class with a rigelfile path and then calls its method `handle_signals`, followed by calling another method to connect providers."
            },
            "name": "handle_signals",
            "location": {
              "start": 104,
              "insert": 105,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 104,
                "end": 106
              }
            },
            "item_type": "method",
            "length": 4,
            "docLength": 2
          },
          {
            "id": "2a75b821-ecd4-f5a3-0f4d-87cb085f8486",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Terminates execution, logs an error message, and cancels any ongoing stage if present, then exits with a non-zero status code (1).",
            "params": [
              {
                "name": "*args",
                "type_name": "Any",
                "description": "List of positional arguments"
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yaml')\norchestrator.handle_signals()\n",
              "description": "\nThis code initializes an instance of the Orchestrator class and calls its handle_signals method to set up signal handlers for SIGINT and SIGTSTP, allowing the user to stop execution by pressing Ctrl-C or Ctrl-Z."
            },
            "name": "handle_abort",
            "location": {
              "start": 111,
              "insert": 112,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 111,
                "end": 115
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 4
          },
          {
            "id": "0ba407f1-250c-6787-6448-06aa3c852060",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Retrieves and returns job data from the `rigelfile` object based on a given job identifier. If the job identifier is a string, it directly accesses the corresponding job data; otherwise, it updates the retrieved job data with additional information provided in the `job` parameter.",
            "params": [
              {
                "name": "job",
                "type_name": "Union[str, SequenceJobEntry]",
                "description": "Required for this method to execute. It represents either a string job identifier or an object of class SequenceJobEntry with a name attribute."
              }
            ],
            "returns": {
              "type_name": "PluginDataModel",
              "description": "A deep copy of the specified job data from the rigelfile. The returned value includes any additional updates made to the job data by the SequenceJobEntry object if applicable."
            },
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yml')\njob_data = orchestrator.get_job_data('my_job')  # or orchestrator.get_job_data(my_sequence_job_entry)",
              "description": ""
            },
            "name": "get_job_data",
            "location": {
              "start": 124,
              "insert": 129,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          },
          {
            "id": "96516f5a-7cf6-60be-4642-18e60eea5a71",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Creates a SequentialStageExecutor instance, which executes jobs sequentially. The executor is initialized with job data from the given SequentialStage, obtained through the get_job_data method.",
            "params": [
              {
                "name": "stage",
                "type_name": "SequentialStage",
                "description": "Expected to be an instance of a class that represents a sequential processing stage, likely containing multiple jobs."
              }
            ],
            "returns": {
              "type_name": "SequentialStageExecutor",
              "description": "Initialized with a list of job data obtained from the jobs in the provided SequentialStage."
            },
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator(\"path_to_rigelfile.yml\")\nstage = SequentialStage(jobs=[\"job1\", \"job2\"])\nsequential_executor = orchestrator.create_sequential_executor(stage)",
              "description": ""
            },
            "name": "create_sequential_executor",
            "location": {
              "start": 145,
              "insert": 146,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "b830c171-db06-41a4-5f40-9bc9cbd62bcb",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Creates and returns an instance of ConcurrentStagesExecutor, passing two lists as arguments: one for job data and another for dependency data from the provided ConcurrentStage object.",
            "params": [
              {
                "name": "stage",
                "type_name": "ConcurrentStage",
                "description": "Expected to represent a concurrent processing stage that consists of jobs and their dependencies."
              }
            ],
            "returns": {
              "type_name": "ConcurrentStagesExecutor",
              "description": "Initialized with two lists: one containing the job data for each job in the given `stage`, and another containing the job data for each dependency of those jobs."
            },
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator(\"path_to_rigelfile.yaml\")\n\nconcurrent_stage = ConcurrentStage([job1, job2, job3])\nexecutor = orchestrator.create_concurrent_executor(concurrent_stage)\n",
              "description": ""
            },
            "name": "create_concurrent_executor",
            "location": {
              "start": 150,
              "insert": 151,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "44f542e8-e18a-95bf-8246-6ffa28dc283e",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Creates an executor for a parallel stage by recursively creating executors for its inner stages and combining them into a single ParallelStageExecutor instance.",
            "params": [
              {
                "name": "stage",
                "type_name": "ParallelStage",
                "description": "Expected to be an object with a \"parallel\" attribute containing a list of inner stages, each of which can be either SequentialStage or ConcurrentStage."
              }
            ],
            "returns": {
              "type_name": "ParallelStageExecutor",
              "description": "Initialized with a list of inner stages and a matrix. The inner stages are created by recursively calling other functions based on their types, i.e., SequentialStage or ConcurrentStage."
            },
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yaml')\nparallel_stage = parallel.Stage()\n# Add inner stages to parallel_stage...\nparallel_executor = orchestrator.create_parallel_executor(parallel_stage)\n",
              "description": "\nNote that this example is simplified for brevity and may not cover all possible scenarios."
            },
            "name": "create_parallel_executor",
            "location": {
              "start": 156,
              "insert": 157,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "e4023441-bef2-ff9f-734f-626b891c631a",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Generates an execution plan by iterating over a sequence of stages and creating corresponding stage executors based on their types (Parallel, Sequential, or Concurrent). The function returns a list of these stage executors.",
            "params": [
              {
                "name": "sequence",
                "type_name": "Sequence",
                "description": "Assumed to be an object that contains stages, such as ParallelStage, SequentialStage, or ConcurrentStage. The exact nature of this sequence is not specified."
              }
            ],
            "returns": {
              "type_name": "List[StageExecutor]",
              "description": "A list of StageExecutor objects, each representing an executor for a stage in the input sequence. The order of the executors corresponds to the order of stages in the input sequence."
            },
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator(\"path_to_rigelfile.yaml\")\nsequence = Sequence()\nstage1 = SequentialStage()\nstage2 = ParallelStage()\n\nsequence.stages.append(stage1)\nsequence.stages.append(stage2)\n\nplan = orchestrator.generate_execution_plan(sequence)\n",
              "description": ""
            },
            "name": "generate_execution_plan",
            "location": {
              "start": 167,
              "insert": 168,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 167,
                "end": 174
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 7
          },
          {
            "id": "6adc9a31-08e8-89bd-b243-dbc717cefb97",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Executes a list of execution plans defined in the `execution_plan` parameter, iterating through each plan and executing its stages by calling their `execute` methods.",
            "params": [
              {
                "name": "execution_plan",
                "type_name": "List[StageExecutor]",
                "description": "Expected to contain one or more StageExecutor instances, which represent the stages that need to be executed as part of the execution plan."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator('path_to_rigelfile.yaml')\nstage1 = SequentialStage()\nstage2 = SequentialStage()\n\nexecution_plan = [StageExecutor(stage1), StageExecutor(stage2)]\norchestrator.execute(execution_plan)",
              "description": ""
            },
            "name": "execute",
            "location": {
              "start": 189,
              "insert": 190,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 189,
                "end": 194
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 5
          },
          {
            "id": "54b0731b-a917-8ea7-0247-54b023c60747",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Executes a single job by creating an execution plan, handling signals, connecting providers, executing the plan, and disconnecting providers. It orchestrates the process of running a specific task or workflow.",
            "params": [
              {
                "name": "job",
                "type_name": "str",
                "description": "Expected to be a single job being executed by this method. It specifies the job for which an execution plan is generated and then executed."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator(\"path_to_rigelfile.yaml\")\norchestrator.run_job(\"my_job\")",
              "description": ""
            },
            "name": "run_job",
            "location": {
              "start": 207,
              "insert": 208,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 207,
                "end": 212
              }
            },
            "item_type": "method",
            "length": 12,
            "docLength": 5
          },
          {
            "id": "3a5ad6e1-b518-ed9a-3f43-6bb3592d403a",
            "ancestors": [
              "9e2855ce-54cb-7498-d347-daf8367bb785"
            ],
            "description": "Executes a specified sequence from a rigelfile, handling signals, connecting providers, and executing the plan. If the sequence is not found, it raises an error. The sequence is generated using the `generate_execution_plan` method.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required for identifying a sequence from the rigelfile's sequences dictionary."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "orchestrator = Orchestrator(\"path_to_rigelfile.yml\")\norchestrator.run_sequence(\"my_sequence_name\")",
              "description": ""
            },
            "name": "run_sequence",
            "location": {
              "start": 225,
              "insert": 226,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 225,
                "end": 230
              }
            },
            "item_type": "method",
            "length": 11,
            "docLength": 5
          }
        ]
      }
    }
  },
  {
    "name": "test_cli_command.py",
    "path": "tests/cli/test_cli_command.py",
    "content": {
      "structured": {
        "description": "A test suite for validating the functionality of a CLI command. It utilizes the click library and its Mocking feature from unittest.mock to test the addition of subcommands to the command group. The test case verifies that the command is correctly added to the group using the add_to_group method.",
        "items": []
      }
    }
  },
  {
    "name": "test_cli_run.py",
    "path": "tests/cli/test_cli_run.py",
    "content": {
      "structured": {
        "description": "Test cases for the `RunJobCommand` class using the `unittest` framework and mocks dependencies with `Mock`. It tests two subcommands 'rigel run job' and 'rigel run sequence', verifying they delegate execution flow correctly and handle exceptions raised by the `WorkspaceManager` class.",
        "items": []
      }
    }
  },
  {
    "name": "test_clients_docker.py",
    "path": "tests/clients/test_clients_docker.py",
    "content": {
      "structured": {
        "description": "Unit tests for a Docker client class using Python-on-whales library. The tests cover various scenarios such as creating, removing, running and waiting for Docker containers, networks, and builders. It uses mocking and patching to isolate dependencies and ensure that individual test cases are not affected by external factors.",
        "items": []
      }
    }
  }
]