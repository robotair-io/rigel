[
  {
    "name": "__init__.py",
    "path": "rigel/cli/__init__.py",
    "content": {
      "structured": {
        "description": "A simple calculator that can perform addition, subtraction, multiplication and division operations on two numbers entered by the user. The `Calculator` class utilizes the built-in `input` function to obtain user input, which is then processed using the corresponding arithmetic operator provided by the `operator` package.",
        "items": []
      }
    }
  },
  {
    "name": "command.py",
    "path": "rigel/cli/command.py",
    "content": {
      "structured": {
        "description": "A class CLICommand that is designed to simplify creating commands for a command-line interface (CLI) using the click library. It provides a mechanism for automatically registering commands and their corresponding callbacks with a click Group object. The CLICommand class also supports adding commands to an existing group, allowing for flexible configuration of the CLI.",
        "items": [
          {
            "id": "b40c25d8-80be-2dbf-9946-cfe9233e88f0",
            "ancestors": [],
            "description": "Facilitates the creation and management of commands for a command-line interface (CLI). It takes an optional command name and docstring, and automatically generates callback functions for each method in the class that can be used as CLI commands.",
            "attributes": [
              {
                "name": "__click_group",
                "type_name": "clickGroup",
                "description": "Initialized with a new instance of a Click Group object."
              },
              {
                "name": "__class__",
                "type_name": "type",
                "description": "A built-in Python attribute that holds the class of the object. It returns a reference to the class of the object, i.e., `CLICommand`."
              },
              {
                "name": "__generate_callback",
                "type_name": "Callable[[Callable,Any,Any],None]",
                "description": "Used to generate a new callback function from a given function f by adding self as its first argument."
              }
            ],
            "name": "CLICommand",
            "location": {
              "start": 6,
              "insert": 8,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 21,
            "docLength": null
          },
          {
            "id": "22399912-48ba-378b-d643-28ce911a6417",
            "ancestors": [
              "b40c25d8-80be-2dbf-9946-cfe9233e88f0"
            ],
            "description": "Initializes a Click group with commands and sets its name and help message. It also wraps the callback functions of commands with a wrapper function (`self.__generate_callback`) before adding them to the Click group.",
            "params": [
              {
                "name": "command",
                "type_name": "Optional[str]",
                "description": "Optional by default. If provided, it sets the name for the click group; otherwise, it defaults to the lowercase class name."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "class CLICommand1:\n    def command1(self):\n        \"\"\"This is help message for command1\"\"\"\n        print(\"Hello from command1!\")\n\n    def command2(self, arg: str = 'default'):\n        \"\"\"This is help message for command2. It takes one argument.\"\"\"\n        print(f\"Hello from command2! The argument is {arg}\")\n\ncommand1 = CLICommand1(command='first')\ncommand1.add_to_group(group=main)\n\nclass CLICommand2(CLICommand1):\n    def command3(self, arg: str):\n        \"\"\"This is help message for command3. It takes one argument.\"\"\"\n        print(f\"Hello from command3! The argument is {arg}\")\n\n    def command4(self):\n        \"\"\"This is help message for command4\"\"\"\n        print(\"Hello from command4!\")\n\ncommand2 = CLICommand2(command='second')\ncommand2.add_to_group(group=main)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 8,
              "insert": 10,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 11,
            "docLength": null
          },
          {
            "id": "9ed9669e-6a26-05af-a84e-deb82abd1c96",
            "ancestors": [
              "b40c25d8-80be-2dbf-9946-cfe9233e88f0"
            ],
            "description": "Generates a new callback function that can be used to execute an arbitrary function (`f`) with a custom context. The generated callback takes any number and type of arguments, and forwards them to the original function (`f`) after prepending its own instance as the first argument.",
            "name": "__generate_callback",
            "location": {
              "start": 21,
              "insert": 22,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "run.py",
    "path": "rigel/cli/run.py",
    "content": {
      "structured": {
        "description": "A CLI (Command-Line Interface) using the Click library that allows users to run jobs and sequences of jobs in a Rigel-based system. The Orchestrator class from the Rigel package is used to execute these jobs and sequences, which are defined in a Rigelfile.",
        "items": [
          {
            "id": "9a27d518-f52e-5e9f-e349-5329ca2ef394",
            "ancestors": [],
            "description": "Wraps two commands: 'run job' and 'run sequence'. Each command takes a string argument (job or sequence name). The class orchestrates jobs and sequences by instantiating an `Orchestrator` object, which runs the specified job or sequence.",
            "attributes": [],
            "name": "RunJobCommand",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 11,
                "end": 13
              }
            },
            "item_type": "class",
            "length": 23,
            "docLength": 2
          },
          {
            "id": "0eb29e44-1703-5190-1544-d0f9bed8fb0a",
            "ancestors": [
              "9a27d518-f52e-5e9f-e349-5329ca2ef394"
            ],
            "description": "Executes a job from the Rigelfile and orchestrates its execution using an Orchestrator object. If any error occurs during execution, it logs the error with a severity level of ERROR and terminates the program.",
            "params": [
              {
                "name": "job",
                "type_name": "str",
                "description": "Defined by @click.argument decorator. It expects a string input from the user when calling the command."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "$ python script.py run my_job_name\n",
              "description": "\nReplace `script.py` with your actual script name and replace `my_job_name` with the desired job name."
            },
            "name": "job",
            "location": {
              "start": 18,
              "insert": 21,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 20,
                "end": 22
              }
            },
            "item_type": "method",
            "length": 9,
            "docLength": 2
          },
          {
            "id": "a8958fc1-5286-45ad-5e4b-7a450ac81200",
            "ancestors": [
              "9a27d518-f52e-5e9f-e349-5329ca2ef394"
            ],
            "description": "Runs a sequence of commands defined by a given string. The command orchestrator is initialized with an Rigel file, and the sequence is executed using the orchestrator's run_sequence method. If any error occurs during execution, it logs the error and exits.",
            "params": [
              {
                "name": "sequence",
                "type_name": "str",
                "description": "Obtained from an argument passed to the command-line interface by click. It is used as input for the Orchestrator's `run_sequence` method."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "runjob runsequence \"Sequence1, Sequence2, Sequence3\"\n",
              "description": ""
            },
            "name": "sequence",
            "location": {
              "start": 30,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 32,
                "end": 34
              }
            },
            "item_type": "method",
            "length": 9,
            "docLength": 2
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/clients/__init__.py",
    "content": {
      "structured": {
        "description": "Two imports from separate modules, DockerClient and ROSBridgeClient. The imports seem to be unused based on the noqa: F401 comment, suggesting that these imports may not be necessary for the current implementation or may need further development.",
        "items": []
      }
    }
  },
  {
    "name": "docker.py",
    "path": "rigel/clients/docker.py",
    "content": {
      "structured": {
        "description": "A wrapper class `DockerClient` around the Docker client API using the `python_on_whales` library. The class provides methods for managing Docker containers, networks, and builders, including creating, removing, and inspecting these entities. It also includes error handling mechanisms to raise custom exceptions in case of any issues during operations.",
        "items": [
          {
            "id": "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2",
            "ancestors": [],
            "description": "Wraps the Python-on-whales library, providing a set of methods for interacting with Docker containers, networks, and builders. It allows managing, creating, inspecting, and removing these entities, as well as waiting for specific container statuses.",
            "attributes": [
              {
                "name": "DOCKER_CONTAINER_ID_DISPLAY_SIZE",
                "type_name": "int",
                "description": "12 by default. It determines the number of characters to display for a container ID when logging messages."
              },
              {
                "name": "DOCKER_RUN_TIMEOUT",
                "type_name": "int",
                "description": "120 seconds, which represents the maximum time to wait for a Docker container's status to become a certain state when running the `wait_for_container_status` method."
              },
              {
                "name": "DOCKER_RUN_WAIT_STATUS",
                "type_name": "int",
                "description": "3 seconds. It represents the time interval to wait before checking the status of a container after a Docker run operation, if the expected status has not been reached yet."
              },
              {
                "name": "client",
                "type_name": "python_on_whales.docker_client.DockerClient",
                "description": "Initialized in the constructor (`__init__`) with `python_on_whales.docker`. It provides a wrapper around the Docker client."
              }
            ],
            "name": "DockerClient",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 11,
                "end": 15
              }
            },
            "item_type": "class",
            "length": 142,
            "docLength": 4
          },
          {
            "id": "3831d581-9994-889f-1a4f-81b2e1cd30cb",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Retrieves an attribute from either the DockerClient object or its client attribute, and returns it if found. If not found in both places, it raises an AttributeError with a custom message indicating that no 'DockerClient' object has the specified attribute.",
            "params": [
              {
                "name": "__name",
                "type_name": "str",
                "description": "An attribute name to be accessed. It is used as a key to access attributes from either the object itself or its client, if not found in the object."
              }
            ],
            "returns": {
              "type_name": "Any",
              "description": "Either an attribute from itself or from its client, depending on whether it exists in one or both objects. If not found in both, it raises an AttributeError with a custom message."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\nresult = docker_client.DOCKER_CONTAINER_ID_DISPLAY_SIZE\ncontainer_id = docker_client.DOCKER_RUN_TIMEOUT\n",
              "description": "\n\nIn this example, `DockerClient` object's attribute is being accessed. If the `DockerClient` class has a class variable with that name, it will return the value directly from the class."
            },
            "name": "__getattribute__",
            "location": {
              "start": 33,
              "insert": 38,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 13,
            "docLength": null
          },
          {
            "id": "45c51269-15d7-b9ac-7c4d-0918bfb1735d",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Attempts to retrieve a Buildx Builder instance by name from the client's buildx inspect method, and returns it if successful; otherwise, it catches any DockerException that may occur during the retrieval process and returns None instead.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Expected to be a string that represents the name of a builder, which can be inspected or retrieved from Docker."
              }
            ],
            "returns": {
              "type_name": "Optional[python_on_whales.components.buildx.cli_wrapper.Builder]",
              "description": "Either an instance of class Builder or None. The value depends on whether a DockerException occurs during the inspection of a builder with the given name."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\nbuilder = docker_client.get_builder('example-builder')\nif builder:\n    # Use the builder object as needed.\nelse:\n    # Handle the case where no builder was found.",
              "description": ""
            },
            "name": "get_builder",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 50,
                "end": 57
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 7
          },
          {
            "id": "a098c727-2860-b189-ab4d-bfab48b41a6a",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Creates a new buildx builder with the specified name, use flag, and driver type. If the builder already exists, it returns the existing one; otherwise, it creates a new one and returns it.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required. It represents the name of the builder to be created or retrieved, which uniquely identifies a builder instance."
              },
              {
                "name": "use",
                "type_name": "bool",
                "description": "True by default. Its purpose is not explicitly specified, but based on its position among other parameters related to Docker buildx, it likely controls whether a builder should be used or not."
              },
              {
                "name": "driver",
                "type_name": "str",
                "description": "Set to 'docker-container' by default. It determines the driver used for building images with Buildx, such as Docker container or Kubernetes cluster."
              }
            ],
            "returns": {
              "type_name": "python_on_whales.components.buildx.cli_wrapper.Builder",
              "description": "Either an existing builder or a newly created one if no matching name is found."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\nbuilder = docker_client.create_builder(name='my_builder', use=True, driver='docker-container')\n",
              "description": ""
            },
            "name": "create_builder",
            "location": {
              "start": 63,
              "insert": 69,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 68,
                "end": 78
              }
            },
            "item_type": "method",
            "length": 13,
            "docLength": 10
          },
          {
            "id": "412fa7d2-74ea-2ea0-fe43-13c039e747b2",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Removes a builder with the given name from the buildx system using the client's buildx remove command. If the removal fails, it raises a DockerAPIError exception.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required to uniquely identify the builder that needs to be removed from the Docker environment."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\ntry:\n    docker_client.create_builder(\"my_builder\", use=True, driver=\"docker-container\")\nexcept Exception as e:\n    print(f\"Error creating builder: {e}\")\n\ntry:\n    docker_client.remove_builder(\"my_builder\")\nexcept Exception as e:\n    print(f\"Error removing builder: {e}\")\n",
              "description": ""
            },
            "name": "remove_builder",
            "location": {
              "start": 87,
              "insert": 88,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 87,
                "end": 93
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 6
          },
          {
            "id": "302c3547-dc2c-2595-e14e-f5f22076074b",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Retrieves a network with a given name from the Docker client, returns it if successful, or None if an exception occurs while inspecting the network.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required to be specified when calling this function. It represents the name of the network that needs to be retrieved or inspected."
              }
            ],
            "returns": {
              "type_name": "Optional[python_on_whales.components.network.cli_wrapper.Network]",
              "description": "A network object if it exists, or None if an exception occurs during its retrieval."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\nnetwork_name = \"my_network\"\nresult = docker_client.get_network(network_name)\n",
              "description": "\nThis code creates a DockerClient object and then attempts to retrieve a network named \"my_network\" using the get_network method."
            },
            "name": "get_network",
            "location": {
              "start": 101,
              "insert": 102,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 101,
                "end": 110
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 9
          },
          {
            "id": "c1b3b57a-8ebd-1ca2-e249-69585439c019",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Creates or retrieves a Docker network with a specified name and driver, and returns a CLI wrapper object for interacting with that network.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required. It specifies the name of the network to create or retrieve. If the network with this name already exists, it will be retrieved; otherwise, a new network with this name will be created."
              },
              {
                "name": "driver",
                "type_name": "str",
                "description": "Used to specify the driver for the network, such as 'bridge' or 'host', depending on the Docker networking mode desired."
              }
            ],
            "returns": {
              "type_name": "python_on_whales.components.network.cli_wrapper.Network",
              "description": "Either a created network object or an already existing network object if it was found by its name."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\nnetwork = docker_client.create_network(\"my-network\", \"bridge\")\n",
              "description": ""
            },
            "name": "create_network",
            "location": {
              "start": 116,
              "insert": 117,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 116,
                "end": 127
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 11
          },
          {
            "id": "1e0aa385-c562-9fab-ed49-98267b5a4614",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Removes a network with the given name from Docker. If the network does not exist, it raises an exception; if there's a Docker-related error during removal, it propagates the original exception.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Used to specify the name of a network that needs to be removed from the system."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\ndocker_client.remove_network('my_network')\n",
              "description": ""
            },
            "name": "remove_network",
            "location": {
              "start": 136,
              "insert": 137,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 136,
                "end": 142
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 6
          },
          {
            "id": "eb9fe3c8-49ed-f6bb-5e49-db9ceac3db29",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Retrieves information about a container with the given name. If the container exists, it returns the inspected container object; otherwise, it returns None. If an error occurs during the operation, it raises a DockerAPIError exception.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required for identifying a specific container. It is used to check if the container exists with the given name and to inspect the container if it does exist."
              }
            ],
            "returns": {
              "type_name": "Optional[python_on_whales.components.container.cli_wrapper.Container]",
              "description": "Either a Container object or None, depending on whether the container with the given name exists in Docker or not."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\ncontainer_name = \"my-container\"\nresult = docker_client.get_container(container_name)\n",
              "description": ""
            },
            "name": "get_container",
            "location": {
              "start": 150,
              "insert": 151,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 150,
                "end": 159
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 9
          },
          {
            "id": "688df19f-3c78-aebc-9f42-40c99b6470bd",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Runs a new Docker container from an image or returns an existing one with the given name. If no container exists, it creates and starts a new one; otherwise, it returns the existing one.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required. It represents the name of the container to be run or created. If the container with this name already exists, it returns an existing container instance; otherwise, it creates a new one."
              },
              {
                "name": "image",
                "type_name": "str",
                "description": "Used to specify the name or ID of an image from which a new container is created when running the container for the first time."
              },
              {
                "name": "**kwargs",
                "type_name": "Any",
                "description": "Dictionary of keyword arguments"
              }
            ],
            "returns": {
              "type_name": "Union[python_on_whales.components.container.cli_wrapper.Container, str, Iterable[Tuple[str, bytes]]]",
              "description": "Either an instance of Container, a string or an iterable of tuples containing strings and bytes."
            },
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\ncontainer = docker_client.run_container('my_container', 'python:3.9-slim')\n",
              "description": ""
            },
            "name": "run_container",
            "location": {
              "start": 168,
              "insert": 174,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 173,
                "end": 187
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 14
          },
          {
            "id": "ca765328-8a45-a58c-3544-43aa20a38f48",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Removes a container with the specified name from the system, forcing its removal if necessary and deleting any attached volumes. If an error occurs during removal, it raises a DockerAPIError exception.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required to specify the name of a container that needs to be removed from the system."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\ndocker_client.remove_container('test_container')",
              "description": ""
            },
            "name": "remove_container",
            "location": {
              "start": 197,
              "insert": 198,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 197,
                "end": 203
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 6
          },
          {
            "id": "c30e1732-dc9d-56bd-9b4c-9ed61abc2fb4",
            "ancestors": [
              "19bb5b8d-16c6-d2a6-2740-b37b34cd30d2"
            ],
            "description": "Waits for the status of a specified container to become a certain status, within a defined timeout period. If the container does not exist, it raises an exception.",
            "params": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required. It specifies the name of the container for which to wait for its status to become a specified status."
              },
              {
                "name": "status",
                "type_name": "str",
                "description": "Expected as a string representing the desired status of the container."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "docker_client = DockerClient()\nbuilder = docker_client.create_builder('my_builder', use=True, driver='docker-container')\ncontainer = builder.start()\ndocker_client.wait_for_container_status(container.id, 'running')",
              "description": ""
            },
            "name": "wait_for_container_status",
            "location": {
              "start": 211,
              "insert": 216,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 215,
                "end": 223
              }
            },
            "item_type": "method",
            "length": 30,
            "docLength": 8
          }
        ]
      }
    }
  },
  {
    "name": "rosbridge.py",
    "path": "rigel/clients/rosbridge.py",
    "content": {
      "structured": {
        "description": "A ROSBridgeClient class that wraps roslibpy's Ros class and provides a client for the ROS bridge websocket server. It allows users to connect to the ROS bridge, subscribe to topics, register message handlers, and remove them. The class uses roslibpy for low-level communication with the ROS bridge.",
        "items": [
          {
            "id": "b1b360a4-5f2f-ca86-b944-2ad5949b87d8",
            "ancestors": [],
            "description": "Returns a decorator that wraps a given function (`f`) to check if a client object's `rosbridge_client` attribute is not None before executing the wrapped function. If the client is active, it executes the original function with the provided arguments.",
            "params": [
              {
                "name": "f",
                "type_name": "Callable",
                "description": "Passed to this function. It represents a function that takes self as its first argument, followed by any number of positional and keyword arguments."
              }
            ],
            "returns": {
              "type_name": "Callable",
              "description": "A decorator that can be used to check if the client is active before calling a method `f`. If the client is active, it calls the original method `f`; otherwise, it does nothing."
            },
            "usage": {
              "language": "python",
              "code": "class MyClass:\n    def __init__(self):\n        self.rosbridge_client = None\n    \n    @client_is_active\n    def send_message(self, message):\n        # implementation of send_message method\n\nmy_object = MyClass()\nmy_object.send_message(\"Hello\")",
              "description": ""
            },
            "name": "client_is_active",
            "location": {
              "start": 11,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "5a0abb40-b961-04a0-3a42-0f8f01a6cd97",
            "ancestors": [
              "b1b360a4-5f2f-ca86-b944-2ad5949b87d8"
            ],
            "description": "Checks if an instance variable `rosbridge_client` exists and returns its value if it does. The returned value is generated by calling another function `f` with the current object (`self`) and any additional arguments (`*args`, **kwargs`).",
            "params": [
              {
                "name": "self",
                "type_name": "object",
                "description": "Used to pass implicit reference of the instance of a class. It allows the method called by this wrapper to access and modify attributes and methods of the class."
              },
              {
                "name": "*args",
                "type_name": "list",
                "description": "List of positional arguments"
              },
              {
                "name": "**kwargs",
                "type_name": "dict",
                "description": "Dictionary of keyword arguments"
              }
            ],
            "returns": {
              "type_name": "str|Any",
              "description": "Obtained by calling the function `f` with arguments `self`, `*args`, and `**kwargs`. The return value depends on the implementation of function `f`."
            },
            "usage": {
              "language": "python",
              "code": "wrapped_function = wrapper(f, \"argument1\", argument2=42)",
              "description": ""
            },
            "name": "wrapper",
            "location": {
              "start": 12,
              "insert": 13,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "function",
            "length": 3,
            "docLength": null
          },
          {
            "id": "95fd1d6a-1267-5ab3-a348-22bda15d1205",
            "ancestors": [],
            "description": "Connects to a ROS bridge, registers and removes message handlers for specific topics and message types, and manages subscribers. It persists connections until explicitly closed or an error occurs.",
            "attributes": [
              {
                "name": "handlers",
                "type_name": "Dict[Tuple[str, str], List[ROS_MESSAGE_HANDLER_TYPE]]",
                "description": "Used to store registered message handlers for specific topics and message types. It maps keys (topic, message_type) to lists of handler functions."
              },
              {
                "name": "subscribers",
                "type_name": "Dict[Tuple[str, str], roslibpy.core.Topic]",
                "description": "Used to keep track of all the topics subscribed by the client. Each topic subscription is represented as a key-value pair where the key is a tuple of (topic_name, message_type) and the value is the corresponding `Topic` object from `roslibpy`."
              },
              {
                "name": "rosbridge_client",
                "type_name": "Optional[roslibpy.Ros]",
                "description": "Initialized with a roslibpy.Ros object in the `__init__` method, allowing for connection to a ROS bridge."
              },
              {
                "name": "host",
                "type_name": "str",
                "description": "Initialized to 'localhost'. It specifies the hostname or IP address of the ROS bridge server that this client will connect to."
              },
              {
                "name": "port",
                "type_name": "int",
                "description": "9090 by default. It specifies the port number to which the ROS bridge client connects for communication with the ROS master."
              },
              {
                "name": "__persist",
                "type_name": "bool",
                "description": "Initially set to `True`. It determines whether the client should continue attempting to establish a connection when encountering exceptions during startup or shutdown operations."
              }
            ],
            "name": "ROSBridgeClient",
            "location": {
              "start": 18,
              "insert": 19,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 18,
                "end": 22
              }
            },
            "item_type": "class",
            "length": 81,
            "docLength": 4
          },
          {
            "id": "b8aa2f13-99e4-99ae-4f4e-07d04a77a438",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205"
            ],
            "description": "Initializes an instance by setting up internal data structures and establishing a connection to a ROS (Robot Operating System) bridge client. It takes optional host and port parameters, defaulting to 'localhost' and 9090 respectively.",
            "params": [
              {
                "name": "host",
                "type_name": "str",
                "description": "Set to 'localhost' by default. It represents the host name or IP address where the ROS (Robot Operating System) bridge is running, allowing connections from clients."
              },
              {
                "name": "port",
                "type_name": "int",
                "description": "9090 by default. It specifies the port number to which the Rosbridge client connects when establishing a connection with the ROS (Robot Operating System)."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ros_bridge_client = ROSBridgeClient(host='localhost', port=9090)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 29,
              "insert": 30,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 29,
                "end": 38
              }
            },
            "item_type": "constructor",
            "length": 9,
            "docLength": 9
          },
          {
            "id": "65762af0-f1be-2990-9949-6d9ed7bfb293",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205"
            ],
            "description": "Attempts to connect to a ROS bridge server specified by `self.host` and `self.port`, retrying up to `MAX_CONNECTION_ATTEMPTS` times if failed, and raises an exception if all retries fail.",
            "params": [
              {
                "name": "retries",
                "type_name": "int",
                "description": "30 by default. It determines how many times to retry connecting to the ROS bridge if an attempt fails, before raising a ClientError with details about the exception."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ros_bridge_client = ROSBridgeClient()\nros_bridge_client.connect()\n",
              "description": "\nThis will attempt to establish a connection to the rosbridge client at 'localhost:9090'. The function `connect` will run indefinitely until it succeeds in establishing a connection or until the maximum number of retries is reached."
            },
            "name": "connect",
            "location": {
              "start": 48,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 14,
            "docLength": null
          },
          {
            "id": "1d4906b7-b530-6ca8-b646-0af5fd346c0a",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205"
            ],
            "description": "Creates a generic message handler for a given topic and message type. The handler function calls all registered message handlers for that topic and message type, passing the received message to each handler.",
            "name": "__create_generic_message_handler",
            "location": {
              "start": 63,
              "insert": 64,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 63,
                "end": 76
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 13
          },
          {
            "id": "e4b9bce2-0b37-d2bc-424a-3b0142bc8e28",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205",
              "1d4906b7-b530-6ca8-b646-0af5fd346c0a"
            ],
            "description": "Maps a combination of a topic and message type to a list of handlers, and then invokes each handler in the list with the given message as its argument. This allows for flexible and dynamic handling of messages based on their topic and type.",
            "params": [
              {
                "name": "message",
                "type_name": "ROS_MESSAGE_TYPE",
                "description": "Expected to be an instance of a specific type, representing a message received from a topic of interest."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "handler_function(message1) \nhandler_function(message2)",
              "description": ""
            },
            "name": "handler_function",
            "location": {
              "start": 77,
              "insert": 78,
              "offset": " ",
              "indent": 12,
              "comment": null
            },
            "item_type": "function",
            "length": 5,
            "docLength": null
          },
          {
            "id": "7b016781-2b5a-7185-774b-1075f0ec3834",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205"
            ],
            "description": "Registers a message handler for a specified topic and message type, ensuring that no duplicate handlers are registered. If no existing handler exists, it creates a new subscriber to receive messages of that type from the topic.",
            "params": [
              {
                "name": "topic",
                "type_name": "str",
                "description": "Required to be passed while registering a message handler. It represents the topic for which the provided message handler will be registered on the ROS (Robot Operating System) system."
              },
              {
                "name": "message_type",
                "type_name": "str",
                "description": "Used to specify the message type that corresponds to the topic where messages are being published or subscribed."
              },
              {
                "name": "handler",
                "type_name": "ROS_MESSAGE_HANDLER_TYPE",
                "description": "Expected to be a callback function that will be called when a message of the specified topic and message type is received from the ROS node."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ros_bridge_client = ROSBridgeClient()\nros_bridge_client.connect()\n\nclass MyMessageHandler(ROS_MESSAGE_HANDLER_TYPE):\n    def __init__(self, topic: str) -> None:\n        self.topic = topic\n\n    def handle_ros_message(self, message: ROS_MESSAGE_TYPE) -> None:\n        print(f\"Received {message} on topic {self.topic}\")\n\nros_bridge_client.register_message_handler('chatter', 'std_msgs/msg/String', MyMessageHandler('chatter'))\n",
              "description": ""
            },
            "name": "register_message_handler",
            "location": {
              "start": 85,
              "insert": 87,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 86,
                "end": 96
              }
            },
            "item_type": "method",
            "length": 17,
            "docLength": 10
          },
          {
            "id": "dc0fa90f-778a-0782-3844-df502f51e007",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205"
            ],
            "description": "Removes a message handler for a specific topic and message type, verifying if any other handlers are registered after removal. If not, it also unsubscribes from the topic and deletes the key from internal dictionaries.",
            "params": [
              {
                "name": "topic",
                "type_name": "str",
                "description": "Required, indicating the name of a topic to remove the message handler for. It forms part of a key along with the `message_type` to uniquely identify the message handlers."
              },
              {
                "name": "message_type",
                "type_name": "str",
                "description": "Used to specify the type of ROS (Robot Operating System) message for which a handler needs to be removed. It is part of the key that uniquely identifies a handler in the handlers dictionary."
              },
              {
                "name": "handler",
                "type_name": "ROS_MESSAGE_HANDLER_TYPE",
                "description": "Used to remove a message handler from the list of handlers for a specific topic and message type."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "client = ROSBridgeClient()\nclient.connect()\n\nhandler1 = client.__create_generic_message_handler('topic1', 'message_type1')\nhandler2 = client.__create_generic_message_handler('topic2', 'message_type2')\n\nclient.register_message_handler('topic1', 'message_type1', handler1)\nclient.register_message_handler('topic2', 'message_type2', handler2)\n\n# Now, the handlers are registered and will be triggered when messages of type 'message_type1' on topic 'topic1' or 'message_type2' on topic 'topic2' are received.\n\nclient.remove_message_handler('topic1', 'message_type1', handler1)",
              "description": ""
            },
            "name": "remove_message_handler",
            "location": {
              "start": 113,
              "insert": 115,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 114,
                "end": 124
              }
            },
            "item_type": "method",
            "length": 13,
            "docLength": 10
          },
          {
            "id": "17cd2ad9-9600-7da9-2a49-b2cd3d8a7615",
            "ancestors": [
              "95fd1d6a-1267-5ab3-a348-22bda15d1205"
            ],
            "description": "Closes the connection to the ROS bridge, unsubscribes all subscribers, and resets internal state.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "ros_bridge_client = ROSBridgeClient()\nros_bridge_client.connect()\nros_bridge_client.register_message_handler(\"chatter\", \"std_msgs/msg/String\", lambda message: print(message))\nros_bridge_client.close()",
              "description": ""
            },
            "name": "close",
            "location": {
              "start": 137,
              "insert": 139,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 138,
                "end": 141
              }
            },
            "item_type": "method",
            "length": 9,
            "docLength": 3
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/files/__init__.py",
    "content": {
      "structured": {
        "description": "A class named \"LinkedList\" that implements a doubly linked list data structure using nodes with references to previous and next elements in the list. The list provides insertions at both ends as well as traversals through its elements. It utilizes the built-in \"random\" module for shuffling the list during initialization and the \"time\" module for tracking execution time of various operations.",
        "items": []
      }
    }
  },
  {
    "name": "decoder.py",
    "path": "rigel/files/decoder.py",
    "content": {
      "structured": {
        "description": "A YAML data decoder that recursively looks for template variables in YAML data and replaces them with corresponding values from user-defined variables or environment variables. The decoder uses regular expressions to match variable names enclosed between delimiters {{ and }}. It supports two types of headers: global variables and shared data, which are used to declare variables that can be accessed within the YAML data.",
        "items": [
          {
            "id": "074749a7-f5d0-969c-7b44-d1ca050e2ff6",
            "ancestors": [],
            "description": "Decodes YAML files containing template variables and replaces them with actual values from a dictionary or environment variables. It recursively traverses the data structure, replacing template variables in strings and updating variable names to match the header.",
            "attributes": [],
            "name": "YAMLDataDecoder",
            "location": {
              "start": 17,
              "insert": 18,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 17,
                "end": 26
              }
            },
            "item_type": "class",
            "length": 167,
            "docLength": 9
          },
          {
            "id": "01b6512c-366e-00bf-1745-478e5642e0fe",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Removes specific characters from a given string (`match`) to extract a variable name. The characters '{', '}' and ' ' are removed, returning the cleaned-up string as the extracted variable name.",
            "name": "__extract_variable_name",
            "location": {
              "start": 28,
              "insert": 29,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 28,
                "end": 38
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 10
          },
          {
            "id": "48114e35-53b2-228d-6a49-d1ae7445fa14",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Recursively decodes nested dictionaries and lists within a given data structure, using provided variables, header information, and an optional path for debugging purposes.",
            "name": "__aux_decode",
            "location": {
              "start": 45,
              "insert": 46,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 45,
                "end": 54
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 9
          },
          {
            "id": "3fb255d8-a995-45a6-004e-3f1868dc099d",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Recursively decodes a dictionary-like data structure from YAML data. It calls two private methods to decode values and keys, then processes them according to a given header and path.",
            "name": "__aux_decode_dict",
            "location": {
              "start": 60,
              "insert": 61,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 60,
                "end": 73
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 13
          },
          {
            "id": "cfbfd75f-5ef7-97ad-384e-14d55745e599",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Recursively processes dictionary values to replace template variables with actual values from the input data, environment variables, or shared data. It handles string values containing delimiters and nested values such as lists and dictionaries.",
            "name": "__aux_decode_dict_values",
            "location": {
              "start": 77,
              "insert": 78,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 77,
                "end": 89
              }
            },
            "item_type": "method",
            "length": 47,
            "docLength": 12
          },
          {
            "id": "da78af93-7b10-f58f-8442-f013173d625a",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Traverses the keys of a given data structure, replaces specific template variables with their corresponding values from predefined variables or environment variables, and updates the data structure accordingly.",
            "name": "__aux_decode_dict_keys",
            "location": {
              "start": 137,
              "insert": 138,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 137,
                "end": 149
              }
            },
            "item_type": "method",
            "length": 34,
            "docLength": 12
          },
          {
            "id": "dc63145d-123b-bab2-874c-c2992222b42f",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Recursively decodes a list of data elements by replacing template variables with actual values from variables or environment settings, based on the given header and path.",
            "name": "__aux_decode_list",
            "location": {
              "start": 184,
              "insert": 185,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 184,
                "end": 196
              }
            },
            "item_type": "method",
            "length": 47,
            "docLength": 12
          },
          {
            "id": "5d215954-bf2a-fcbb-6f4c-b96d73e0c6b0",
            "ancestors": [
              "074749a7-f5d0-969c-7b44-d1ca050e2ff6"
            ],
            "description": "Decodes YAML data using the provided `variables` and `header`, then returns the decoded data as a dictionary. The decoding process is performed by the internal `_aux_decode` method.",
            "params": [
              {
                "name": "data",
                "type_name": "Dict[str, Any]",
                "description": "Expected to contain key-value pairs where keys are strings and values can be any type."
              },
              {
                "name": "variables",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a collection of key-value pairs where keys are variable names and values are their corresponding values."
              },
              {
                "name": "header",
                "type_name": "str",
                "description": "Expected to be passed as an argument when calling this method. Its purpose is not explicitly stated, but it is likely related to decoding the data provided in the input dictionary."
              }
            ],
            "returns": {
              "type_name": "Dict[str, Any]",
              "description": "A dictionary where keys are strings and values can be any type. This returned dictionary is the input parameter `data` modified by the auxiliary method `__aux_decode`."
            },
            "usage": {
              "language": "python",
              "code": "decoder = YAMLDataDecoder()\ndata = {'name': 'John', 'age': 30}\nvariables = {'user.name': 'Jane'}\nheader = 'user'\nresult = decoder.decode(data, variables, header)\n",
              "description": ""
            },
            "name": "decode",
            "location": {
              "start": 244,
              "insert": 250,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 249,
                "end": 258
              }
            },
            "item_type": "method",
            "length": 8,
            "docLength": 9
          }
        ]
      }
    }
  },
  {
    "name": "loader.py",
    "path": "rigel/files/loader.py",
    "content": {
      "structured": {
        "description": "A class YAMLDataLoader to load and parse YAML files using the yaml package. The class takes a filepath as an argument in its constructor and provides a method to load the YAML file contents. It attempts to open the file, load its content with full_load function from yaml module, and returns it as a dictionary-like object. If the file does not exist or is empty, it raises corresponding exceptions.",
        "items": [
          {
            "id": "dd0bed0d-a332-4e8d-5944-b6ee7aa00234",
            "ancestors": [],
            "description": "Loads YAML data from a file and returns it as a Python object. It handles exceptions for missing files, invalid YAML syntax, and empty files.",
            "attributes": [
              {
                "name": "filepath",
                "type_name": "str",
                "description": "Initialized in the constructor method with a string parameter representing the path to the YAML file that needs to be loaded."
              }
            ],
            "name": "YAMLDataLoader",
            "location": {
              "start": 10,
              "insert": 11,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 10,
                "end": 13
              }
            },
            "item_type": "class",
            "length": 28,
            "docLength": 3
          },
          {
            "id": "c87cef15-4891-9888-9f46-0e9e4b835d53",
            "ancestors": [
              "dd0bed0d-a332-4e8d-5944-b6ee7aa00234"
            ],
            "description": "Attempts to load a YAML configuration file at a specified filepath. If successful, it returns the loaded data as a Python object. If an error occurs (e.g., file not found or corrupted), it raises a corresponding exception.",
            "params": [],
            "returns": {
              "type_name": "Any",
              "description": "An object containing data loaded from a YAML file at the specified filepath, or raises an exception if the file cannot be found, is empty, or contains invalid YAML formatting."
            },
            "usage": {
              "language": "python",
              "code": "loader = YAMLDataLoader('path/to/config.yaml')\nconfig_data = loader.load()\n",
              "description": ""
            },
            "name": "load",
            "location": {
              "start": 22,
              "insert": 23,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 22,
                "end": 28
              }
            },
            "item_type": "method",
            "length": 24,
            "docLength": 6
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/loggers/__init__.py",
    "content": {
      "structured": {
        "description": "A logger using the get_logger function from the logger module. The get_logger function is likely responsible for retrieving and configuring a logging object.",
        "items": []
      }
    }
  },
  {
    "name": "logger.py",
    "path": "rigel/loggers/logger.py",
    "content": {
      "structured": {
        "description": "A custom logger formatter and retriever. The formatter RigelFormatter is used to colorize log messages based on their severity levels. It utilizes ANSI escape sequences for colors and logging package for formatting. The get_logger function initializes and returns a message logger with a specified name, level, and handler.",
        "items": [
          {
            "id": "b2117667-c0d4-95aa-ec4e-3d196ebeca4c",
            "ancestors": [],
            "description": "Formats log messages based on their level (debug, info, warning, error, critical). It uses colorized strings to differentiate between levels and returns a formatted string for each message. The colors are defined by the `GREEN`, `BLUE`, `YELLOW`, and `RED` variables.",
            "attributes": [
              {
                "name": "formats",
                "type_name": "Dict[int,str]",
                "description": "Used to store the format string for each logging level. The keys are integer values representing the different logging levels and the values are strings representing the format strings for those levels."
              }
            ],
            "name": "RigelFormatter",
            "location": {
              "start": 12,
              "insert": 13,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 12,
                "end": 13
              }
            },
            "item_type": "class",
            "length": 13,
            "docLength": 1
          },
          {
            "id": "9e4ee6f9-59f8-2bbc-604f-621f863c61c2",
            "ancestors": [
              "b2117667-c0d4-95aa-ec4e-3d196ebeca4c"
            ],
            "description": "Formats a log record based on the format corresponding to its level, retrieved from a dictionary. It uses the provided log record and returns a formatted string.",
            "params": [
              {
                "name": "record",
                "type_name": "logging.LogRecord",
                "description": "Passed to this method. This object represents an event recorded by a logger instance. It contains information such as timestamp, log level, message, etc."
              }
            ],
            "returns": {
              "type_name": "str",
              "description": "The formatted string representation of a log record. It is generated by the specified format for the log level of the record using a logging.Formatter object."
            },
            "usage": {
              "language": "python",
              "code": "logger = logging.getLogger('my_logger')\nlogger.setLevel(logging.DEBUG)\nhandler = logging.StreamHandler()\nhandler.setFormatter(RigelFormatter())\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning message\")\nlogger.error(\"This is an error message\")\n",
              "description": ""
            },
            "name": "format",
            "location": {
              "start": 23,
              "insert": 24,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "5f304700-29f6-17b2-044d-fb895afcad7c",
            "ancestors": [],
            "description": "Returns a configured logger named \"Rigel\" with a debug level. If no handlers are attached, it adds a stream handler with a debug level and a custom formatter to the logger, enabling logging output to the console.",
            "params": [],
            "returns": {
              "type_name": "logging.Logger",
              "description": "A logger object named \"Rigel\" that has been configured to output debug level logs to the console using a custom formatter."
            },
            "usage": {
              "language": "python",
              "code": "logger = get_logger()\nlogger.debug('This message will be debugged')\n",
              "description": "\n\nNote: The RigelFormatter and logging module are assumed to be defined elsewhere in this code."
            },
            "name": "get_logger",
            "location": {
              "start": 29,
              "insert": 30,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 29,
                "end": 34
              }
            },
            "item_type": "function",
            "length": 11,
            "docLength": 5
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/models/core/__init__.py",
    "content": {
      "structured": {
        "description": "Imports from two modules, `registry` and `ssh`. The import from `registry` module references a class named `ContainerRegistry`. From the `ssh` module, it imports two classes: `SSHPrivateKey` and `SSHPrivateKeyFile`, which likely represent secure shell private keys and their file representation respectively.",
        "items": []
      }
    }
  },
  {
    "name": "registry.py",
    "path": "rigel/models/core/registry.py",
    "content": {
      "structured": {
        "description": "A class named ContainerRegistry that inherits from ComplexDataModel and uses the pydantic library with extra parameter set to forbid for preventing any extra parameters. The class has three attributes: server, password, and username. \n\nIt allows definition of a structured data model with strict validation rules for the provided input.",
        "items": [
          {
            "id": "4b455d10-6b70-cca5-6c49-3e55f9824666",
            "ancestors": [],
            "description": "Defines a complex data model for storing information about container servers. It inherits from `ComplexDataModel` and is configured to disallow additional attributes. The class has three instance variables: `server`, `password`, and `username`, which represent the server details.",
            "attributes": [
              {
                "name": "server",
                "type_name": "str",
                "description": "A component of the complex data model. It represents the server address or hostname where container registry services are hosted."
              },
              {
                "name": "password",
                "type_name": "str",
                "description": "Part of a class definition that inherits from `ComplexDataModel`. It appears to be a private attribute, as it does not have a corresponding setter method."
              },
              {
                "name": "username",
                "type_name": "str",
                "description": "Part of its definition as a subclass of `ComplexDataModel`. Its presence in the class definition suggests that it is expected to be present in instances of this class."
              }
            ],
            "name": "ContainerRegistry",
            "location": {
              "start": 5,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "ssh.py",
    "path": "rigel/models/core/ssh.py",
    "content": {
      "structured": {
        "description": "Two classes, SSHPrivateKeyFile and SSHPrivateKey, using pydantic's ComplexDataModel. The classes represent information about private SSH keys, specifically their hostnames and paths or values respectively.",
        "items": [
          {
            "id": "cfc57e14-ce37-30b3-1748-8c6dcb5c3db7",
            "ancestors": [],
            "description": "Defines a complex data model for representing SSH private key files. It has two attributes: `hostname` and `path`, which specify the hostname associated with the key file and its path, respectively. This class enforces strict schema validation by forbidding extra attributes.",
            "attributes": [
              {
                "name": "hostname",
                "type_name": "str",
                "description": "Part of the class's definition, allowing it to be used within the context of SSH private key files, likely representing a hostname associated with the key."
              },
              {
                "name": "path",
                "type_name": "str",
                "description": "Used to store a string value representing the file path where the SSH private key is located."
              }
            ],
            "name": "SSHPrivateKeyFile",
            "location": {
              "start": 5,
              "insert": 6,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 5,
                "end": 12
              }
            },
            "item_type": "class",
            "length": 3,
            "docLength": 7
          },
          {
            "id": "b4605b8c-a730-0496-4b4c-4f563f55c151",
            "ancestors": [],
            "description": "Represents an SSH private key data model, inheriting from `ComplexDataModel`. It has two attributes: `hostname` and `value`, both of type `str`, which likely represent the hostname and the private key value respectively.",
            "attributes": [
              {
                "name": "hostname",
                "type_name": "str",
                "description": "A part of the inherited `ComplexDataModel`."
              },
              {
                "name": "value",
                "type_name": "str",
                "description": "Part of the class definition. It represents the private key value itself, which is a string representation of the SSH private key data."
              }
            ],
            "name": "SSHPrivateKey",
            "location": {
              "start": 18,
              "insert": 20,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 19,
                "end": 26
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/models/__init__.py",
    "content": {
      "structured": {
        "description": "A class that utilizes Java's StringBuilder and ArrayList classes to implement a custom data structure, specifically a stack-based queue. It overrides the add and get methods from the Queue interface to provide a LIFO ordering. The code relies on Java's generics system for type safety.",
        "items": []
      }
    }
  },
  {
    "name": "application.py",
    "path": "rigel/models/application.py",
    "content": {
      "structured": {
        "description": "An application class using the Pydantic library's BaseModel and specifies constraints on its attributes through the Extra class. The class represents a ROS (Robot Operating System) application with two properties: distro, which is required, and dir, which is optional with a default value of '.'.",
        "items": [
          {
            "id": "a70a9ff8-bf58-64b2-ac4e-281a66d7b1a6",
            "ancestors": [],
            "description": "Defines a model that inherits from `BaseModel`. It has two properties: `distro`, which is required, and `dir`, which is optional with a default value of `'.'`. The `extra=Extra.forbid` parameter ensures that no additional attributes can be defined for the object.",
            "attributes": [
              {
                "name": "distro",
                "type_name": "str",
                "description": "Required, meaning it must be provided when instantiating an instance of the `Application` class."
              },
              {
                "name": "dir",
                "type_name": "str",
                "description": "Optional, meaning it can be omitted when creating an instance of the class. Its default value is '.'."
              }
            ],
            "name": "Application",
            "location": {
              "start": 8,
              "insert": 9,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 8,
                "end": 20
              }
            },
            "item_type": "class",
            "length": 6,
            "docLength": 12
          }
        ]
      }
    }
  },
  {
    "name": "builder.py",
    "path": "rigel/models/builder.py",
    "content": {
      "structured": {
        "description": "A ModelBuilder class that helps instantiate model classes by handling exceptions that may occur during instance creation. It uses pydantic and rigel packages to manage validation errors. The build method takes in arguments and keyword arguments for the model class, attempts to create an instance, and catches any raised ValidationErrors before re-raising them as PydanticValidationErrors.",
        "items": [
          {
            "id": "03bb1419-7c0b-37b6-b241-a0ed256630f2",
            "ancestors": [],
            "description": "Initializes an instance type and uses it to create a new instance based on provided arguments and keyword arguments. It also catches any `ValidationError` exceptions and re-raises them as `PydanticValidationError`.",
            "attributes": [
              {
                "name": "instance_type",
                "type_name": "Type",
                "description": "Initialized with a specific instance type during object creation."
              }
            ],
            "name": "ModelBuilder",
            "location": {
              "start": 6,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 6,
                "end": 11
              }
            },
            "item_type": "class",
            "length": 11,
            "docLength": 5
          },
          {
            "id": "c617ad9b-9737-19bd-3645-7135cc13af43",
            "ancestors": [
              "03bb1419-7c0b-37b6-b241-a0ed256630f2"
            ],
            "description": "Attempts to create an instance of `self.instance_type` using provided arguments and keyword arguments. If successful, it returns the created instance. In case of a ValidationError, it wraps the exception with PydanticValidationError and re-raises it.",
            "params": [
              {
                "name": "args",
                "type_name": "List[Any]",
                "description": "Expected to be a list of arguments that will be passed to the `instance_type` method."
              },
              {
                "name": "kwargs",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be a dictionary where keys are strings (parameter names) and values are arbitrary types. It represents keyword arguments passed to the instance_type function."
              }
            ],
            "returns": {
              "type_name": "Any",
              "description": "The result of calling `self.instance_type` with `*args` and `**kwargs`. If an exception occurs during this call, it catches the ValidationError and raises a PydanticValidationError instead."
            },
            "usage": {
              "language": "python",
              "code": "my_model = ModelBuilder(Model)\nresult = my_model.build([1, 2], {'name': 'John'})\n",
              "description": ""
            },
            "name": "build",
            "location": {
              "start": 23,
              "insert": 24,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 23,
                "end": 34
              }
            },
            "item_type": "method",
            "length": 6,
            "docLength": 11
          }
        ]
      }
    }
  },
  {
    "name": "data.py",
    "path": "rigel/models/data.py",
    "content": {
      "structured": {
        "description": "Two classes: SimpleDataModel and ComplexDataModel. The SimpleDataModel is a union type that can hold values of boolean, float, integer, or string types. The ComplexDataModel inherits from pydantic's BaseModel class with extra set to forbid any additional attributes not explicitly defined in the model.",
        "items": [
          {
            "id": "10407a2d-0b14-e9a9-a24e-575780c0ed98",
            "ancestors": [],
            "description": "Defines a data model that inherits from `BaseModel`. It has two attributes: `type` (a string) and `with_` (a dictionary with any value type, aliased as 'with'). The `extra=Extra.forbid` parameter indicates that additional fields are not allowed.",
            "attributes": [
              {
                "name": "type",
                "type_name": "str",
                "description": "Defined as part of the model's schema. It represents a string value that characterizes the type of data being modeled."
              },
              {
                "name": "with_",
                "type_name": "Dict[str, Any]",
                "description": "Aliased as 'with'. The `Field` constructor is used to define this attribute with a default value of ... which implies that it is required."
              }
            ],
            "name": "ComplexDataModel",
            "location": {
              "start": 7,
              "insert": 9,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 4,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/models/plugin.py",
    "content": {
      "structured": {
        "description": "A data model using Pydantic's BaseModel, which enforces strict type hints and validates input data against its schema. The model is named PluginDataModel and has two attributes: plugin and with_. The with_ attribute is a dictionary that maps string keys to arbitrary values, aliased as 'with' for compatibility reasons.",
        "items": [
          {
            "id": "84b376b7-7a5f-b8aa-b346-a83b80fcccfc",
            "ancestors": [],
            "description": "Defines a data model for storing plugin-related information. It inherits from `BaseModel` and forbids extra attributes. The model consists of two properties: `plugin`, which is a string, and `with_`, an alias for `PluginRawData` field.",
            "attributes": [
              {
                "name": "plugin",
                "type_name": "str",
                "description": "A required field, meaning it cannot be omitted when creating an instance of this model."
              },
              {
                "name": "with_",
                "type_name": "PluginRawData",
                "description": "Aliased as 'with'. It is not directly assigned a value, instead it uses the `Field(..., alias='with')` syntax to create a field."
              }
            ],
            "name": "PluginDataModel",
            "location": {
              "start": 7,
              "insert": 9,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 4,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "provider.py",
    "path": "rigel/models/provider.py",
    "content": {
      "structured": {
        "description": "A Pydantic model named ProviderDataModel that represents structured data about providers. It uses the `BaseModel` and `Extra.forbid` from the `pydantic` library to create a model with strict typing and validation rules. The model has two attributes: `provider`, which is a string, and `with_`, which is a dictionary of any type (`Any`).",
        "items": [
          {
            "id": "8ac69d46-60e7-a2a5-894c-07f0bfd565f5",
            "ancestors": [],
            "description": "Validates and defines a data model for storing provider information. It inherits from `BaseModel`, which provides validation capabilities. The class has two attributes: `provider`, a string field, and `with_`, an alias of `ProviderRawData` that is not allowed to have extra values.",
            "attributes": [
              {
                "name": "provider",
                "type_name": "str",
                "description": "A required field, meaning that it must be provided when creating or updating instances of this model."
              },
              {
                "name": "with_",
                "type_name": "ProviderRawData",
                "description": "Aliased as 'with'. The ellipsis (...) in its definition indicates that it is a required field, but no value is provided."
              }
            ],
            "name": "ProviderDataModel",
            "location": {
              "start": 7,
              "insert": 9,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 4,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "rigelfile.py",
    "path": "rigel/models/rigelfile.py",
    "content": {
      "structured": {
        "description": "A class `Rigelfile` using Pydantic's BaseModel. It represents information about ROS (Robot Operating System) applications and contains various types of data such as jobs, sequences, providers, and global variables. The class enforces strict typing using Python type hints and Pydantic's extra=Extra.forbid configuration, which ensures that only specified fields are allowed in the model.",
        "items": [
          {
            "id": "083e1099-c8c6-c985-5d42-6576e6f855fd",
            "ancestors": [],
            "description": "Defines a data model for Rigel configuration files. It has required fields for application and jobs, as well as optional fields for providers, sequences, and global variables. This class ensures that only necessary data is stored in the Rigel configuration file.",
            "attributes": [
              {
                "name": "application",
                "type_name": "Application",
                "description": "Required."
              },
              {
                "name": "jobs",
                "type_name": "Dict[str, PluginDataModel]",
                "description": "Required. It represents a dictionary where each key is a string and the corresponding value is of type PluginDataModel."
              },
              {
                "name": "providers",
                "type_name": "Dict[str, ProviderDataModel]",
                "description": "Optional by default with a default value of an empty dictionary `{}`."
              },
              {
                "name": "sequences",
                "type_name": "Dict[str, Sequence]",
                "description": "Optional. It contains a dictionary where keys are strings and values are instances of the `Sequence` model."
              },
              {
                "name": "vars",
                "type_name": "RigelfileGlobalData",
                "description": "Initialized with an empty dictionary `{}` by default."
              }
            ],
            "name": "Rigelfile",
            "location": {
              "start": 12,
              "insert": 13,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 12,
                "end": 25
              }
            },
            "item_type": "class",
            "length": 9,
            "docLength": 13
          }
        ]
      }
    }
  },
  {
    "name": "sequence.py",
    "path": "rigel/models/sequence.py",
    "content": {
      "structured": {
        "description": "A set of classes using the Pydantic library for constructing and validating structured data. The classes represent various types of job stages in a sequence processing workflow, including sequential, concurrent, and parallel stages, as well as a root Sequence class that contains a list of these stages.",
        "items": [
          {
            "id": "16213a81-5f6d-1fb7-a24d-c32f2f5c039d",
            "ancestors": [],
            "description": "Validates and serializes data for a sequence job entry. It inherits from `BaseModel`, enforcing strict schema validation with `extra=Extra.forbid`. The class has two attributes: `name` (a string) and `with_` (a dictionary alias for the `with` field, initialized to an empty dictionary).",
            "attributes": [
              {
                "name": "name",
                "type_name": "str",
                "description": "A required field."
              },
              {
                "name": "with_",
                "type_name": "Dict[str, Any]",
                "description": "Aliased as 'with'. It represents a dictionary where keys are strings and values can be any type. The name with underscores at the beginning indicates that it might have been used to avoid conflict with Python's built-in keyword `with`."
              }
            ],
            "name": "SequenceJobEntry",
            "location": {
              "start": 5,
              "insert": 8,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 4,
            "docLength": null
          },
          {
            "id": "48e4f6ad-6e9e-af80-bb43-96ee213c67c9",
            "ancestors": [],
            "description": "Inherits from `BaseModel` and defines a `description` attribute as a string with a default value of an empty string. The `extra=Extra.forbid` parameter prevents additional attributes from being created for the model instance.",
            "attributes": [
              {
                "name": "description",
                "type_name": "str",
                "description": "Initialized to an empty string. It inherits from BaseModel, a base model class that provides basic functionality for data models."
              }
            ],
            "name": "StageBaseModel",
            "location": {
              "start": 12,
              "insert": 15,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 3,
            "docLength": null
          },
          {
            "id": "48ef68f0-da21-3a93-204e-2d1ddebb3ecd",
            "ancestors": [],
            "description": "Is a model that inherits from `StageBaseModel`. It has a property `jobs`, which is a list that can contain either a string or an instance of `SequenceJobEntry`. This indicates that the stage can process either single-job or multi-job sequences.",
            "attributes": [
              {
                "name": "jobs",
                "type_name": "List[Union[str, SequenceJobEntry]]",
                "description": "Defined by the parent class `StageBaseModel`. It can contain a list of string values or objects of type `SequenceJobEntry`."
              }
            ],
            "name": "SequentialStage",
            "location": {
              "start": 18,
              "insert": 21,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 3,
            "docLength": null
          },
          {
            "id": "4cfadf54-3223-02ac-dc47-5829246bad38",
            "ancestors": [],
            "description": "Defines a stage that can execute multiple jobs concurrently, inheriting properties from its base model. It contains two attributes: `jobs`, which holds a list of job entries (strings or instances of `SequenceJobEntry`), and `dependencies`, which stores a list of dependencies for those jobs.",
            "attributes": [
              {
                "name": "jobs",
                "type_name": "List[Union[str, SequenceJobEntry]]",
                "description": "Used to represent a list of jobs that can be either strings or instances of SequenceJobEntry."
              },
              {
                "name": "dependencies",
                "type_name": "List[Union[str, SequenceJobEntry]]",
                "description": "Used to store a list of either string (job names) or SequenceJobEntry objects that represent jobs which must be completed before this job can start."
              }
            ],
            "name": "ConcurrentStage",
            "location": {
              "start": 24,
              "insert": 27,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 4,
            "docLength": null
          },
          {
            "id": "decad0f8-34b2-9fa5-d24d-3e3c56745786",
            "ancestors": [],
            "description": "Inherits from `StageBaseModel`. It contains a list of parallel stages (`parallel`) and a dictionary for storing matrices with string keys and values that can be strings or lists of any type (`matrix`).",
            "attributes": [
              {
                "name": "parallel",
                "type_name": "List[Union[SequentialStage, ConcurrentStage]]",
                "description": "Not nullable."
              },
              {
                "name": "matrix",
                "type_name": "Dict[str, Union[str, List[Any]]]",
                "description": "Initialized as an empty dictionary. It allows for key-value pairs where keys are strings, and values can be either strings or lists of any type (Any)."
              }
            ],
            "name": "ParallelStage",
            "location": {
              "start": 31,
              "insert": 34,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 5,
            "docLength": null
          },
          {
            "id": "59579fef-4e7c-488e-904b-810855f64571",
            "ancestors": [],
            "description": "Defines a model with two attributes: `stages`, which is a list of `SequenceStage` objects, and `matrix`, which is a dictionary that can contain any type of value. The `extra=Extra.forbid` parameter restricts additional fields from being added to the model.",
            "attributes": [
              {
                "name": "stages",
                "type_name": "List[SequenceStage]",
                "description": "Mandatory to be defined."
              },
              {
                "name": "matrix",
                "type_name": "Dict[str, Any]",
                "description": "Initialized as an empty dictionary (`{}`). This suggests that it will store key-value pairs with string keys and values of any data type."
              }
            ],
            "name": "Sequence",
            "location": {
              "start": 43,
              "insert": 46,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/aws/robomaker/__init__.py",
    "content": {
      "structured": {
        "description": "A class that represents a graph. It uses the NetworkX library to create and manipulate nodes and edges in the graph. The code also includes a method to calculate the shortest path between two nodes using Dijkstra's algorithm, as well as another method to find the connected components of the graph using Depth-First Search (DFS).",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/plugins/aws/robomaker/models.py",
    "content": {
      "structured": {
        "description": "Several classes that model different components of an AWS RoboMaker application using Pydantic, a Python library for building robust APIs. The classes include configuration models for VPC, tools, robot applications, simulation applications, data sources, and compute resources. These configurations are used to define the setup for a RoboMaker simulation or job.",
        "items": [
          {
            "id": "c560dfd0-a35e-bc86-fe4f-f308533ef9da",
            "ancestors": [],
            "description": "Defines a model for configuring a Virtual Private Cloud (VPC). It consists of lists of subnets and security groups, as well as a boolean option to assign a public IP address. The class is designed to restrict extra properties from being set.",
            "attributes": [
              {
                "name": "subnets",
                "type_name": "List[str]",
                "description": "Required (not explicitely stated, but implied due to inheritance from `BaseModel`). It represents a list of subnet IDs or names that can be used for resources within the VPC."
              },
              {
                "name": "securityGroups",
                "type_name": "List[str]",
                "description": "Alias for the attribute `security_groups`."
              },
              {
                "name": "assignPublicIp",
                "type_name": "bool",
                "description": "Initially set to False by default. It can be optionally assigned a value of True during object creation, indicating whether public IP should be assigned."
              }
            ],
            "name": "VPCConfig",
            "location": {
              "start": 9,
              "insert": 12,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 6,
            "docLength": null
          },
          {
            "id": "1faae048-7ec1-a78e-2a4a-3507903a3826",
            "ancestors": [],
            "description": "Validates and configures a tool's settings, enforcing required fields for name and command, while allowing optional fields with default values. It checks the 'exitBehavior' field against predefined values ('FAIL', 'RESTART') to ensure validity.",
            "attributes": [
              {
                "name": "name",
                "type_name": "str",
                "description": "A required field, meaning it must be provided when creating an instance of the `Tool` class. It represents a string value that corresponds to the name of the tool."
              },
              {
                "name": "command",
                "type_name": "str",
                "description": "Required by default. It does not have any specific alias or default value, implying that it must be provided when creating a new instance of the `Tool` class."
              },
              {
                "name": "exitBehavior",
                "type_name": "str",
                "description": "Optional by default. It can take two values, 'FAIL' or 'RESTART', and defaults to 'RESTART'. Validation ensures that any provided value matches one of these allowed options."
              },
              {
                "name": "streamOutputToCloudWatch",
                "type_name": "bool",
                "description": "Optional by default. Its default value is False, and it can be overridden during object creation. It allows streaming output to Cloud Watch."
              },
              {
                "name": "streamUI",
                "type_name": "bool",
                "description": "Optional by default, meaning it can be omitted when creating a new instance of `Tool`. It represents whether to stream the UI output or not."
              }
            ],
            "name": "Tool",
            "location": {
              "start": 19,
              "insert": 21,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 20,
                "end": 38
              }
            },
            "item_type": "class",
            "length": 23,
            "docLength": 18
          },
          {
            "id": "ad4d8559-24d6-f19e-4c4d-6df6320fd0ed",
            "ancestors": [
              "1faae048-7ec1-a78e-2a4a-3507903a3826"
            ],
            "description": "Configures serialization options for a Python application, specifically for JSON-based APIs. It sets two properties: `allow_population_by_field_name` to allow population by field name and `extra` to forbid extra fields in the output.",
            "attributes": [
              {
                "name": "allow_population_by_field_name",
                "type_name": "bool",
                "description": "Set to `True`. It allows fields to be populated by using a field name that matches the variable name in the Python code, rather than requiring exact matching."
              },
              {
                "name": "extra",
                "type_name": "Extra",
                "description": "Set to `forbid`, which means that any additional fields in the request data will be rejected, rather than being ignored or accepted as default values."
              }
            ],
            "name": "Config",
            "location": {
              "start": 40,
              "insert": 41,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "class",
            "length": 3,
            "docLength": null
          },
          {
            "id": "6ea71da1-c515-3c8e-5343-a815eae8eca7",
            "ancestors": [
              "1faae048-7ec1-a78e-2a4a-3507903a3826"
            ],
            "description": "Validates an input string representing an exit behavior, ensuring it matches either 'FAIL' or 'RESTART'. If not valid, it raises an InvalidValueError; otherwise, returns the validated value.",
            "params": [
              {
                "name": "exitBehavior",
                "type_name": "str",
                "description": "Validated to ensure it has one of two specific values, 'FAIL' or 'RESTART'. If not, an error is raised."
              }
            ],
            "returns": {
              "type_name": "str",
              "description": "Either 'FAIL' or 'RESTART' if the input meets the condition, and raises an error otherwise."
            },
            "usage": {
              "language": "python",
              "code": "tool = Tool(name='MyTool', command='my_command', exitBehavior='RESTART')\n",
              "description": "\nThis code creates a new instance of the class Tool with a name, command and a default value for 'exitBehavior' which is 'RESTART'."
            },
            "name": "validate_exit_behavior",
            "location": {
              "start": 53,
              "insert": 55,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 54,
                "end": 57
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 3
          },
          {
            "id": "84b542ab-6e0f-68a7-d64c-bdfdc5704bc8",
            "ancestors": [],
            "description": "Defines a model for robot applications. It contains attributes for ECR, command, name, environment, ports, streamUI, and tools. The `BaseModel` is inherited from Pydantic's BaseModel to enable validation of the input data. Extra parameters are forbidden in this model.",
            "attributes": [
              {
                "name": "ecr",
                "type_name": "str",
                "description": "A required field for this model, as indicated by its presence in the class definition."
              },
              {
                "name": "command",
                "type_name": "List[str]",
                "description": "A collection of strings representing commands."
              },
              {
                "name": "name",
                "type_name": "str",
                "description": "Set to `DEFAULT_ROBOT_APPLICATION_NAME` by default. It represents a unique name for the robot application."
              },
              {
                "name": "environment",
                "type_name": "List[str]",
                "description": "Initialized with an empty list by default. It allows for a variable number of strings to be added, representing the environment settings or conditions for the robot application."
              },
              {
                "name": "ports",
                "type_name": "List[Tuple[int, int]]",
                "description": "Optional by default. It represents a list of tuples where each tuple contains two integers representing start and end port numbers for a specific communication protocol."
              },
              {
                "name": "streamUI",
                "type_name": "bool",
                "description": "Alias of 'stream_ui'. It has a default value of False, indicating that by default, the stream UI is not enabled for this robot application."
              },
              {
                "name": "tools",
                "type_name": "List[Tool]",
                "description": "Not initialized with any value by default. It means this attribute requires a non-empty list of `Tool` objects when creating an instance of `RobotApplication`."
              }
            ],
            "name": "RobotApplication",
            "location": {
              "start": 63,
              "insert": 66,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 10,
            "docLength": null
          },
          {
            "id": "dbf0f0b4-ce6c-6a81-0145-90cd94aa54b7",
            "ancestors": [],
            "description": "Defines a simulation application that inherits from `RobotApplication`. It contains properties for the name and world configurations, which is a list of dictionaries representing different worlds. The `world_configs` field is an alias for the list with a default value of an empty list.",
            "attributes": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Set to a default value specified by `DEFAULT_SIMULATION_APPLICATION_NAME`. This name is used to identify the application."
              },
              {
                "name": "worldConfigs",
                "type_name": "List[Dict[Literal[\"world\"], str]]",
                "description": "Alias'd as 'world_configs'. It has a default value of an empty list."
              }
            ],
            "name": "SimulationApplication",
            "location": {
              "start": 77,
              "insert": 80,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 4,
            "docLength": null
          },
          {
            "id": "8f90c8f2-b031-1d83-a54c-81ea51e18e81",
            "ancestors": [],
            "description": "Defines a data source model with required fields for destination, name, and S3 bucket/keys. It also specifies a default type as \"File\" and validates it to be one of three allowed types: \"Prefix\", \"Archive\", or \"File\".",
            "attributes": [
              {
                "name": "destination",
                "type_name": "str",
                "description": "Required."
              },
              {
                "name": "name",
                "type_name": "str",
                "description": "Required, as specified by its presence without a default value assigned to it."
              },
              {
                "name": "s3Bucket",
                "type_name": "str",
                "description": "Initialized with a default value. It has an alias 's3_bucket', indicating that it can also be referred to as 's3_bucket' when accessing or validating the attribute."
              },
              {
                "name": "s3Keys",
                "type_name": "List[str]",
                "description": "Aliased as \"s3_keys\". It represents a list of S3 keys associated with the data source, which is optional since it's not marked as required."
              },
              {
                "name": "type",
                "type_name": "str",
                "description": "Initialized with a default value of 'File'. It can be changed, but it must be one of ['Prefix', 'Archive', 'File']."
              }
            ],
            "name": "DataSource",
            "location": {
              "start": 92,
              "insert": 93,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 92,
                "end": 95
              }
            },
            "item_type": "class",
            "length": 16,
            "docLength": 3
          },
          {
            "id": "07495304-29f1-ba83-0f47-63bca094addf",
            "ancestors": [
              "8f90c8f2-b031-1d83-a54c-81ea51e18e81"
            ],
            "description": "Validates the 'type' field of the data source. If the type is not one of 'Prefix', 'Archive', or 'File', it raises an InvalidValueError; otherwise, it returns the validated type.",
            "params": [
              {
                "name": "ds_type",
                "type_name": "str",
                "description": "Specified as a type hint. It represents the data source type, which should be one of 'Prefix', 'Archive', or 'File'."
              }
            ],
            "returns": {
              "type_name": "str",
              "description": "Either the validated `ds_type` or None, if the validation fails and an exception is raised."
            },
            "usage": {
              "language": "python",
              "code": "ds = DataSource(type='Prefix')\nds2 = DataSource(type='InvalidValue')  # This will raise a ValueError\n",
              "description": "\n\nIn this example, ds is a valid instance of DataSource with type 'Prefix', whereas ds2 will result in an InvalidValueError because the value for 'type' is not one of the allowed values."
            },
            "name": "validate_data_source_type",
            "location": {
              "start": 106,
              "insert": 108,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 107,
                "end": 110
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 3
          },
          {
            "id": "2a21af41-a47d-9488-3640-7f8f158e5086",
            "ancestors": [],
            "description": "Defines a schema for computing resources, inheriting from `BaseModel`. It has three fields: `computeType`, specifying CPU or GPU/CPU combination; `gpuUnitLimit` and `simulationUnitLimit`, both integers representing respective limits. The `extra=Extra.forbid` parameter disallows additional properties beyond these defined fields.",
            "attributes": [
              {
                "name": "computeType",
                "type_name": "Union[Literal['CPU'], Literal['GPU_AND_CPU']]",
                "description": "Aliased as 'compute_type'. It can take two values: 'CPU' or 'GPU_AND_CPU', indicating whether the computation is done on CPU only or both GPU and CPU."
              },
              {
                "name": "gpuUnitLimit",
                "type_name": "int",
                "description": "Alias for the field with the same name. It represents the limit on GPU units."
              },
              {
                "name": "simulationUnitLimit",
                "type_name": "int",
                "description": "Aliased as 'simulation_unit_limit'."
              }
            ],
            "name": "Compute",
            "location": {
              "start": 119,
              "insert": 120,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 119,
                "end": 121
              }
            },
            "item_type": "class",
            "length": 4,
            "docLength": 2
          },
          {
            "id": "83061890-b350-f7a6-ca40-2a05fe4dd125",
            "ancestors": [],
            "description": "Defines a schema for a plugin configuration model, which includes properties such as IAM role, robot application, simulation duration, and VPC configuration. It also allows optional fields like output location, worldforge exported job, simulation application, and compute settings.",
            "attributes": [
              {
                "name": "iam_role",
                "type_name": "str",
                "description": "Required, as indicated by its presence in the class definition without any specified default value or `Optional` indicator."
              },
              {
                "name": "robot_application",
                "type_name": "Optional[RobotApplication]",
                "description": "Optional, meaning it can be assigned a value or left as None."
              },
              {
                "name": "simulation_application",
                "type_name": "Optional[SimulationApplication]",
                "description": "Optional, meaning it can be set to None or any value of type SimulationApplication."
              },
              {
                "name": "worldforge_exported_job",
                "type_name": "Optional[Dict[str, Any]]",
                "description": "Optional. It can hold a dictionary with any key-value pairs representing an exported job from WorldForge."
              },
              {
                "name": "output_location",
                "type_name": "Optional[str]",
                "description": "Optional, meaning it can be either present with a value or absent. It represents a possible output location for simulation results."
              },
              {
                "name": "simulation_duration",
                "type_name": "int",
                "description": "300 by default, indicating the duration of a simulation in seconds."
              },
              {
                "name": "vpc_config",
                "type_name": "Optional[VPCConfig]",
                "description": "Optional, meaning it can be missing or None."
              },
              {
                "name": "compute",
                "type_name": "Optional[Compute]",
                "description": "Optional, meaning it can be either set or not set. When set, its value is an instance of the Compute class."
              },
              {
                "name": "data_sources",
                "type_name": "List[DataSource]",
                "description": "Initialized with an empty list. It allows multiple data sources to be defined, each being a `DataSource` object."
              }
            ],
            "name": "PluginModel",
            "location": {
              "start": 128,
              "insert": 131,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 11,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/aws/robomaker/plugin.py",
    "content": {
      "structured": {
        "description": "A plugin for Rigel, an automation tool, that interacts with AWS RoboMaker and creates robot and simulation applications, starts simulations, waits for their completion, and cancels or deletes them when needed. The plugin uses boto3 library to interact with AWS services and performs various actions such as creating and deleting robot and simulation applications, starting and cancelling simulations, and retrieving public IP addresses and ports of running simulations.",
        "items": [
          {
            "id": "308f72a1-2ba7-a481-1c43-02d1e1d76333",
            "ancestors": [],
            "description": "Handles RoboMaker simulation job creation, management and interaction. It sets up a robot and simulation application if necessary, creates a simulation job, waits for its status to reach 'Running', and then stops it after the specified duration.",
            "attributes": [
              {
                "name": "model",
                "type_name": "PluginModel",
                "description": "Created through ModelBuilder by calling `build([], self.raw_data)`. It represents a plugin model that contains details about robot applications, simulation applications, IAM roles, output locations, vpc configurations, and other related settings."
              },
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed to the plugin during initialization. Its contents are not explicitly defined but are expected to contain the raw data required for the plugin's operation."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 17,
              "insert": 19,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 273,
            "docLength": null
          },
          {
            "id": "a860faf7-fc62-8ba0-f74c-45ad5d648776",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Initializes an instance of the plugin by calling its superclass's constructor and then building a model for the plugin based on raw data. It asserts that the built model is an instance of the PluginModel class.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed to the superclass's initializer as well as used when building the model instance via ModelBuilder."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Passed to the class constructor. Its presence indicates that it is an input required for the initialization process."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Passed to the parent class's constructor along with other parameters."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional (with default value `{}`). It appears to hold data related to providers, possibly being used in the construction of the PluginModel."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional by default. It provides additional data that can be shared among different parts of the system. If not provided, it defaults to an empty dictionary."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={\"provider\": AWSProviderOutputModel()},\n    shared_data={}\n)\n",
              "description": "\nThis example initializes a `Plugin` object with the required parameters."
            },
            "name": "__init__",
            "location": {
              "start": 19,
              "insert": 27,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 17,
            "docLength": null
          },
          {
            "id": "b44f1b9b-0432-82a9-3c46-240cc509833e",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Retrieves and returns an AWS RoboMaker client based on a list of available AWS providers, ensuring only one provider is used and it is properly configured for RoboMaker operations.",
            "params": [],
            "returns": {
              "type_name": "boto3.session.Session.client",
              "description": "A client object that can be used for interacting with Amazon RoboMaker service through Boto3, an SDK for AWS."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), providers_data)\nclient = plugin.retrieve_robomaker_client()\n",
              "description": "\n\nThis code snippet creates a new instance of the `Plugin` class and then calls the `retrieve_robomaker_client` method to retrieve an AWS RoboMaker client."
            },
            "name": "retrieve_robomaker_client",
            "location": {
              "start": 39,
              "insert": 41,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 13,
            "docLength": null
          },
          {
            "id": "3329d8d6-5fb1-3392-b34e-591dba86f687",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Creates a new robot application using information from the model and logs the creation process. The method takes no arguments besides the self parameter, indicating it is part of a class.",
            "params": [],
            "returns": {
              "type_name": "Dict[str, Any]",
              "description": "A new robot application object after it has been successfully created using the provided parameters."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'provider': AWSProviderOutputModel()},\n    shared_data={}\n)\nrobot_application = plugin.create_robot_application()\n",
              "description": ""
            },
            "name": "create_robot_application",
            "location": {
              "start": 53,
              "insert": 54,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 13,
            "docLength": null
          },
          {
            "id": "18866491-e653-ac8a-a141-6dab1be9ba7a",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Deletes a robot application specified by its Amazon Resource Name (ARN) using the RoboMaker client. The deletion is confirmed with an informational log message if successful.",
            "params": [
              {
                "name": "arn",
                "type_name": "str",
                "description": "Required. It represents the Amazon Resource Name (ARN) for the robot application to be deleted."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...)  # Initialize the plugin object with necessary data\nrobot_arn = \"arn:aws:robomaker:region:account-id:robot-application/robot-application-name\"\nplugin.delete_robot_application(robot_arn)",
              "description": ""
            },
            "name": "delete_robot_application",
            "location": {
              "start": 67,
              "insert": 71,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "900b6e2a-c270-1f90-bd45-eac69c030b20",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Creates a new simulation application using the RoboMaker client, with parameters such as name, robot software suite, simulation software suite, and environment URI. It then logs an information message upon successful creation.",
            "params": [],
            "returns": {
              "type_name": "Dict[str, Any]",
              "description": "An instance of a simulation application created by the AWS RoboMaker client using the provided parameters. The returned object is logged as a successful creation and then passed back to the caller."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nsimulation_app = plugin.create_simulation_application()\n",
              "description": ""
            },
            "name": "create_simulation_application",
            "location": {
              "start": 75,
              "insert": 76,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "fbdbef03-8e89-7a90-5447-ec46bc94a851",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Deletes a simulation application identified by its Amazon Resource Name (ARN). It uses the Robomaker client to send a DELETE request and logs a success message when the operation is complete.",
            "params": [
              {
                "name": "arn",
                "type_name": "str",
                "description": "Required, representing an Amazon Resource Name (ARN) that uniquely identifies the simulation application to be deleted."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData, Application())\narn = \"arn:aws:robomaker:region-id:account-id:simulation-application/sim-app-name\"\nplugin.delete_simulation_application(arn)",
              "description": ""
            },
            "name": "delete_simulation_application",
            "location": {
              "start": 92,
              "insert": 96,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "3cc3c9a3-e5a5-1499-5047-a9bf9bb89168",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Takes a list of environment variable strings and returns a dictionary where each key-value pair is extracted from the input string using the '=' character as separator, with leading/trailing whitespaces removed.",
            "params": [
              {
                "name": "envs",
                "type_name": "List[str]",
                "description": "Expected to contain strings representing environment variables, where each string is in the format 'key=value'."
              }
            ],
            "returns": {
              "type_name": "Dict[str, str]",
              "description": "A dictionary mapping environment variable names to their corresponding values. The input list of strings representing environment variables in 'key=value' format is converted into this dictionary."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nenv_vars = ['FOO=bar', 'BAZ=qux']\nconverted_envs = plugin.convert_envs(env_vars)\n",
              "description": ""
            },
            "name": "convert_envs",
            "location": {
              "start": 100,
              "insert": 101,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "6f1ae363-715b-1fa0-7540-8c106129e384",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Creates a RoboMaker simulation job based on the provided configuration data from the model and other dependent objects, and returns the created job. It also logs the creation event if successful.",
            "params": [],
            "returns": {
              "type_name": "Dict[str, Any]",
              "description": "A dictionary representing the created simulation job. This includes information such as IAM role, output location, maximum job duration, VPC configuration, robot and simulation applications, compute configuration, data sources, and worldforge exported jobs."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nrobomaker_client = plugin.retrieve_robomaker_client()\nrobot_application = plugin.create_robot_application()\nsimulation_application = plugin.create_simulation_application()\n\nkwargs = {\n    'iamRole': robot_application['arn'],\n    'outputLocation': {'s3Bucket': simulation_application['name']},\n    'maxJobDurationInSeconds': 3600,\n    'vpcConfig': {\n        'subnets': ['subnet-12345678'],\n        'securityGroups': ['sg-12345678'],\n        'assignPublicIp': True\n    }\n}\n\nif plugin.model.robot_application is not None:\n    kwargs['robotApplications'] = [\n        {\n            'application': robot_application['arn'],\n            'launchConfig': {\n                'streamUI': False,\n                'command': 'cd /app && python main.py',\n                'environmentVariables': {'KEY': 'value'},\n                'portForwardingConfig': {\n                    'portMappings': [\n                        {'jobPort': 8080, 'applicationPort': 8081, 'enableOnPublicIp': True}\n                    ]\n                }\n            },\n            'tools': []\n        }\n    ]\n\nsimulation_job = plugin.create_simulation_job(**kwargs)",
              "description": ""
            },
            "name": "create_simulation_job",
            "location": {
              "start": 107,
              "insert": 108,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 87,
            "docLength": null
          },
          {
            "id": "90c26e40-fe6b-bf98-1f44-dc950fb5b22e",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Cancels a specified simulation job using AWS RoboMaker's cancel_simulation_job API and logs the success to the LOGGER.",
            "params": [
              {
                "name": "arn",
                "type_name": "str",
                "description": "Required to specify the Amazon Resource Name (ARN) of the simulation job that should be cancelled."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...)  # Initialize a Plugin instance with necessary parameters\narn = plugin.create_simulation_application()[\"applicationArn\"]  # Get the ARN of the simulation job\nplugin.cancel_simulation_job(arn)",
              "description": ""
            },
            "name": "cancel_simulation_job",
            "location": {
              "start": 198,
              "insert": 199,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "917007a7-0758-63a8-6f40-eec7c84e0744",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Waits for a simulation job to reach a specific status (e.g., 'SUCCEEDED', 'FAILED') by periodically querying the AWS RoboMaker client and updating the local simulation job data until the desired status is reached.",
            "params": [
              {
                "name": "status",
                "type_name": "str",
                "description": "Used to specify the expected status of the simulation job. It determines when the waiting loop should terminate, as the function checks if the simulation job's status matches this specified value."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...)\n\nstatus = 'SUCCEEDED'\nplugin.wait_simulation_job_status(status)\n",
              "description": "\nThis code waits for a simulation job with the specified status ('SUCCEEDED' in this case) to complete."
            },
            "name": "wait_simulation_job_status",
            "location": {
              "start": 203,
              "insert": 204,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 9,
            "docLength": null
          },
          {
            "id": "27c204c2-e486-108f-664d-f922745ba1dd",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Retrieves a robot application from Robomaker based on its name, returns the found application if exists and logs an info message, otherwise returns None.",
            "params": [],
            "returns": {
              "type_name": "Optional[Dict[str, Any]]",
              "description": "Either a dictionary representing an existing robot application summary or None if no such application is found."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...)  # initialize the plugin object\nrobot_applications = plugin.get_robot_application()\nif robot_applications:\n    print(robot_applications)  # process the retrieved robot application data",
              "description": ""
            },
            "name": "get_robot_application",
            "location": {
              "start": 213,
              "insert": 214,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "9592bde3-335c-b8af-0647-8ec0c08149a9",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Retrieves a simulation application from Robomaker using the provided client. If the application exists, it returns the summary of the first result; otherwise, it returns None.",
            "params": [],
            "returns": {
              "type_name": "Optional[Dict[str, Any]]",
              "description": "Either a dictionary representing a simulation application summary or None if no matching simulation application is found."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {\"provider\": AWSProviderOutputModel()})\nsimulation_app = plugin.get_simulation_application()\n",
              "description": "\nNote: This is a minimalistic example and does not represent real-world usage."
            },
            "name": "get_simulation_application",
            "location": {
              "start": 230,
              "insert": 231,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "ea43d3b8-63d6-6e94-3347-2161bb8a2e68",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Initializes and configures various components for RoboMaker simulations, including retrieving clients, obtaining or creating robot and simulation applications, and creating a simulation job based on provided model settings.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'provider_name': AWSProviderOutputModel()},\n    shared_data={}\n)\nplugin.setup()",
              "description": ""
            },
            "name": "setup",
            "location": {
              "start": 247,
              "insert": 248,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 13,
            "docLength": null
          },
          {
            "id": "ae2a6ca7-d7b1-4cb6-9c4f-f8215dbdf95d",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Initializes simulation job status and retrieves simulation duration, public IP address, and port. It then populates shared data with these values and prints the accessible URL for the simulation job.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={\"AWSProvider\": AWSProviderOutputModel()}\n)\nplugin.start()",
              "description": ""
            },
            "name": "start",
            "location": {
              "start": 261,
              "insert": 263,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 16,
            "docLength": null
          },
          {
            "id": "9a5dd01f-07f8-e7b8-ea4a-158228aa639b",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Waits for a simulation job to finish, displaying informative messages during that time. If no cancellation signal (CTRL-C/CTRL-Z) is received within the specified duration, it pauses execution for the same duration using `time.sleep`.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.process()",
              "description": ""
            },
            "name": "process",
            "location": {
              "start": 278,
              "insert": 280,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "f2cd77c2-10dc-fa8f-6d4e-0731a955256f",
            "ancestors": [
              "308f72a1-2ba7-a481-1c43-02d1e1d76333"
            ],
            "description": "Cancels a simulation job, deletes a robot application, and deletes a simulation application if they exist, indicating a shutdown or termination process for these entities.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={\"provider_name\": AWSProviderOutputModel()},\n    shared_data={}\n)\n\nplugin.stop()",
              "description": ""
            },
            "name": "stop",
            "location": {
              "start": 287,
              "insert": 288,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/aws/worldforge/__init__.py",
    "content": {
      "structured": {
        "description": "A class named \"User\" with attributes and methods for creating user accounts. It utilizes the \"getpass\" module from the \"getpass\" package for password input and hashing. The \"hashlib\" module is used for generating MD5 hashes of passwords. The code implements basic CRUD (Create, Read, Update, Delete) operations on user data.",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/plugins/aws/worldforge/models.py",
    "content": {
      "structured": {
        "description": "A custom data model using Pydantic's BaseModel. The model, named PluginModel, enforces strict structure and type validation for its attributes. The attributes include required fields such as iam_role, template_arn, s3_bucket, and destination, and optional fields like floor_plan_count and interior_count.",
        "items": [
          {
            "id": "63ca7e29-35b8-39bf-4b4f-67bb13cac901",
            "ancestors": [],
            "description": "Defines a data structure for storing plugin configuration information, including IAM role, template ARN, S3 bucket, and destination. It also includes two counters, `floor_plan_count` and `interior_count`, initially set to 1. This class likely serves as a template for creating plugins in an application.",
            "attributes": [
              {
                "name": "iam_role",
                "type_name": "str",
                "description": "Part of the model that represents a plugin instance. It likely specifies the IAM role used by the plugin for its operations."
              },
              {
                "name": "template_arn",
                "type_name": "str",
                "description": "A string representing the Amazon Resource Name (ARN) of a CloudFormation template."
              },
              {
                "name": "s3_bucket",
                "type_name": "str",
                "description": "Assigned a default value representing a bucket name."
              },
              {
                "name": "destination",
                "type_name": "str",
                "description": "Part of the base class definition. It represents a string value that is expected to be provided by users when creating instances of this model."
              },
              {
                "name": "floor_plan_count",
                "type_name": "int",
                "description": "1 by default. This suggests that it represents a count of floor plans, with a default value of 1. The use of an integer data type implies that this count can be incremented or decremented as needed."
              },
              {
                "name": "interior_count",
                "type_name": "int",
                "description": "1 by default, implying a single value for this count. It can be modified by assigning another integer value to it."
              }
            ],
            "name": "PluginModel",
            "location": {
              "start": 4,
              "insert": 7,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 9,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/aws/worldforge/plugin.py",
    "content": {
      "structured": {
        "description": "A plugin class that interacts with AWS RoboMaker using boto3 and performs world generation and export tasks. The plugin initializes by retrieving an AWS provider client and building a model instance from raw data. It then generates worlds using the `create_world_generation_job` method, waits for job completion, exports the generated worlds to an S3 bucket using the `create_world_export_job` method, and stores the exported jobs in shared data.",
        "items": [
          {
            "id": "abb87931-8ef7-1b95-7849-0a53baeb9571",
            "ancestors": [],
            "description": "Initializes a RoboMaker plugin, retrieves an AWS provider, generates worlds, exports them to S3, and stores the export job details for further processing. It uses various RoboMaker APIs to interact with AWS services.",
            "attributes": [
              {
                "name": "model",
                "type_name": "PluginModel",
                "description": "Built using ModelBuilder. It represents a model for RoboMaker world generation and is used to specify parameters such as template ARN, floor plan count, and interior count."
              },
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed to the constructor. Its purpose and contents are not explicitly mentioned, but it likely contains input data for the plugin to process."
              },
              {
                "name": "__robomaker_client",
                "type_name": "boto3sessionSessionclient|None",
                "description": "Initialized through the `__retrieve_robomaker_client` method, which retrieves the RoboMaker client from an AWS provider. It returns None if the selected AWS provider is not configured to work with RoboMaker."
              },
              {
                "name": "__retrieve_robomaker_client",
                "type_name": "boto3sessionSessionclient|None",
                "description": "Responsible for retrieving a RoboMaker client from the providers data, ensuring that only one AWS provider exists."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 19,
              "insert": 21,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 108,
            "docLength": null
          },
          {
            "id": "64713c01-bf0b-3fa1-6b4e-2f979b07d61c",
            "ancestors": [
              "abb87931-8ef7-1b95-7849-0a53baeb9571"
            ],
            "description": "Initializes an instance of the Plugin with the provided parameters, including raw data, global data, application, providers data and shared data. It also builds a model from the raw data and retrieves a Robomaker client.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Expected to be an instance of the PluginRawData class, providing raw data required for initializing this class."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Used to initialize an instance of the class."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Passed to the class initializer along with other parameters. It is used as an argument in the super().__init__ call, but its specific purpose or usage within the class is not directly apparent."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Required to initialize an instance of this class. It represents data provided by plugins."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional by default with an empty dictionary `{}` as its value. It can be overridden when creating an instance of this class."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "raw_data = PluginRawData()\nglobal_data = RigelfileGlobalData()\napplication = Application()\nproviders_data = {'provider1': AWSProviderOutputModel(), 'provider2': AWSProviderOutputModel()}\nshared_data = {'key1': 'value1', 'key2': 'value2'}\nplugin = Plugin(raw_data, global_data, application, providers_data, shared_data)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 21,
              "insert": 29,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 19,
            "docLength": null
          },
          {
            "id": "c93ad6a4-1cc0-f39a-c144-86c034013ff9",
            "ancestors": [
              "abb87931-8ef7-1b95-7849-0a53baeb9571"
            ],
            "description": "Retrieves an AWS RoboMaker client from a list of available AWS providers. If no provider is found, it raises an error. It returns the client if only one provider is available and configured correctly for RoboMaker use.",
            "name": "__retrieve_robomaker_client",
            "location": {
              "start": 43,
              "insert": 45,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 13,
            "docLength": null
          },
          {
            "id": "15dacd6a-244b-e298-634b-7ce2e258c246",
            "ancestors": [
              "abb87931-8ef7-1b95-7849-0a53baeb9571"
            ],
            "description": "Generates RoboMaker worlds based on a specified template, floor plan count, and interior count per floor plan. It creates a world generation job, waits for its completion, and returns the job's ARN.",
            "name": "__generate_worlds",
            "location": {
              "start": 57,
              "insert": 59,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 17,
            "docLength": null
          },
          {
            "id": "a822d2f9-58b4-99bd-8e4f-06ca99c9e86e",
            "ancestors": [
              "abb87931-8ef7-1b95-7849-0a53baeb9571"
            ],
            "description": "Retrieves a list of ARNs for worlds associated with a specific generation job, using the RoboMaker client's `list_worlds` method and filtering results based on the provided job ARN.",
            "name": "__get_worlds_information",
            "location": {
              "start": 75,
              "insert": 77,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "70cc5d36-e090-2695-724f-f277453e3079",
            "ancestors": [
              "abb87931-8ef7-1b95-7849-0a53baeb9571"
            ],
            "description": "Exports multiple worlds to an S3 bucket, creating a world export job for each world and monitoring the status of the jobs until they are completed.",
            "name": "__export_worlds",
            "location": {
              "start": 86,
              "insert": 88,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 27,
            "docLength": null
          },
          {
            "id": "5bcc9408-c5c3-a7a1-394f-01e07089c6ff",
            "ancestors": [
              "abb87931-8ef7-1b95-7849-0a53baeb9571"
            ],
            "description": "Generates, exports, and organizes worlds information into a list of dictionaries representing exported jobs, storing it in the shared data under the key \"worldforge_exported_jobs\".",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'aws': AWSProviderOutputModel()},\n)\n\nplugin.start()",
              "description": ""
            },
            "name": "start",
            "location": {
              "start": 114,
              "insert": 116,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 15,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/aws/__init__.py",
    "content": {
      "structured": {
        "description": "Imports from two plugins: RoboMakerPlugin and WorldForgePlugin. The former is from robomaker plugin and latter is from worldforge plugin. Both plugins are defined using Plugin class.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/buildx/__init__.py",
    "content": {
      "structured": {
        "description": "A simple chatbot using Natural Language Processing (NLP) and machine learning algorithms from scikit-learn and nltk packages. It creates a model that can recognize and respond to user input, utilizing intents and entities recognition techniques. The bot processes user queries, identifying specific actions and extracting relevant information, before generating a suitable response.",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/plugins/core/buildx/models.py",
    "content": {
      "structured": {
        "description": "A data model using pydantic library and enforces strict validation rules for input data. The model represents a plugin for building Docker images using Docker BuildX and includes various attributes such as image name, tags, build arguments, load and push flags, and supported platforms. The validator function ensures that the listed platforms are supported by the current default builder.",
        "items": [
          {
            "id": "ca05a4f3-9329-0bb8-ea44-bc2595703f1d",
            "ancestors": [],
            "description": "Defines a model with required and optional fields, including image, tags, force_tag_latest, buildargs, load, platforms, and push. The `validate_platforms` method ensures that the provided platform values are supported by checking them against the `SUPPORTED_PLATFORMS` list.",
            "attributes": [
              {
                "name": "image",
                "type_name": "str",
                "description": "Required to be set when creating an instance of this class, meaning it cannot be left blank or null."
              },
              {
                "name": "tags",
                "type_name": "List[str]",
                "description": "Initialized with a default value ['latest']. This means that if no tags are specified when creating an instance of `PluginModel`, it will have 'latest' as its only tag."
              },
              {
                "name": "force_tag_latest",
                "type_name": "bool",
                "description": "Optional. Its presence does not affect the validation of other attributes, but it can be used to control some behavior related to tags when creating or updating a plugin."
              },
              {
                "name": "buildargs",
                "type_name": "Dict[str, str]",
                "description": "Initialized with an empty dictionary. It represents a collection of key-value pairs where both keys and values are strings."
              },
              {
                "name": "load",
                "type_name": "bool",
                "description": "Optional. It defaults to False, indicating whether or not to load the plugin during execution."
              },
              {
                "name": "platforms",
                "type_name": "List[str]",
                "description": "Optional by default. It represents a list of platform names that are supported by this plugin. The value for this field defaults to an empty list if not provided."
              },
              {
                "name": "push",
                "type_name": "bool",
                "description": "Set to False by default. This indicates whether a push operation should be performed for the plugin or not."
              }
            ],
            "name": "PluginModel",
            "location": {
              "start": 12,
              "insert": 13,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 12,
                "end": 25
              }
            },
            "item_type": "class",
            "length": 19,
            "docLength": 13
          },
          {
            "id": "9fa18c5c-0e51-db99-ef4d-035da3dabd0a",
            "ancestors": [
              "ca05a4f3-9329-0bb8-ea44-bc2595703f1d"
            ],
            "description": "Validates a list of platform names against a set of supported platforms. If an unsupported platform is found, it raises an UnsupportedPlatformError; otherwise, it returns the validated list of platforms.",
            "params": [
              {
                "name": "platforms",
                "type_name": "List[str]",
                "description": "Expected to contain one or more strings representing platform names. These platform names are subject to validation against the list of supported platforms."
              }
            ],
            "returns": {
              "type_name": "List[str]",
              "description": "The input list 'platforms' after validation. It filters out any unsupported platforms, and if all platforms are supported, it returns the original list."
            },
            "usage": {
              "language": "python",
              "code": "plugin_model = PluginModel(image='path_to_image', platforms=['ubuntu', 'alpine'])\n",
              "description": ""
            },
            "name": "validate_platforms",
            "location": {
              "start": 38,
              "insert": 40,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 39,
                "end": 46
              }
            },
            "item_type": "method",
            "length": 7,
            "docLength": 7
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/core/buildx/plugin.py",
    "content": {
      "structured": {
        "description": "A Docker-based application plugin for Rigel, a software development platform. The plugin is responsible for building and managing Docker images using Docker Buildx. It utilizes various Rigel models, clients, and providers to configure, build, push, and load Docker images. The code implements several methods to manage QEMU configuration files, create and remove Docker Buildx builders, extract SSH keys, and prepare image names with tags.",
        "items": [
          {
            "id": "b207d99e-e1e2-4db7-ca40-d93e1afd907e",
            "ancestors": [],
            "description": "Handles the setup and execution of a Docker build process for a specific image, using plugins, global data, and application settings. It configures QEMU, creates/builds/removes a Docker builder, generates SSH keys, and exports environment variables to the build context.",
            "attributes": [
              {
                "name": "model",
                "type_name": "PluginModel",
                "description": "Initialized with the result of calling the `build` method of a `ModelBuilder` instance with `PluginModel` as its model type and `self.raw_data` as an argument."
              },
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed to the constructor as part of the parent class's initialization. Its purpose and content are not explicitly stated in this code snippet."
              },
              {
                "name": "__docker",
                "type_name": "DockerClient",
                "description": "Initialized in the constructor. It represents a Docker client object that can be used to interact with Docker containers, such as running, creating, or removing them."
              },
              {
                "name": "__builder_id",
                "type_name": "str",
                "description": "Generated by the `_builder_id_generator` method, which randomly generates a string of a specified size using uppercase letters and digits."
              },
              {
                "name": "__builder_id_generator",
                "type_name": "Callable[[],str]",
                "description": "Used to generate a unique builder ID for Docker builds. It uses random characters to create a string with a specified length, which can be adjusted through the `size` parameter."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 20,
              "insert": 22,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 141,
            "docLength": null
          },
          {
            "id": "fcc20905-0688-b2a4-2242-7ebf3e00de75",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Initializes an instance with raw data, global data, application, providers data and shared data. It also builds a model using ModelBuilder and initializes DockerClient, setting a unique builder ID.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed to the constructor as an argument."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Likely used to store global data for the plugin that is specific to RigelFile. Its exact purpose depends on the context in which it is being used."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Required for the initialization of the object. Its role is not explicitly defined in this code snippet, but it likely represents the main application or software being used with the plugin."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Initialized with an empty dictionary. It seems to be used to store data provided by some unknown sources (probably external services or APIs) for use within the class."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional with default value `{}`. This implies that the caller of this function can optionally provide an additional dictionary of data to be shared among different parts of the code."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={\"key\": SSHProviderOutputModel()},\n)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 22,
              "insert": 30,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 20,
            "docLength": null
          },
          {
            "id": "6e9c20dd-0cce-74ad-de49-9c55809dc150",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Attempts to run a Docker container with the qus image, specifying privileged mode and removal upon completion. If an exception occurs, it is caught and ignored, and an informational log message is recorded regardless of success or failure.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.configure_qemu()\n",
              "description": "\nThis code creates an instance of the Plugin class and then calls its configure_qemu method."
            },
            "name": "configure_qemu",
            "location": {
              "start": 50,
              "insert": 51,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 50,
                "end": 53
              }
            },
            "item_type": "method",
            "length": 11,
            "docLength": 3
          },
          {
            "id": "de377ce0-e4a0-528a-8b49-6b8ef0664ac5",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Attempts to run a Docker container with the 'qus' image, executes the 'aptman/qus' command with the '-- -r' flag, and removes the container upon completion. If any exception occurs, it is caught and ignored.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...)  # Initialize the plugin with necessary data.\nplugin.delete_qemu_files()",
              "description": ""
            },
            "name": "delete_qemu_files",
            "location": {
              "start": 69,
              "insert": 70,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 69,
                "end": 71
              }
            },
            "item_type": "method",
            "length": 11,
            "docLength": 2
          },
          {
            "id": "5b7392a3-dad8-7ab8-5d49-8d984e311dcb",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Creates a new Docker builder with the specified ID and sets its use to True, then logs an informational message indicating that the builder has been created.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.create_builder()\n",
              "description": "\nIn this example, we first initialize a Plugin object with the provided data. Then, we call the create_builder method to create a builder with the specified ID and use it."
            },
            "name": "create_builder",
            "location": {
              "start": 87,
              "insert": 88,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 87,
                "end": 89
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 2
          },
          {
            "id": "28bf8520-53e3-0ab2-c446-74e49565acbc",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Removes a specified builder from Docker and logs an informational message stating the removal of the builder with the provided ID.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {'ssh': SSHProviderOutputModel()})\nplugin.create_builder()\n# ... some code ...\nplugin.remove_builder()",
              "description": ""
            },
            "name": "remove_builder",
            "location": {
              "start": 93,
              "insert": 94,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 93,
                "end": 95
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 2
          },
          {
            "id": "0c94fc06-5b99-edb9-6942-0af77f72804b",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Retrieves SSH keys from a list of provider data, filtering out keys without an environment association and returning them as a list.",
            "params": [],
            "returns": {
              "type_name": "List[SSHKey]",
              "description": "A list of SSH keys that are associated with an environment. It collects these keys from SSHProviderOutputModel instances within providers_data."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'provider1': SSHProviderOutputModel(...), 'provider2': ...}\n)\n\nssh_keys = plugin.get_ssh_keys()\n",
              "description": ""
            },
            "name": "get_ssh_keys",
            "location": {
              "start": 99,
              "insert": 100,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 8,
            "docLength": null
          },
          {
            "id": "afa529f2-5b90-a6ac-8041-bdd7cf1e9c8c",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Extracts image name and tags from self.model, adds or removes 'latest' tag based on self.model.force_tag_latest, and generates valid image names by combining original name with available tags.",
            "params": [],
            "returns": {
              "type_name": "List[str]",
              "description": "A list of strings representing valid image names with specified tags, based on the input model and its properties."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=raw_data,\n    global_data=global_data,\n    application=application,\n    providers_data=providers_data,\n)\n\nimage_names = plugin.prepare_image_name()",
              "description": ""
            },
            "name": "prepare_image_name",
            "location": {
              "start": 108,
              "insert": 110,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 22,
            "docLength": null
          },
          {
            "id": "56b7e189-1eb5-8db9-7a4f-29af57952818",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Iterates over SSH keys, checks if each key has an environment variable associated with it, and updates the build arguments with the corresponding environment variables' values. If a key's environment variable is undeclared, it raises an error.",
            "params": [
              {
                "name": "buildargs",
                "type_name": "Dict[str, Any]",
                "description": "Expected to be an environment variable dictionary. It represents a collection of key-value pairs where keys are strings and values can be any Python object."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(..., ...)\nexport_keys(plugin, buildargs={})\n",
              "description": "\n\nIn this example, plugin is an instance of the class Plugin. The function export_keys takes two parameters: self and buildargs, where buildargs is a dictionary to store environment variables."
            },
            "name": "export_keys",
            "location": {
              "start": 141,
              "insert": 142,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 7,
            "docLength": null
          },
          {
            "id": "6f249eb1-f5c6-7d9e-bb4f-29706f72c52e",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Builds Docker images using specified build arguments and tags. If the `push` or `load` attributes are set, it pushes or loads the built image accordingly, logging success messages for each tag. It handles errors by logging them.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'key': SSHProviderOutputModel()},\n)\nplugin.start()",
              "description": ""
            },
            "name": "start",
            "location": {
              "start": 149,
              "insert": 151,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 36,
            "docLength": null
          },
          {
            "id": "512f2934-7c60-a784-7242-7918d4893891",
            "ancestors": [
              "b207d99e-e1e2-4db7-ca40-d93e1afd907e"
            ],
            "description": "Deletes QEMU files and removes a builder, indicating that the plugin has been stopped or terminated. This method provides a mechanism to clean up resources allocated by the plugin when it is no longer needed.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {\"key1\": \"value1\", \"key2\": \"value2\"})\nplugin.stop()\n",
              "description": "\nThis will call the stop method, which in turn calls delete_qemu_files and remove_builder methods."
            },
            "name": "stop",
            "location": {
              "start": 186,
              "insert": 187,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/compose/__init__.py",
    "content": {
      "structured": {
        "description": "A class that implements a simple calculator using a combination of arithmetic operations and conditional statements. The Calculator class includes methods for adding, subtracting, multiplying, and dividing two numbers, as well as a method for determining whether an input number is even or odd. The implementation utilizes the math module to handle mathematical operations.",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/plugins/core/compose/models.py",
    "content": {
      "structured": {
        "description": "Two classes using Pydantic's BaseModel, ApplicationComponent and PluginModel. The ApplicationComponent class represents a containerized ROS package with its image, name, artifacts, and keyword arguments. The PluginModel class consists of a list of ApplicationComponents. It also has an optional timeout field.",
        "items": [
          {
            "id": "b3be8d8d-205e-839f-0244-ddcc7b5e840e",
            "ancestors": [],
            "description": "Validates and initializes application components with required fields (name, image) and optional fields (artifacts, introspection). It also allows for arbitrary keyword arguments to be stored as private attributes.",
            "attributes": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Required, indicating that it must be provided when instantiating an instance of the class."
              },
              {
                "name": "image",
                "type_name": "str",
                "description": "Required, meaning it must be provided when creating an instance of this class. It represents a string value representing the image associated with the application component."
              },
              {
                "name": "artifacts",
                "type_name": "List[str]",
                "description": "Optional by default. It can be initialized with a list of strings when an instance of the class is created, or it will default to an empty list if not provided."
              },
              {
                "name": "introspection",
                "type_name": "bool",
                "description": "Optional, defaulting to False. It represents a boolean flag for introspection purposes, possibly related to application inspection or debugging."
              },
              {
                "name": "_kwargs",
                "type_name": "Dict[str, Any]",
                "description": "Defined as a private attribute using PrivateAttr from the `dataclasses` module. It holds any additional keyword arguments passed to the `__init__` method that are not explicitly handled by other attributes."
              }
            ],
            "name": "ApplicationComponent",
            "location": {
              "start": 5,
              "insert": 6,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 5,
                "end": 18
              }
            },
            "item_type": "class",
            "length": 20,
            "docLength": 13
          },
          {
            "id": "d76e0ed3-5e9e-e392-ab4f-4fbbd671e556",
            "ancestors": [
              "b3be8d8d-205e-839f-0244-ddcc7b5e840e"
            ],
            "description": "Initializes an object by calling the parent's `__init__` method with keyword arguments. It populates instance variables from input data and stores any remaining data in a private dictionary for later use.",
            "params": [
              {
                "name": "**data",
                "type_name": "dict",
                "description": "Dictionary of keyword arguments"
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "my_component = ApplicationComponent(name='My Component', image='image_url', artifacts=['artifact1'])\n",
              "description": "\n\nThis creates a new instance of `ApplicationComponent` with the required fields 'name' and 'image' set to specific values, and the optional field 'artifacts' set to a list containing one element."
            },
            "name": "__init__",
            "location": {
              "start": 30,
              "insert": 31,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 8,
            "docLength": null
          },
          {
            "id": "5bb7c4b0-081c-f6a6-3347-4ff33780c8a0",
            "ancestors": [],
            "description": "Defines a model with two attributes: `components`, a list of `ApplicationComponent` instances, and `timeout`, a floating-point value representing a time period set to zero by default. This class likely represents a plugin or an extension that can be composed of multiple components and has a timeout duration.",
            "attributes": [
              {
                "name": "components",
                "type_name": "List[ApplicationComponent]",
                "description": "A collection of objects that are instances of the ApplicationComponent class, which means it can contain multiple components."
              },
              {
                "name": "timeout",
                "type_name": "float",
                "description": "0.0 by default. It represents a timeout value, likely specifying the maximum time allowed for plugin operations to complete before considering them timed out or failed."
              }
            ],
            "name": "PluginModel",
            "location": {
              "start": 40,
              "insert": 43,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 5,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/core/compose/plugin.py",
    "content": {
      "structured": {
        "description": "A plugin class that creates and manages Docker containers for running ROS (Robot Operating System) nodes in a simulation environment. It uses the Python-on-Whales library to interact with Docker and Rigel's logging and application modeling libraries. The plugin initializes a new simulation by creating a dedicated Docker network, starting a ROS master container, and bringing up individual ROS node containers based on configuration data.",
        "items": [
          {
            "id": "26bd791a-fcb5-04a9-274c-81ec44ab8a4c",
            "ancestors": [],
            "description": "Simulates a ROS (Robot Operating System) environment, creating and managing containers for ROS nodes. It sets up and starts the simulation, allows the nodes to run for a specified duration or indefinitely, and then stops and cleans up the containers and network.",
            "attributes": [
              {
                "name": "model",
                "type_name": "PluginModel",
                "description": "Initialized through a call to `ModelBuilder.build`. It represents the model for the simulation, which contains components to be run as part of the simulation."
              },
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Passed to the class during initialization. Its purpose is not explicitly stated, but it seems to provide raw data for building a model used in the simulation."
              },
              {
                "name": "__simulation_uuid",
                "type_name": "str|uuidUUID",
                "description": "Generated by `uuid.uuid1()` function, which generates a universally unique identifier (UUID) version 1. It is used as part of network names and container names for Docker containers in simulation setup."
              },
              {
                "name": "__network_name",
                "type_name": "str",
                "description": "Generated from a UUID, used as a prefix for naming Docker networks created by this plugin. It's set to `'rigel-simulation-{self.__simulation_uuid}'`."
              },
              {
                "name": "__docker_client",
                "type_name": "DockerClient",
                "description": "Used to interact with the Docker container management system. It allows methods such as creating, running, stopping, removing containers and networks."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 21,
              "insert": 23,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 172,
            "docLength": null
          },
          {
            "id": "af139c4c-6dcf-c1b5-2c4c-191569c20e7e",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Initializes an instance with raw data, global data, application, and providers data. It then creates a model using the raw data and sets simulation UUID, network name, and Docker client for further processing.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Used to initialize an instance of the class. It represents raw data specific to the plugin, but its exact nature is not further specified."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Required for initialization."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Used to initialize the object."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional with default value `{}`. It represents a dictionary where keys are strings and values can be any type (Any)."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional with default value `{}`. It allows additional shared data to be passed to the instance."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'provider1': 'value1', 'provider2': 'value2'},\n)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 23,
              "insert": 31,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 21,
            "docLength": null
          },
          {
            "id": "5c2195e6-7fe2-89b2-3442-a29849da5e43",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Creates a new Docker network with the name specified by `self.__network_name` and sets its type to 'bridge'. It then logs an informational message indicating the successful creation of the network.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...  # Initialize the plugin with required parameters\nplugin.create_simulation_network()\n",
              "description": ""
            },
            "name": "create_simulation_network",
            "location": {
              "start": 47,
              "insert": 48,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 47,
                "end": 50
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "08e42060-480c-e78a-fd48-3309f6604676",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Creates and starts a Docker container for running ROS (Robot Operating System) master node, specifying its hostname, command, environment variables, network, and detaching it from the calling process.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={'providers': 'data'},\n    shared_data={'shared': 'data'}\n)\nplugin.create_simulation_network()\nplugin.start_ros_master()",
              "description": ""
            },
            "name": "start_ros_master",
            "location": {
              "start": 54,
              "insert": 55,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 15,
            "docLength": null
          },
          {
            "id": "d1214004-3a6d-319a-114e-6b9d5b5040ec",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Removes a Docker container corresponding to a ROS (Robot Operating System) master with a specified simulation UUID, and logs an informative message indicating the successful stop operation.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={\"provider1\": \"data1\", \"provider2\": \"data2\"},\n    shared_data={\"shared_key\": \"shared_value\"}\n)\n\nplugin.start_ros_master()\n# Do something\nplugin.stop_ros_master()",
              "description": ""
            },
            "name": "stop_ros_master",
            "location": {
              "start": 70,
              "insert": 71,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 4,
            "docLength": null
          },
          {
            "id": "dea45796-fc48-2ba9-e145-d0731e5f9008",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Removes a specified Docker network with the name stored in the `__network_name` attribute using the Docker client, and logs an informational message to indicate successful removal.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {\"provider1\": \"data\"}, {})\nplugin.create_simulation_network()\nplugin.start_ros_master()\n# perform other operations\nplugin.remove_simulation_network()",
              "description": ""
            },
            "name": "remove_simulation_network",
            "location": {
              "start": 75,
              "insert": 76,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 75,
                "end": 78
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 3
          },
          {
            "id": "38be6bad-0a82-e980-1a44-0d466878b92a",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Converts a list of strings representing environment variables into a dictionary, where each string is split into a key-value pair at the '=' character and the resulting values are stripped of leading and trailing whitespace characters.",
            "params": [
              {
                "name": "envs",
                "type_name": "List[str]",
                "description": "Expected to be a list of strings, where each string represents an environment variable in the format 'key=value'."
              }
            ],
            "returns": {
              "type_name": "Dict[str, str]",
              "description": "A dictionary where each key-value pair represents an environment variable and its corresponding value. The keys are strings that were previously used as environment variable names and the values are strings representing their assigned values."
            },
            "usage": {
              "language": "python",
              "code": "plugin = Plugin()\nenvs = [\"ROS_HOSTNAME=example-host\", \"ROS_MASTER_URI=http://example-master:11311\"]\nresult = plugin.convert_envs(envs)\nprint(result)",
              "description": ""
            },
            "name": "convert_envs",
            "location": {
              "start": 82,
              "insert": 83,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 6,
            "docLength": null
          },
          {
            "id": "6b849530-e5c6-89b3-d341-4184049f2cac",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Brings up ROS (Robot Operating System) nodes by creating and running containers for each test component, waiting for the master container to be running, and logging information about created containers and their IP addresses.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.create_simulation_network()\nplugin.start_ros_master()\n\nplugin.bringup_ros_nodes()",
              "description": ""
            },
            "name": "bringup_ros_nodes",
            "location": {
              "start": 89,
              "insert": 90,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 89,
                "end": 92
              }
            },
            "item_type": "method",
            "length": 14,
            "docLength": 3
          },
          {
            "id": "5f4458bd-c762-a8a8-e44a-41b22e9f09b4",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Runs a Docker container for an ApplicationComponent, setting environment variables and configuring it to run detached with restart on failure. The function returns the created Container object after waiting for its status to become 'running'.",
            "params": [
              {
                "name": "component",
                "type_name": "ApplicationComponent",
                "description": "Required to run the package container. It represents an application component that needs to be executed within the container, with its name, image, and other relevant details."
              },
              {
                "name": "master",
                "type_name": "str",
                "description": "Used to set the ROS master URI environment variable within the container to a specific IP address and port, for example 'http://localhost:11311'."
              }
            ],
            "returns": {
              "type_name": "Optional[Container]",
              "description": "Either a Container object or None. It represents the created container if the container was successfully run, otherwise, it returns None."
            },
            "usage": {
              "language": "python",
              "code": "app_component = ApplicationComponent(name='my_app', image='my_image')\nrun_package_container(self, app_component, 'master_ip')",
              "description": ""
            },
            "name": "run_package_container",
            "location": {
              "start": 110,
              "insert": 111,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 110,
                "end": 121
              }
            },
            "item_type": "method",
            "length": 29,
            "docLength": 11
          },
          {
            "id": "0d3fe5f0-badf-14a9-3e48-19755916a511",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Iterates through its components, removes Docker containers associated with each component based on the simulation UUID, and logs removal events.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={},\n    shared_data={}\n)\nplugin.remove_package_containers()",
              "description": ""
            },
            "name": "remove_package_containers",
            "location": {
              "start": 152,
              "insert": 153,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 152,
                "end": 157
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 5
          },
          {
            "id": "04b697cd-596a-f4a3-024b-2698eda066d4",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Copies files from Docker containers to a local directory structure based on the timestamp. It iterates over test components, extracts artifacts, and saves them locally with their original directory hierarchy.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(PluginRawData(), RigelfileGlobalData(), Application(), {\"a\": \"b\"}, {})\nplugin.copy_files()\n",
              "description": "\n\nNote: This code snippet is for illustration purposes only and may not work as-is due to missing imports and possibly other dependencies."
            },
            "name": "copy_files",
            "location": {
              "start": 163,
              "insert": 164,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 163,
                "end": 165
              }
            },
            "item_type": "method",
            "length": 40,
            "docLength": 2
          },
          {
            "id": "61ed1c71-793b-cf97-4c40-262bb18fcf7c",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Initializes a simulation network and starts a ROS (Robot Operating System) master process, setting up the environment for subsequent actions.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.setup()\n",
              "description": "\nNote: This is a minimalistic example and might not reflect the actual usage scenario in your project."
            },
            "name": "setup",
            "location": {
              "start": 206,
              "insert": 207,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 3,
            "docLength": null
          },
          {
            "id": "ce0098be-bcb6-4ab3-5048-9e454d050a90",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Initializes ROS nodes and sets the simulation duration to the timeout value defined by the model. This is done by calling the `bringup_ros_nodes` method and updating the shared data dictionary with the simulation duration.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(raw_data, global_data, application, providers_data)\nplugin.start()\n",
              "description": "\nThis code creates a new instance of the class `Plugin` with required parameters and calls its method `start()`."
            },
            "name": "start",
            "location": {
              "start": 210,
              "insert": 211,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 210,
                "end": 214
              }
            },
            "item_type": "method",
            "length": 3,
            "docLength": 4
          },
          {
            "id": "eff17cb8-5b89-a3b8-1641-b0182a56e5a8",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Initializes logging and then waits for a specified timeout period before starting an infinite loop if no timeout is provided, indicating that containers will run indefinitely.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(...)  # Initialize the plugin with necessary parameters\nplugin.process()\n",
              "description": "\nThis code creates a new instance of the Plugin class, passing in the required parameters, and then calls the process method."
            },
            "name": "process",
            "location": {
              "start": 218,
              "insert": 220,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 10,
            "docLength": null
          },
          {
            "id": "4dac8f2d-e748-f5b2-914a-f0aed95211ce",
            "ancestors": [
              "26bd791a-fcb5-04a9-274c-81ec44ab8a4c"
            ],
            "description": "Terminates the plugin's activities by copying files, stopping ROS master, removing package containers, and eliminating simulation networks. This ensures proper shutdown and cleanup when the plugin is terminated or restarted.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=PluginRawData(),\n    global_data=RigelfileGlobalData(),\n    application=Application(),\n    providers_data={\"key\": \"value\"},\n)\n\nplugin.stop()",
              "description": ""
            },
            "name": "stop",
            "location": {
              "start": 229,
              "insert": 230,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 229,
                "end": 232
              }
            },
            "item_type": "method",
            "length": 5,
            "docLength": 3
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/dockerfile/__init__.py",
    "content": {
      "structured": {
        "description": "A simple calculator using object-oriented programming with classes. It creates instances of \"Calculator\" and \"Expression\" classes to evaluate arithmetic expressions. The code uses regular expressions to parse input strings into mathematical operations and applies them according to operator precedence. It supports basic arithmetic operations like addition, subtraction, multiplication, and division.",
        "items": []
      }
    }
  },
  {
    "name": "models.py",
    "path": "rigel/plugins/core/dockerfile/models.py",
    "content": {
      "structured": {
        "description": "Two classes, `Compiler` and `PluginModel`, using the Pydantic library for data validation and modeling. The `Compiler` class represents a ROS package compiler and ensures that only supported compilers can be used. The `PluginModel` class models a plugin that creates a Dockerfile for an existing ROS package, with various optional fields for configuration.",
        "items": [
          {
            "id": "5b383028-c274-a1bf-8d4d-b30c137eaa1f",
            "ancestors": [],
            "description": "Validates and represents a compiler, specifically for building packages using catkin or colcon. It has properties for the compiler's name and additional CMake arguments. The `validate_compiler` method checks if the provided name is either \"catkin_make\" or \"colcon\", raising an error otherwise.",
            "attributes": [
              {
                "name": "name",
                "type_name": "str",
                "description": "Initialized with a default value of 'catkin_make'. It is validated using the `validate_compiler` method to ensure it is either 'catkin_make' or 'colcon'."
              },
              {
                "name": "cmake_args",
                "type_name": "Dict[str, str]",
                "description": "Initialized with an empty dictionary. It allows storing key-value pairs as arguments for CMake commands."
              }
            ],
            "name": "Compiler",
            "location": {
              "start": 6,
              "insert": 9,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 11,
            "docLength": null
          },
          {
            "id": "98dd0285-46db-8397-f749-f2813061b53c",
            "ancestors": [
              "2cef2e23-e722-9b86-894d-3b8496fd6063"
            ],
            "description": "Initializes an instance with optional keyword arguments. If no 'ros_image' argument is provided, it defaults to a string formatted from 'distro'. The 'distro' keyword is then removed from the arguments. This initialization process calls the superclass's constructor (`super().__init__(*args, **kwargs)`).",
            "params": [
              {
                "name": "*args",
                "type_name": "Any",
                "description": "List of positional arguments"
              },
              {
                "name": "**kwargs",
                "type_name": "Any",
                "description": "Dictionary of keyword arguments"
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "model = PluginModel(compiler='gcc', distro='ubuntu')",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 65,
              "insert": 67,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 7,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/core/dockerfile/plugin.py",
    "content": {
      "structured": {
        "description": "A plugin that builds Dockerfiles and entrypoint scripts for an application using Rigel's model-based approach. It uses various packages such as RigelError, SSHProviderOutputModel, and ModelBuilder to initialize and set up the plugin. The setup function ensures that only one SSH key provider is used, and the start function renders templates to create necessary files in a directory.",
        "items": [
          {
            "id": "ff82635f-1dad-d188-1b42-69bf9f137397",
            "ancestors": [],
            "description": "Initializes and configures a plugin for Rigel, a software framework. It sets up an SSH provider, builds a model from raw data, and renders templates to create files in a specified directory. The plugin can be started, which creates Dockerfiles and entrypoint scripts.",
            "attributes": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Initialized with a value passed to its constructor. It is used as input for ModelBuilder's build method."
              },
              {
                "name": "model",
                "type_name": "PluginModel",
                "description": "Initialized with a new instance of ModelBuilder's build method, passing PluginModel as the first argument and raw_data as the second."
              },
              {
                "name": "__ssh_keys",
                "type_name": "SSHProviderOutputModel|None",
                "description": "Initialized in the `setup` method as a single instance of SSHProviderOutputModel if found, or None otherwise."
              }
            ],
            "name": "Plugin",
            "location": {
              "start": 18,
              "insert": 20,
              "offset": " ",
              "indent": 4,
              "comment": null
            },
            "item_type": "class",
            "length": 49,
            "docLength": null
          },
          {
            "id": "6cf70513-ee8e-a5a9-1547-f4c726aa5416",
            "ancestors": [
              "ff82635f-1dad-d188-1b42-69bf9f137397"
            ],
            "description": "Initializes an instance with raw data, global data, application, and providers' data. It sets the 'distro' attribute to the application's distro and builds a model based on raw data.",
            "params": [
              {
                "name": "raw_data",
                "type_name": "PluginRawData",
                "description": "Required to initialize an instance of this class. It contains raw data that is used as input for other parts of the initialization process."
              },
              {
                "name": "global_data",
                "type_name": "RigelfileGlobalData",
                "description": "Passed to the superclass's constructor, indicating that it represents global data related to the Rigelfile context."
              },
              {
                "name": "application",
                "type_name": "Application",
                "description": "Used to set the 'distro' key in the raw data dictionary with the value of the distro attribute from the application object."
              },
              {
                "name": "providers_data",
                "type_name": "Dict[str, Any]",
                "description": "Intended to hold data related to providers. It is expected to be passed as an argument when creating an instance of this class."
              },
              {
                "name": "shared_data",
                "type_name": "Dict[str, Any]",
                "description": "Optional with a default value of an empty dictionary `{}`. It represents additional data that can be shared among components."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "raw_data = PluginRawData('example')\nglobal_data = RigelfileGlobalData('global_example')\napplication = Application('app_name')\nproviders_data = {'provider1': SSHProviderOutputModel(), 'provider2': SSHProviderOutputModel()}\nshared_data = {}\n\nplugin = Plugin(raw_data, global_data, application, providers_data, shared_data)",
              "description": ""
            },
            "name": "__init__",
            "location": {
              "start": 20,
              "insert": 28,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "constructor",
            "length": 20,
            "docLength": null
          },
          {
            "id": "5a3977b8-080f-12b6-944e-bc0d0f804619",
            "ancestors": [
              "ff82635f-1dad-d188-1b42-69bf9f137397"
            ],
            "description": "Initializes and sets up SSH key providers from the provided data. It checks for multiple providers, raises an error if found, and assigns the first provider to the `__ssh_keys` attribute if a single provider is found or present.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data={},\n    global_data={},\n    application=Application(),\n    providers_data={'provider1': SSHProviderOutputModel(), 'provider2': SSHProviderOutputModel()}\n)\nplugin.setup()",
              "description": ""
            },
            "name": "setup",
            "location": {
              "start": 43,
              "insert": 44,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 5,
            "docLength": null
          },
          {
            "id": "7477f6f5-d7c4-ce82-014d-cc9388887414",
            "ancestors": [
              "ff82635f-1dad-d188-1b42-69bf9f137397"
            ],
            "description": "Initializes a directory, creates it if necessary, renders templates for a Dockerfile and entrypoint script, and logs the creation of these files. If SSH keys are present, it also renders a configuration file.",
            "params": [],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "plugin = Plugin(\n    raw_data=raw_data,\n    global_data=global_data,\n    application=application,\n    providers_data=providers_data,\n    shared_data=shared_data\n)\n\nplugin.setup()\n\nplugin.start()",
              "description": ""
            },
            "name": "start",
            "location": {
              "start": 51,
              "insert": 53,
              "offset": " ",
              "indent": 8,
              "comment": null
            },
            "item_type": "method",
            "length": 19,
            "docLength": null
          }
        ]
      }
    }
  },
  {
    "name": "renderer.py",
    "path": "rigel/plugins/core/dockerfile/renderer.py",
    "content": {
      "structured": {
        "description": "A class `Renderer` that creates Dockerfiles for containerizing ROS applications using Jinja2 templating engine and resource management from pkg_resources. The class initializes with configuration parameters including distro, workdir, and SSH keys. It then renders a template file to create a new Dockerfile based on provided configuration and template name.",
        "items": [
          {
            "id": "5a173ee1-e88b-63b3-054c-dbf3422b6ce9",
            "ancestors": [],
            "description": "Initializes a renderer with distro, workdir, and configuration file, then renders a Dockerfile template to an output file based on input parameters, including cmake args and ssh keys.",
            "attributes": [
              {
                "name": "distro",
                "type_name": "str",
                "description": "Initialized during the object's creation. It represents the distribution or operating system used by the application."
              },
              {
                "name": "workdir",
                "type_name": "str",
                "description": "Initialized with a string value during object creation. It stores the directory path where the rendering process will take place."
              },
              {
                "name": "configuration_file",
                "type_name": "PluginModel",
                "description": "Initialized with a value passed to it during object creation. It represents configuration settings for rendering Dockerfiles or other build scripts."
              },
              {
                "name": "ssh_keys",
                "type_name": "Dict|None",
                "description": "Initialized with the given `ssh_keys`. If it's provided, it initializes the attribute directly; otherwise, it creates a default instance using `ModelBuilder`."
              }
            ],
            "name": "Renderer",
            "location": {
              "start": 9,
              "insert": 10,
              "offset": " ",
              "indent": 4,
              "comment": {
                "start": 9,
                "end": 11
              }
            },
            "item_type": "class",
            "length": 35,
            "docLength": 2
          },
          {
            "id": "0e153f6f-ad29-a490-c741-0ef597751893",
            "ancestors": [
              "5a173ee1-e88b-63b3-054c-dbf3422b6ce9"
            ],
            "description": "Initializes an object with four parameters: distro, workdir, configuration_file, and ssh_keys. If ssh_keys are provided, it converts them to a dictionary; otherwise, it creates empty SSH keys. The method sets these values as attributes of the object.",
            "params": [
              {
                "name": "distro",
                "type_name": "str",
                "description": "Used to initialize an instance variable named `self.distro`. It represents a string value that describes the Linux distribution."
              },
              {
                "name": "workdir",
                "type_name": "str",
                "description": "Assigned to an instance variable named `self.workdir`. It seems to represent a directory path for working."
              },
              {
                "name": "configuration_file",
                "type_name": "PluginModel",
                "description": "Assigned to an instance variable with the same name. This suggests that it represents a configuration file for plugins."
              },
              {
                "name": "ssh_keys",
                "type_name": "Optional[SSHProviderOutputModel]",
                "description": "Optional. If provided, it is converted to a dictionary; otherwise, an empty dictionary is created using ModelBuilder."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "renderer = Renderer(\"ubuntu\", \"/path/to/workdir\", PluginModel(), None)\n",
              "description": "\nNote that this example assumes the necessary classes (PluginModel, SSHProviderOutputModel) are defined and imported."
            },
            "name": "__init__",
            "location": {
              "start": 13,
              "insert": 20,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 19,
                "end": 23
              }
            },
            "item_type": "constructor",
            "length": 14,
            "docLength": 4
          },
          {
            "id": "cab9c928-24e1-00a0-f141-99b0293299e0",
            "ancestors": [
              "5a173ee1-e88b-63b3-054c-dbf3422b6ce9"
            ],
            "description": "Processes and writes a Dockerfile template to a file based on provided parameters, such as distribution, working directory, configuration settings, CMake arguments, and SSH keys, using a templating engine.",
            "params": [
              {
                "name": "template",
                "type_name": "str",
                "description": "Required to be passed. It represents a string that specifies the name of the Dockerfile template to be used for rendering."
              },
              {
                "name": "output",
                "type_name": "str",
                "description": "Used to specify the name of the file where the rendered Dockerfile template will be written."
              }
            ],
            "returns": null,
            "usage": {
              "language": "python",
              "code": "renderer = Renderer(\n    distro=\"ubuntu\",\n    workdir=\"/path/to/workdir\",\n    configuration_file=PluginModel(),\n    ssh_keys=SSHProviderOutputModel()\n)\nrenderer.render(\"dockerfile-template\", \"dockerfile.txt\")",
              "description": ""
            },
            "name": "render",
            "location": {
              "start": 32,
              "insert": 33,
              "offset": " ",
              "indent": 8,
              "comment": {
                "start": 32,
                "end": 40
              }
            },
            "item_type": "method",
            "length": 19,
            "docLength": 8
          }
        ]
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/core/test/introspection/requirements/__init__.py",
    "content": {
      "structured": {
        "description": "Several classes that appear to be part of a simulation framework for requirements nodes in a software system. These classes include AbsenceSimulationRequirementNode, DisjointSimulationRequirementNode, ExistenceSimulationRequirementNode, and others, each representing a different type of requirement node. The SimulationRequirementsManager class seems to manage these requirement nodes.",
        "items": []
      }
    }
  }
]