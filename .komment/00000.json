[
  {
    "name": "__init__.py",
    "path": "rigel/files/__init__.py",
    "content": {
      "structured": {
        "description": "And imports various modules from separate files: RigelfileCreator, YAMLDataDecoder, YAMLDataLoader, and Renderer. These modules likely implement functionality related to working with data in YAML format, including decoding, loading, creating rigelfiles, and rendering. The code appears to utilize the yaml package for handling YAML data.",
        "items": []
      }
    }
  },
  {
    "name": "creator.py",
    "path": "rigel/files/creator.py",
    "content": {
      "structured": {
        "description": "A class `RigelfileCreator` that uses the `shutil.copyfile` function from the `shutil` package and `resource_filename` function from `pkg_resources` package to create a copy of the \"Rigelfile\" asset file from a resource directory to the current working directory. The `create` method of this class is responsible for performing this operation.",
        "items": []
      }
    }
  },
  {
    "name": "decoder.py",
    "path": "rigel/files/decoder.py",
    "content": {
      "structured": {
        "description": "A YAMLDataDecoder class that decodes YAML data by replacing template variables enclosed between `{{ }}` delimiters with their corresponding values from a dictionary or environment variables. The decoding process is recursive and supports complex data structures such as dictionaries and lists. It utilizes regular expressions to extract variable names and raises an error if a variable is undeclared.",
        "items": []
      }
    }
  },
  {
    "name": "loader.py",
    "path": "rigel/files/loader.py",
    "content": {
      "structured": {
        "description": "A class YAMLDataLoader that loads YAML data from a file and handles errors such as non-existent files, invalid YAML syntax, and empty files. It uses the yaml package for parsing YAML data and provides specific error messages for each type of error encountered. The load method attempts to load the YAML data from the specified filepath and returns it if successful or raises exceptions otherwise.",
        "items": []
      }
    }
  },
  {
    "name": "renderer.py",
    "path": "rigel/files/renderer.py",
    "content": {
      "structured": {
        "description": "A class named Renderer that uses Jinja2 templating engine to render templates based on a given configuration and saves it to an output file. The Renderer class initializes with a DockerSection object representing a configuration file for rendering templates. The `render` method generates a Dockerfile from a template, replacing placeholders with actual values from the configuration dictionary, and writes it to an output file.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/models/__init__.py",
    "content": {
      "structured": {
        "description": "Various import statements. It imports DockerfileSection, DockerSection, SSHKey, and SUPPORTED_PLATFORMS from a docker module. Additionally, it imports PluginSection, Rigelfile, and SimulationSection from other modules. These imports suggest that this code is part of a larger project focused on building or managing containerized environments using technologies like Docker.",
        "items": []
      }
    }
  },
  {
    "name": "docker.py",
    "path": "rigel/models/docker.py",
    "content": {
      "structured": {
        "description": "Several data models using Pydantic's BaseModel for representing various configurations and options in a Docker-based system called Rigel. The models include SSH keys, registry information, Docker configuration options, and Dockerfile sections. These models are used to validate and structure input data according to specific requirements, ensuring that the data is consistent and well-formed.",
        "items": []
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/models/plugin.py",
    "content": {
      "structured": {
        "description": "A class `PluginSection` using the `BaseModel` from the Pydantic package. The class represents a plugin model with required and optional fields, including validation for the `name` field that follows a specific format `<AUTHOR>/<PACKAGE>`.",
        "items": []
      }
    }
  },
  {
    "name": "rigelfile.py",
    "path": "rigel/models/rigelfile.py",
    "content": {
      "structured": {
        "description": "A Rigel configuration file model using Pydantic's BaseModel. The model consists of required and optional sections. The packages section is mandatory and accepts at least one declaration from either DockerSection or DockerfileSection. The deploy, simulate, and vars sections are optional, allowing for flexible storage and retrieval of variables with string keys.",
        "items": []
      }
    }
  },
  {
    "name": "simulation.py",
    "path": "rigel/models/simulation.py",
    "content": {
      "structured": {
        "description": "A SimulationSection class using Pydantic's BaseModel. It represents a simulation section in a model with required and optional fields. The class has three attributes: plugins, which is a list of PluginSection objects; introspection, which is an optional list of strings; and timeout, which defaults to 60 seconds if not provided.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/plugins/__init__.py",
    "content": {
      "structured": {
        "description": "Imports for three modules: PluginInstaller, PluginLoader, and Plugin from a package. The PluginInstaller module is responsible for installing plugins into a system. The PluginLoader module loads and manages plugin instances. The Plugin class represents a plugin itself, encapsulating its functionality and metadata.",
        "items": []
      }
    }
  },
  {
    "name": "installer.py",
    "path": "rigel/plugins/installer.py",
    "content": {
      "structured": {
        "description": "A class named `PluginInstaller` which is responsible for installing external plugins from a specified Git repository using pip. The installation process is initiated by constructing a URL based on the protocol and other attributes of the class.",
        "items": []
      }
    }
  },
  {
    "name": "loader.py",
    "path": "rigel/plugins/loader.py",
    "content": {
      "structured": {
        "description": "A PluginLoader class that validates and loads plugins using ModelBuilder from rigelcore.models. The loader checks if a plugin's entrypoint is compliant with specified methods such as 'run' and 'stop', then imports and initializes it. Plugins are checked for compliance at the entrypoint level, ensuring they meet specific requirements.",
        "items": []
      }
    }
  },
  {
    "name": "plugin.py",
    "path": "rigel/plugins/plugin.py",
    "content": {
      "structured": {
        "description": "A protocol named Plugin using Protocol and runtime_checkable from typing package. The protocol consists of two methods: run and stop. The run method initiates plugin execution while the stop method terminates its operation. The protocol is designed for plugins that can be executed and stopped.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "rigel/__init__.py",
    "content": {
      "structured": {
        "description": "A set of exceptions and imports several modules from within its own package structure. The exceptions relate to various errors that may occur during plugin installation and usage.",
        "items": []
      }
    }
  },
  {
    "name": "cli.py",
    "path": "rigel/cli.py",
    "content": {
      "structured": {
        "description": "A Rigel application that provides various tools for managing and deploying ROS (Robot Operating System) packages. It uses Click library for creating command-line interfaces and RigelCore library for working with Docker containers and plugins. The application can be used to initialize a Rigelfile, build and containerize packages, deploy simulations, run applications, and install plugins on different hosting platforms.",
        "items": []
      }
    }
  },
  {
    "name": "exceptions.py",
    "path": "rigel/exceptions.py",
    "content": {
      "structured": {
        "description": "A set of custom error types for Rigel applications, which are used to handle various exceptions that may occur during program execution. These errors include issues with Rigelfile not found or already exists, unformatted Rigelfile, incomplete Rigelfile, empty Rigelfile, unsupported compiler and platform, invalid plugin name, and unknown ROS packages.",
        "items": []
      }
    }
  },
  {
    "name": "__init__.py",
    "path": "tests/__init__.py",
    "content": {
      "structured": {
        "description": "A class named `Node` using the `dataclasses` package, which represents a node in a graph with an integer label and a list of child nodes. The class is then used to create a directed acyclic graph (DAG) and perform depth-first search (DFS) traversal on it using a recursive function.",
        "items": []
      }
    }
  },
  {
    "name": "test_exceptions.py",
    "path": "tests/test_exceptions.py",
    "content": {
      "structured": {
        "description": "A test suite using unittest package to validate exceptions raised by Rigel's exception classes. The tests cover various scenarios including file not found, file already exists, unformatted file, and others. The exceptions are used to handle specific error conditions during plugin installation, rigel file processing, and other operations.",
        "items": []
      }
    }
  },
  {
    "name": "test_files_creator.py",
    "path": "tests/test_files_creator.py",
    "content": {
      "structured": {
        "description": "A unit test suite for RigelfileCreator class using unittest and mock libraries. The test suite has one test case which verifies the creation of a new Rigelfile by mocking resource_filename and copyfile functions from shutil library. The creator creates a file at a specific path and copies it to another location.",
        "items": []
      }
    }
  },
  {
    "name": "test_files_decoder.py",
    "path": "tests/test_files_decoder.py",
    "content": {
      "structured": {
        "description": "A test suite using unittest package for testing the functionality of YAMLDataDecoder class from rigel.files module. The test suite consists of four tests that validate the decoding mechanism of YAMLDataDecoder with different data structures such as dictionaries and lists. The tests check if the decoder correctly handles references to unknown global variables and returns expected output.",
        "items": []
      }
    }
  },
  {
    "name": "test_files_loader.py",
    "path": "tests/test_files_loader.py",
    "content": {
      "structured": {
        "description": "A test suite for the YAMLDataLoader class in the rigel.files module. The tests check if various exceptions are thrown when trying to load YAML files with specific conditions: a file not found, an empty file and an unformatted file. These exceptions are handled using unittest's assertRaises method and mock_open to simulate file open operations.",
        "items": []
      }
    }
  },
  {
    "name": "test_files_renderer.py",
    "path": "tests/test_files_renderer.py",
    "content": {
      "structured": {
        "description": "A unit test suite for a class Renderer in rigel.files package, which is responsible for rendering template files using DockerSection configuration data. The test uses mocking and patching to verify that the renderer correctly renders a template file with specified input and output files, configuration data, and writes the rendered content to an output file.",
        "items": []
      }
    }
  },
  {
    "name": "test_models_docker.py",
    "path": "tests/test_models_docker.py",
    "content": {
      "structured": {
        "description": "Unit tests for two classes from the Rigel project: `SSHKey` and `DockerSection`. The tests verify that the classes throw expected exceptions when invalid inputs are provided.",
        "items": []
      }
    }
  },
  {
    "name": "test_models_plugin.py",
    "path": "tests/test_models_plugin.py",
    "content": {
      "structured": {
        "description": "A unit test class named PluginSectionTesting that tests the validity of a plugin name in the Rigel models. The test case checks if an InvalidPluginNameError is raised when an invalid plugin name is provided while creating an instance of PluginSection.",
        "items": []
      }
    }
  },
  {
    "name": "test_plugins_installer.py",
    "path": "tests/test_plugins_installer.py",
    "content": {
      "structured": {
        "description": "Unit tests for the PluginInstaller class in the rigel.plugins module. The tests cover various scenarios including invalid plugin names, extracting valid plugin names' parts, using SSH and HTTPS protocols, installing plugins via pip with correct arguments, and handling installation errors. The tests utilize mocking and patching to simulate various conditions and verify expected behavior of the installer.",
        "items": []
      }
    }
  },
  {
    "name": "test_plugins_loader.py",
    "path": "tests/test_plugins_loader.py",
    "content": {
      "structured": {
        "description": "Unit tests for the `PluginLoader` class in the Rigel project using the `unittest` framework and `pydantic` library. The tests cover various scenarios such as checking plugin compliance with expected methods, handling unknown plugins, and simulating plugin creation. The `PluginLoader` class is responsible for loading and initializing plugins based on their configuration.",
        "items": []
      }
    }
  }
]